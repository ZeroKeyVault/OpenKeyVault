<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Platform</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Kyber Post-Quantum Cryptography Library -->
    <script src="https://cdn.jsdelivr.net/npm/@pqcrypto/kyber768@1.0.0/dist/kyber768.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0; /* Light grey background */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }
        .container {
            background-color: #ffffff; /* White background for the main app */
            border-radius: 1rem; /* Rounded corners for the container */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            width: 95%;
            margin: 1.5rem auto;
            overflow: hidden;
        }
        .header {
            background-color: #f9f9f9; /* Slightly off-white for header */
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            text-align: center;
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
        }
        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            background-color: #f5f5f5; /* Light grey for sidebar */
            border-right: 1px solid #e0e0e0;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }
        .vault-list {
            flex-grow: 1;
            overflow-y: auto;
        }
        .vault-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #e0e0e0;
        }
        .vault-item:hover {
            background-color: #f0f0f0;
        }
        .vault-item.active {
            background-color: #e0e0e0;
            font-weight: 600;
        }
        .chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            overflow: hidden; /* Ensure this doesn't create extra scrollbars */
        }
        .messages-display {
            flex-grow: 1;
            background-color: #f9f9f9;
            border-radius: 0.75rem;
            padding: 1rem;
            overflow-y: auto; /* Make messages scrollable */
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
        }
        .message {
            margin-bottom: 0.75rem;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            /* Adjusted max-width for better responsiveness */
            max-width: calc(100% - 4rem); /* Allows some margin/padding */
            word-wrap: break-word; /* Ensures long words break */
        }
        .message.self {
            background-color: #e0e0e0; /* Light grey for self messages */
            margin-left: auto; /* Aligns to the right */
            text-align: right;
        }
        .message.other {
            background-color: #f0f0f0; /* Even lighter grey for other messages */
            margin-right: auto; /* Aligns to the left */
            text-align: left;
        }
        .message-sender {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }
        .message-content {
            font-size: 1rem;
            color: #333;
        }
        .message-timestamp {
            font-size: 0.7rem;
            color: #999;
            margin-top: 0.5rem;
            display: block;
        }
        .input-area {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .input-area input[type="text"] {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
            outline: none;
        }
        .input-area button {
            padding: 0.75rem 1.5rem;
            background-color: #888; /* Grey for buttons */
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .input-area button:hover {
            background-color: #666;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.show {
            visibility: visible;
            opacity: 1;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            position: relative;
        }
        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
            color: #888;
        }
        .modal-content h2 {
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #333;
            text-align: center;
        }
        .modal-content label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #555;
        }
        .modal-content input,
        .modal-content select {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
        }
        .modal-content button {
            width: 100%;
            padding: 0.75rem;
            background-color: #888;
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            font-size: 1.1rem;
            transition: background-color 0.2s ease;
        }
        .modal-content button:hover {
            background-color: #666;
        }
        .footer {
            text-align: center;
            padding: 1rem;
            color: #666;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        .message-file {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #e0e0e0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
        }
        .message-file svg {
            width: 1.25rem;
            height: 1.25rem;
            fill: #555;
        }
        .message-file span {
            color: #333;
            font-weight: 500;
        }
        .nuke-button {
            background-color: #f44336; /* Red for Nuke button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            margin-top: auto; /* Pushes it to the bottom of the sidebar */
        }
        .nuke-button:hover {
            background-color: #d32f2f;
        }
        .info-message {
            background-color: #fff3cd;
            color: #664d03;
            padding: 0.75rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ffecb3;
            text-align: center;
        }
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
                padding-bottom: 0;
            }
            .chat-area {
                padding-top: 0;
            }
            .vault-list {
                max-height: 200px; /* Limit height of vault list on small screens */
            }
            .header {
                font-size: 2rem;
                padding: 1rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            /* Adjust message max-width on very small screens if needed */
            .message {
                max-width: calc(100% - 2rem); /* More room for padding/margin on very small screens */
            }
            .message.self, .message.other {
                margin-left: 0; /* Remove auto margins to simplify */
                margin-right: 0;
                width: 100%; /* Take full width */
            }
            .message.self {
                text-align: right; /* Keep text alignment */
                background-color: #e0e0e0;
            }
            .message.other {
                text-align: left; /* Keep text alignment */
                background-color: #f0f0f0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">The Platform</div>
        <div class="main-content">
            <div class="sidebar">
                <div class="info-message" id="user-id-display">
                    Your ID: <span id="current-user-id">Generating...</span>
                </div>
                <button id="create-vault-btn" class="input-area button">Create Vault</button>
                <button id="join-vault-btn" class="input-area button">Join Vault</button>
                <div class="vault-list" id="vault-list">
                    <!-- Vault items will be injected here -->
                </div>
                <button id="nuke-btn" class="nuke-button">Nuke All Data</button>
            </div>
            <div class="chat-area">
                <div id="no-vault-selected" class="info-message text-center p-4 rounded-lg bg-gray-100 text-gray-700">
                    Select a vault to start chatting or create/join a new one.
                </div>
                <div id="chat-window" class="messages-display hidden">
                    <!-- Messages will be injected here -->
                </div>
                <div id="chat-input-area" class="input-area hidden">
                    <input type="text" id="message-input" placeholder="Type your message...">
                    <input type="file" id="file-input" class="hidden" accept="*/*">
                    <button id="attach-file-btn" title="Attach File">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                            <path fill-rule="evenodd" d="M18.97 3.659A2.25 2.25 0 0 0 17.023 2.25h-13.5A2.25 2.25 0 0 0 1.25 4.5v11.25c0 1.036.724 1.897 1.702 2.131a.75.75 0 0 0 .584.076l7.497-1.5a.75.75 0 0 0 .427-.715V6.25a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 .75.75v6.19l1.777.355a.75.75 0 0 0 .584-.076c.978-.234 1.702-1.095 1.702-2.131V4.5A2.25 2.25 0 0 0 18.97 3.659ZM12 15.75h.007v.008H12v-.008ZM10.5 6a.75.75 0 0 0-.75.75v4.5a.75.75 0 0 0 .75.75h.75a.75.75 0 0 0 .75-.75v-4.5a.75.75 0 0 0-.75-.75h-.75Z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button id="send-message-btn">Send</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Create Vault Modal -->
    <div id="create-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="create-vault-close">&times;</span>
            <h2>Create New Vault</h2>
            <form id="create-vault-form">
                <label for="vault-name">Vault Name:</label>
                <input type="text" id="vault-name" placeholder="e.g., Family Chat, Project X" required>
                <label for="vault-type">Vault Type:</label>
                <select id="vault-type" required>
                    <option value="private">Private (Direct Message)</option>
                    <option value="public">Public (Group)</option>
                </select>
                <label for="expiration-time">Expiration Time:</label>
                <select id="expiration-time" required>
                    <option value="1h">1 Hour</option>
                    <option value="5h">5 Hours</option>
                    <option value="24h">24 Hours</option>
                    <option value="1mo">1 Month</option>
                    <option value="3mo">3 Months</option>
                    <option value="6mo">6 Months</option>
                    <option value="1yr">1 Year</option>
                    <option value="never">Never</option>
                </select>
                <button type="submit">Create Vault</button>
                <div id="create-vault-hash-display" class="info-message mt-4 hidden">
                    Vault Hash: <span id="generated-vault-hash" class="font-mono break-all"></span><br>
                    <!-- FIX: Added type="button" to prevent accidental form submission -->
                    <button id="copy-hash-btn" type="button" class="mt-2 w-auto px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm">Copy Hash</button>
                </div>
            </form>
        </div>
    </div>
    <!-- Join Vault Modal -->
    <div id="join-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="join-vault-close">&times;</span>
            <h2>Join Existing Vault</h2>
            <form id="join-vault-form">
                <label for="join-vault-hash">Vault Hash:</label>
                <input type="text" id="join-vault-hash" placeholder="Enter vault hash" required>
                <label for="join-vault-name">Name for this Vault (for your reference):</label>
                <input type="text" id="join-vault-name" placeholder="e.g., John's Chat, Dev Team" required>
                <button type="submit">Join Vault</button>
            </form>
        </div>
    </div>
    <!-- Message Box for alerts -->
    <div id="message-box" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="message-box-close">&times;</span>
            <h2 id="message-box-title"></h2>
            <p id="message-box-content" class="text-center mb-4"></p>
            <button id="message-box-ok">OK</button>
        </div>
    </div>
    <footer class="footer">
        <!-- New Footer Text -->
        <p>Encrypted by The Laughing Buddha Protocol</p>
        <p>a Prakhar Solanki creation</p>
        <p>&copy;2025-The Platform.</p>
    </footer>
    <script>
        // Global variables for WebSocket and user ID
        let ws;
        let userId;
        let activeVaultId = null;
        const vaults = new Map(); // Stores vaultId -> { name, type, key, iv, messages: [] }
        // IMPORTANT: Update this to your Render WebSocket URL
        // Example: 'wss://your-app-name.onrender.com'
        const SERVER_URL = 'wss://server-618i.onrender.com'; // **UPDATE THIS LINE WITH YOUR RENDER URL**
        
        // --- Kyber Post-Quantum Cryptography Functions ---
        /**
         * Generates a Kyber keypair from a deterministic seed (vault hash)
         * @param {string} vaultHash - The vault hash used as seed
         * @returns {Promise<{publicKey: Uint8Array, secretKey: Uint8Array}>} Kyber keypair
         */
        async function generateKyberKeypairFromHash(vaultHash) {
            // Convert vault hash to seed (32 bytes for Kyber)
            const seed = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(vaultHash));
            const seedArray = new Uint8Array(seed);
            
            // Generate deterministic Kyber keypair
            const keypair = kyber768.keygen(seedArray);
            return {
                publicKey: keypair.publicKey,
                secretKey: keypair.secretKey
            };
        }
        
        /**
         * Encapsulates with Kyber public key to get shared secret and ciphertext
         * @param {Uint8Array} publicKey - The Kyber public key
         * @returns {{ciphertext: Uint8Array, sharedSecret: Uint8Array}}
         */
        function kyberEncapsulate(publicKey) {
            return kyber768.encapsulate(publicKey);
        }
        
        /**
         * Decapsulates Kyber ciphertext to get shared secret
         * @param {Uint8Array} ciphertext - The Kyber ciphertext
         * @param {Uint8Array} secretKey - The Kyber secret key
         * @returns {Uint8Array} The shared secret
         */
        function kyberDecapsulate(ciphertext, secretKey) {
            return kyber768.decapsulate(ciphertext, secretKey);
        }
        
        /**
         * Encrypts data using AES-GCM with a key derived from Kyber shared secret
         * @param {ArrayBuffer} data - The data to encrypt
         * @param {Uint8Array} sharedSecret - The Kyber shared secret
         * @returns {Promise<{encryptedData: ArrayBuffer, iv: Uint8Array}>}
         */
        async function encryptDataWithKyber(data, sharedSecret) {
            // Derive AES key from Kyber shared secret
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                sharedSecret,
                { name: "HKDF" },
                false,
                ["deriveKey"]
            );
            
            const aesKey = await crypto.subtle.deriveKey(
                {
                    name: "HKDF",
                    hash: "SHA-256",
                    salt: new Uint8Array(16),
                    info: new TextEncoder().encode("KyberVaultKey")
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
            
            // Encrypt data with derived AES key
            const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV for AES-GCM
            const encryptedData = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                aesKey,
                data
            );
            
            return { encryptedData, iv };
        }
        
        /**
         * Decrypts data using AES-GCM with a key derived from Kyber shared secret
         * @param {ArrayBuffer} encryptedData - The encrypted data
         * @param {Uint8Array} iv - The IV used for encryption
         * @param {Uint8Array} sharedSecret - The Kyber shared secret
         * @returns {Promise<ArrayBuffer>} The decrypted data
         */
        async function decryptDataWithKyber(encryptedData, iv, sharedSecret) {
            // Derive AES key from Kyber shared secret
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                sharedSecret,
                { name: "HKDF" },
                false,
                ["deriveKey"]
            );
            
            const aesKey = await crypto.subtle.deriveKey(
                {
                    name: "HKDF",
                    hash: "SHA-256",
                    salt: new Uint8Array(16),
                    info: new TextEncoder().encode("KyberVaultKey")
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
            
            // Decrypt data with derived AES key
            return crypto.subtle.decrypt(
                { name: "AES-GCM", iv: iv },
                aesKey,
                encryptedData
            );
        }
        
        /**
         * Encrypts a vault key using Kyber shared secret
         * @param {CryptoKey} vaultKey - The vault AES key
         * @param {Uint8Array} sharedSecret - The Kyber shared secret
         * @returns {Promise<{encryptedData: ArrayBuffer, iv: Uint8Array}>}
         */
        async function encryptVaultKeyWithKyber(vaultKey, sharedSecret) {
            const rawVaultKey = await exportKey(vaultKey);
            return encryptDataWithKyber(rawVaultKey, sharedSecret);
        }
        
        /**
         * Decrypts a vault key using Kyber shared secret
         * @param {ArrayBuffer} encryptedData - The encrypted vault key
         * @param {Uint8Array} iv - Initialization vector
         * @param {Uint8Array} sharedSecret - The Kyber shared secret
         * @returns {Promise<CryptoKey>}
         */
        async function decryptVaultKeyWithKyber(encryptedData, iv, sharedSecret) {
            const decryptedKey = await decryptDataWithKyber(encryptedData, iv, sharedSecret);
            return importKey(decryptedKey);
        }
        
        // --- Utility Functions ---
        /**
         * Displays a custom message box instead of alert().
         * @param {string} title - The title of the message box.
         * @param {string} message - The content message.
         * @param {function} onOk - Callback function when OK is clicked.
         */
        function showMessageBox(title, message, onOk = () => {}) {
            const msgBox = document.getElementById('message-box');
            document.getElementById('message-box-title').textContent = title;
            document.getElementById('message-box-content').textContent = message;
            msgBox.classList.add('show');
            const okBtn = document.getElementById('message-box-ok');
            const closeBtn = document.getElementById('message-box-close');
            const closeMessageBox = () => {
                msgBox.classList.remove('show');
                okBtn.removeEventListener('click', okHandler);
                closeBtn.removeEventListener('click', closeHandler);
                onOk();
            };
            const okHandler = () => closeMessageBox();
            const closeHandler = () => closeMessageBox();
            okBtn.addEventListener('click', okHandler);
            closeBtn.addEventListener('click', closeHandler);
        }
        /**
         * Copies text to the clipboard.
         * @param {string} text - The text to copy.
         */
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showMessageBox('Copied!', 'Vault hash copied to clipboard.');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessageBox('Error', 'Failed to copy hash. Please copy manually: ' + text);
            }
            document.body.removeChild(textarea);
        }
        /**
         * Converts a File object to a Base64 string.
         * @param {File} file - The file to convert.
         * @returns {Promise<string>} A promise that resolves with the Base64 string.
         */
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }
        /**
         * Converts a Base64 string back to a Blob.
         * @param {string} base64 - The Base64 string.
         * @param {string} mimeType - The MIME type of the original file.
         * @returns {Blob} The Blob object.
         */
        function base64ToBlob(base64, mimeType) {
            const byteString = atob(base64.split(',')[1]);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            return new Blob([ab], { type: mimeType });
        }
        /**
         * Downloads a file from Base64 data.
         * @param {string} base64Data - The Base64 encoded file data.
         * @param {string} filename - The name of the file to download.
         * @param {string} mimeType - The MIME type of the file.
         */
        function downloadFile(base64Data, filename, mimeType) {
            const blob = base64ToBlob(base64Data, mimeType);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        // --- Cryptography (The Laughing Buddha Protocol) ---
        /**
         * Generates a random AES-GCM key.
         * @returns {Promise<CryptoKey>} The generated key.
         */
        async function generateAesKey() {
            return crypto.subtle.generateKey(
                { name: "AES-GCM", length: 256 },
                true, // extractable
                ["encrypt", "decrypt"]
            );
        }
        /**
         * Derives a cryptographic key from a given password (hash) using PBKDF2.
         * This is used to encrypt/decrypt the vault's main AES key.
         * @param {string} password - The vault hash (password).
         * @param {Uint8Array} salt - A unique salt for key derivation.
         * @returns {Promise<CryptoKey>} The derived key.
         */
        async function deriveKeyFromHash(password, salt) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                { name: "PBKDF2" },
                false,
                ["deriveBits", "deriveKey"]
            );
            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000, // High iterations for security
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true, // extractable
                ["encrypt", "decrypt"]
            );
        }
        /**
         * Encrypts data using AES-GCM.
         * @param {ArrayBuffer} data - The data to encrypt.
         * @param {CryptoKey} key - The AES-GCM key.
         * @returns {Promise<{encryptedData: ArrayBuffer, iv: Uint8Array}>} Encrypted data and IV.
         */
        async function encryptData(data, key) {
            const iv = crypto.getRandomValues(new Uint8Array(16)); // 96-bit IV recommended for AES-GCM
            const encryptedData = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                data
            );
            return { encryptedData, iv };
        }
        /**
         * Decrypts data using AES-GCM.
         * @param {ArrayBuffer} encryptedData - The encrypted data.
         * @param {Uint8Array} iv - The IV used for encryption.
         * @param {CryptoKey} key - The AES-GCM key.
         * @returns {Promise<ArrayBuffer>} The decrypted data.
         */
        async function decryptData(encryptedData, iv, key) {
            try {
                return await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encryptedData
                );
            } catch (e) {
                console.error("Decryption failed:", e);
                throw new Error("Decryption failed. Key or data might be corrupted.");
            }
        }
        /**
         * Exports a CryptoKey to a raw ArrayBuffer.
         * @param {CryptoKey} key - The key to export.
         * @returns {Promise<ArrayBuffer>} The raw key data.
         */
        async function exportKey(key) {
            return crypto.subtle.exportKey("raw", key);
        }
        /**
         * Imports a raw ArrayBuffer into a CryptoKey.
         * @param {ArrayBuffer} rawKey - The raw key data.
         * @returns {Promise<CryptoKey>} The imported key.
         */
        async function importKey(rawKey) {
            return crypto.subtle.importKey(
                "raw",
                rawKey,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }
        /**
         * Encrypts a string message.
         * @param {string} message - The message string.
         * @param {CryptoKey} key - The AES-GCM key for the vault.
         * @returns {Promise<{encryptedMessage: string, iv: string}>} Base64 encoded encrypted message and IV.
         */
        async function encryptMessage(message, key) {
            const enc = new TextEncoder();
            const encoded = enc.encode(message);
            const { encryptedData, iv } = await encryptData(encoded, key);
            return {
                encryptedMessage: btoa(String.fromCharCode(...new Uint8Array(encryptedData))),
                iv: btoa(String.fromCharCode(...iv))
            };
        }
        /**
         * Decrypts a string message.
         * @param {string} encryptedMessageB64 - Base64 encoded encrypted message.
         * @param {string} ivB64 - Base64 encoded IV.
         * @param {CryptoKey} key - The AES-GCM key for the vault.
         * @returns {Promise<string>} The decrypted message string.
         */
        async function decryptMessage(encryptedMessageB64, ivB64, key) {
            try {
                const encryptedData = Uint8Array.from(atob(encryptedMessageB64), c => c.charCodeAt(0));
                const iv = Uint8Array.from(atob(ivB64), c => c.charCodeAt(0));
                const decryptedData = await decryptData(encryptedData, iv, key);
                const dec = new TextDecoder();
                return dec.decode(decryptedData);
            } catch (e) {
                console.error("Error decrypting message:", e);
                return "[Could not decrypt message]";
            }
        }
        // --- WebSocket Communication ---
        /**
         * Initializes the WebSocket connection.
         */
        function initWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            console.warn(`Attempting to connect to WebSocket server at: ${SERVER_URL}`);
            ws = new WebSocket(SERVER_URL);
            ws.onopen = async () => {
                console.log('WebSocket connected.');
                // Send user ID to server upon connection
                ws.send(JSON.stringify({ type: 'register', userId: userId }));
                // Load vaults from local storage AFTER registering with the server
                // This ensures we have our ID before trying to retrieve offline messages
                await loadVaultsFromLocalStorage();
            };
            ws.onmessage = async (event) => {
                let data;
                try {
                    data = JSON.parse(event.data);
                } catch (e) {
                    console.error("Failed to parse incoming WebSocket message:", e, event.data);
                    showMessageBox('Data Error', 'Received malformed data from server.');
                    return;
                }
                console.log('Received:', data);
                switch (data.type) {
                    case 'vault_created':
                        // Server sends back the hash and encrypted key for the creator
                        const { vaultId, vaultHash, vaultName, vaultType, expiration, encryptedKeyB64, ivB64, saltB64 } = data;
                        const salt = Uint8Array.from(atob(saltB64), c => c.charCodeAt(0));
                        const derivedKeyForVaultKey = await deriveKeyFromHash(vaultHash, salt);
                        const decryptedVaultKeyRaw = await decryptData(
                            Uint8Array.from(atob(encryptedKeyB64), c => c.charCodeAt(0)),
                            Uint8Array.from(atob(ivB64), c => c.charCodeAt(0)),
                            derivedKeyForVaultKey
                        );
                        const vaultAesKey = await importKey(decryptedVaultKeyRaw);
                        vaults.set(vaultId, {
                            id: vaultId,
                            name: vaultName,
                            type: vaultType,
                            expiration: expiration,
                            key: vaultAesKey,
                            messages: []
                        });
                        await saveVaultsToLocalStorage(); // Await saving
                        renderVaultList();
                        document.getElementById('generated-vault-hash').textContent = vaultHash;
                        document.getElementById('create-vault-hash-display').classList.remove('hidden');
                        showMessageBox('Vault Created!', `Your vault "${vaultName}" has been created. Share this hash: ${vaultHash}`, () => {
                            // Automatically select the new vault after creation
                            selectVault(vaultId);
                        });
                        break;
                        
                    case 'private_vault_created':
                        // Handle private vault creation (Kyber)
                        const { vaultId: privateVaultId, vaultHash: privateVaultHash, vaultName: privateVaultName, expiration: privateExpiration } = data;
                        
                        // Generate Kyber keypair from vault hash
                        const { secretKey } = await generateKyberKeypairFromHash(privateVaultHash);
                        
                        // Store vault with secret key (for later decapsulation)
                        vaults.set(privateVaultId, {
                            id: privateVaultId,
                            name: privateVaultName,
                            type: 'private',
                            expiration: privateExpiration,
                            vaultHash: privateVaultHash,
                            kyberSecretKey: secretKey,
                            messages: []
                        });
                        
                        await saveVaultsToLocalStorage();
                        renderVaultList();
                        document.getElementById('generated-vault-hash').textContent = privateVaultHash;
                        document.getElementById('create-vault-hash-display').classList.remove('hidden');
                        showMessageBox('Vault Created!', `Your private vault "${privateVaultName}" has been created. Share this hash: ${privateVaultHash}`, () => {
                            selectVault(privateVaultId);
                        });
                        break;
                        
                    case 'vault_joined':
                        // Server sends back the encrypted key for the joiner
                        const { joinedVaultId, joinedVaultName, joinedVaultType, joinedExpiration, encryptedKeyB64: joinedEncryptedKeyB64, ivB64: joinedIvB64, saltB64: joinedSaltB64, vaultHash: joinHashUsed } = data;
                        const joinSalt = Uint8Array.from(atob(joinedSaltB64), c => c.charCodeAt(0));
                        const derivedKeyForJoinedVaultKey = await deriveKeyFromHash(joinHashUsed, joinSalt);
                        const decryptedJoinedVaultKeyRaw = await decryptData(
                            Uint8Array.from(atob(joinedEncryptedKeyB64), c => c.charCodeAt(0)),
                            Uint8Array.from(atob(joinedIvB64), c => c.charCodeAt(0)),
                            derivedKeyForJoinedVaultKey
                        );
                        const joinedVaultAesKey = await importKey(decryptedJoinedVaultKeyRaw);
                        vaults.set(joinedVaultId, {
                            id: joinedVaultId,
                            name: joinedVaultName,
                            type: joinedVaultType,
                            expiration: joinedExpiration,
                            key: joinedVaultAesKey,
                            messages: []
                        });
                        await saveVaultsToLocalStorage(); // Await saving
                        renderVaultList();
                        showMessageBox('Vault Joined!', `You have joined "${joinedVaultName}".`, () => {
                            selectVault(joinedVaultId);
                        });
                        break;
                        
                    case 'private_vault_public_key':
                        try {
                            // Get vault hash from join form
                            const vaultHash = document.getElementById('join-vault-hash').value;
                            
                            // Generate Kyber keypair from vault hash
                            const { publicKey, secretKey } = await generateKyberKeypairFromHash(vaultHash);
                            
                            // Encapsulate to get shared secret
                            const publicKeyBuffer = Uint8Array.from(atob(data.publicKey), c => c.charCodeAt(0));
                            const { ciphertext, sharedSecret } = kyberEncapsulate(publicKeyBuffer);
                            
                            // Generate vault AES key
                            const vaultAesKey = await generateAesKey();
                            
                            // Encrypt vault key with shared secret
                            const { encryptedData, iv } = await encryptVaultKeyWithKyber(vaultAesKey, sharedSecret);
                            
                            // Send to server
                            sendMessageToServer({
                                type: 'submit_private_vault_key',
                                userId: userId,
                                vaultId: data.vaultId,
                                ciphertext: btoa(String.fromCharCode(...ciphertext)),
                                encryptedVaultKey: btoa(String.fromCharCode(...encryptedData)),
                                iv: btoa(String.fromCharCode(...iv))
                            });
                            
                            // Temporarily store vault (will be confirmed when creator responds)
                            vaults.set(data.vaultId, {
                                id: data.vaultId,
                                name: data.vaultName,
                                type: 'private',
                                expiration: data.expiration,
                                kyberSecretKey: secretKey,
                                messages: []
                            });
                            
                            await saveVaultsToLocalStorage();
                            renderVaultList();
                            showMessageBox('Vault Joined!', `You have joined "${data.vaultName}".`, () => {
                                selectVault(data.vaultId);
                            });
                        } catch (e) {
                            console.error("Error during private vault join:", e);
                            showMessageBox('Error', 'Failed to join private vault. Please try again.');
                        }
                        break;
                        
                    case 'private_vault_key':
                        try {
                            const vault = vaults.get(data.vaultId);
                            if (vault && vault.kyberSecretKey) {
                                // Decapsulate to get shared secret
                                const ciphertext = Uint8Array.from(atob(data.ciphertext), c => c.charCodeAt(0));
                                const sharedSecret = kyberDecapsulate(ciphertext, vault.kyberSecretKey);
                                
                                // Decrypt vault key
                                const encryptedVaultKey = Uint8Array.from(atob(data.encryptedVaultKey), c => c.charCodeAt(0));
                                const iv = Uint8Array.from(atob(data.iv), c => c.charCodeAt(0));
                                const vaultAesKey = await decryptVaultKeyWithKyber(encryptedVaultKey, iv, sharedSecret);
                                
                                // Update vault with proper key
                                vaults.set(data.vaultId, {
                                    ...vault,
                                    key: vaultAesKey,
                                    kyberSecretKey: null // Clear sensitive key
                                });
                                
                                await saveVaultsToLocalStorage();
                                if (activeVaultId === data.vaultId) {
                                    renderChatMessages(data.vaultId);
                                }
                            }
                        } catch (e) {
                            console.error("Error processing private vault key:", e);
                        }
                        break;
                        
                    case 'new_message':
                        const { vaultId: msgVaultId, senderId, encryptedMessage, iv, timestamp, isFile, fileName, fileMimeType } = data;
                        const vault = vaults.get(msgVaultId);
                        if (vault) {
                            try {
                                const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                                const messageObj = {
                                    sender: senderId,
                                    content: decryptedContent,
                                    timestamp: timestamp,
                                    isFile: isFile,
                                    fileName: fileName,
                                    fileMimeType: fileMimeType
                                };
                                vault.messages.push(messageObj);
                                console.log(`New message for vault ${msgVaultId}:`, messageObj);
                                await saveVaultsToLocalStorage(); // Await saving
                                if (activeVaultId === msgVaultId) {
                                    displayMessage(messageObj);
                                }
                            } catch (e) {
                                console.error("Failed to decrypt incoming message:", e);
                                // Display a placeholder or error message if decryption fails
                                const messageObj = {
                                    sender: senderId,
                                    content: "[Could not decrypt message]",
                                    timestamp: timestamp,
                                    isFile: false // Assume not a file if decryption failed
                                };
                                vault.messages.push(messageObj);
                                await saveVaultsToLocalStorage(); // Await saving
                                if (activeVaultId === msgVaultId) {
                                    displayMessage(messageObj);
                                }
                            }
                        } else {
                            console.warn(`Received message for unknown vault ID: ${msgVaultId}. Message:`, data);
                        }
                        break;
                    case 'offline_messages':
                        console.log(`Received ${data.messages.length} offline messages.`);
                        for (const msg of data.messages) {
                            const { vaultId: msgVaultId, senderId, encryptedMessage, iv, timestamp, isFile, fileName, fileMimeType } = msg;
                            const vault = vaults.get(msgVaultId);
                            if (vault) {
                                try {
                                    const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                                    const messageObj = {
                                        sender: senderId,
                                        content: decryptedContent,
                                        timestamp: timestamp,
                                        isFile: isFile,
                                        fileName: fileName,
                                        fileMimeType: fileMimeType
                                    };
                                    vault.messages.push(messageObj);
                                    console.log(`Processed offline message for vault ${msgVaultId}:`, messageObj);
                                } catch (e) {
                                    console.error("Failed to decrypt offline message:", e);
                                    vault.messages.push({
                                        sender: senderId,
                                        content: "[Decryption Failed]",
                                        timestamp: timestamp,
                                        isFile: false
                                    });
                                }
                            } else {
                                console.warn(`Received offline message for unknown vault ID: ${msgVaultId}. Message:`, msg);
                            }
                        }
                        await saveVaultsToLocalStorage(); // Await saving
                        // Re-render chat for the active vault if new offline messages were added to it
                        if (activeVaultId && vaults.has(activeVaultId)) {
                            renderChatMessages(activeVaultId);
                        }
                        break;
                    case 'error':
                        showMessageBox('Error', data.message);
                        break;
                    case 'vault_expired_notification':
                        const { expiredVaultId, expiredVaultName } = data;
                        if (vaults.has(expiredVaultId)) {
                             vaults.delete(expiredVaultId);
                             await saveVaultsToLocalStorage(); // Await saving after deletion
                             renderVaultList();
                             if (activeVaultId === expiredVaultId) {
                                 activeVaultId = null;
                                 document.getElementById('chat-window').classList.add('hidden');
                                 document.getElementById('chat-input-area').classList.add('hidden');
                                 document.getElementById('no-vault-selected').classList.remove('hidden');
                             }
                             showMessageBox('Vault Expired', `The vault "${expiredVaultName}" has expired and all its data has been wiped.`);
                        } else {
                            console.log(`Received expiration for unknown or already removed vault: ${expiredVaultName} (${expiredVaultId})`);
                        }
                        break;
                }
            };
            ws.onclose = () => {
                console.log('WebSocket disconnected. Attempting to reconnect in 5 seconds...');
                // Consider adding a visual indicator for disconnection
                setTimeout(initWebSocket, 5000);
            };
            ws.onerror = (event) => {
                console.error('WebSocket error event:', event);
                showMessageBox('Connection Error',
                    `Could not connect to the server at ${SERVER_URL}. ` +
                    `Please ensure:
                    1. The Node.js server is running.
                    2. The SERVER_URL in index.html is correct.
                    3. If deployed (e.g., to Render), use 'wss://' for the SERVER_URL.`);
            };
        }
        /**
         * Sends a message to the WebSocket server.
         * @param {object} message - The message object to send.
         */
        function sendMessageToServer(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                showMessageBox('Connection Error', 'Not connected to server. Please wait or refresh.');
                console.warn("Attempted to send message while WebSocket is not open.", message);
            }
        }
        // --- Local Storage Management ---
        /**
         * Saves all vaults data to localStorage.
         * Note: CryptoKey objects cannot be directly stored. We export them to raw ArrayBuffer (Base64)
         * and re-import them when loading.
         */
        async function saveVaultsToLocalStorage() {
            console.log("Saving vaults to localStorage...");
            const serializableVaults = [];
            for (const [id, vault] of vaults.entries()) {
                try {
                    let keyData;
                    if (vault.key) {
                        const exportedKey = await exportKey(vault.key);
                        keyData = btoa(String.fromCharCode(...new Uint8Array(exportedKey)));
                    } else {
                        keyData = null;
                    }
                    
                    serializableVaults.push({
                        id: vault.id,
                        name: vault.name,
                        type: vault.type,
                        expiration: vault.expiration,
                        key: keyData,
                        vaultHash: vault.vaultHash,
                        kyberSecretKey: vault.kyberSecretKey ? btoa(String.fromCharCode(...vault.kyberSecretKey)) : null,
                        messages: vault.messages // Messages are already serializable
                    });
                } catch (e) {
                    console.error(`Failed to export key for vault ${id}:`, e);
                    // Optionally, remove this vault from the list to be saved if its key is corrupted
                }
            }
            try {
                localStorage.setItem('thePlatformVaults', JSON.stringify(serializableVaults));
                console.log("Vaults successfully saved to localStorage.");
            } catch (e) {
                console.error("Error saving vaults to localStorage:", e);
                showMessageBox('Storage Error', 'Could not save data to local storage. Your browser might be full or private browsing is enabled.');
            }
        }
        /**
         * Loads vaults data from localStorage.
         */
        async function loadVaultsFromLocalStorage() {
            console.log("Loading vaults from localStorage...");
            const storedVaults = localStorage.getItem('thePlatformVaults');
            vaults.clear(); // Clear existing vaults before loading
            if (storedVaults) {
                try {
                    const parsedVaults = JSON.parse(storedVaults);
                    for (const serializedVault of parsedVaults) {
                        try {
                            let key = null;
                            if (serializedVault.key) {
                                key = await importKey(Uint8Array.from(atob(serializedVault.key), c => c.charCodeAt(0)));
                            }
                            
                            vaults.set(serializedVault.id, {
                                id: serializedVault.id,
                                name: serializedVault.name,
                                type: serializedVault.type,
                                expiration: serializedVault.expiration,
                                key: key,
                                vaultHash: serializedVault.vaultHash,
                                kyberSecretKey: serializedVault.kyberSecretKey ? Uint8Array.from(atob(serializedVault.kyberSecretKey), c => c.charCodeAt(0)) : null,
                                messages: serializedVault.messages || []
                            });
                            console.log(`Loaded vault: ${serializedVault.name} (${serializedVault.id})`);
                        } catch (e) {
                            console.error(`Failed to load vault ${serializedVault.id} from localStorage (key import failed):`, e);
                            // This vault might be corrupted or key unimportable, skip it.
                        }
                    }
                    console.log(`Finished loading ${vaults.size} vaults from localStorage.`);
                    renderVaultList();
                    // If there are vaults, select the first one by default or previously active
                    if (vaults.size > 0) {
                        const lastActiveVaultId = localStorage.getItem('lastActiveVaultId');
                        if (lastActiveVaultId && vaults.has(lastActiveVaultId)) {
                            selectVault(lastActiveVaultId);
                        } else {
                            selectVault(vaults.keys().next().value); // Select the first available vault
                        }
                    } else {
                        console.log("No vaults found in localStorage.");
                        document.getElementById('no-vault-selected').classList.remove('hidden');
                        document.getElementById('chat-window').classList.add('hidden');
                        document.getElementById('chat-input-area').classList.add('hidden');
                    }
                } catch (e) {
                    console.error("Error parsing vaults from localStorage:", e);
                    showMessageBox('Data Corruption', 'Local vault data is corrupted. Clearing data and starting fresh.');
                    localStorage.removeItem('thePlatformVaults'); // Clear corrupted data
                    // Reload the page or simply continue with empty vaults
                    renderVaultList();
                }
            } else {
                console.log("No vaults found in localStorage initially.");
            }
        }
        /**
         * Clears all local data (vaults, messages, user ID).
         */
        function nukeAllData() {
            showMessageBox('Confirm Nuke', 'Are you sure you want to wipe ALL your local data and disconnect? This action cannot be undone. This will also attempt to clear your data on the server.', async () => {
                localStorage.removeItem('thePlatformVaults');
                localStorage.removeItem('thePlatformUserId');
                localStorage.removeItem('lastActiveVaultId');
                vaults.clear();
                activeVaultId = null;
                document.getElementById('chat-window').innerHTML = '';
                document.getElementById('vault-list').innerHTML = '';
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('current-user-id').textContent = 'Nuked! Reopen for new ID.';
                // Inform server to remove user's data
                sendMessageToServer({ type: 'nuke', userId: userId });
                // Simulate closing the page by clearing content and displaying a message
                document.body.innerHTML = `
                    <div class="flex flex-col items-center justify-center min-h-screen bg-gray-100 text-gray-700">
                        <h1 class="text-4xl font-bold mb-4">Data Nuked!</h1>
                        <p class="text-lg">All your local data has been wiped.</p>
                        <p class="text-lg">To start fresh, please reopen "The Platform".</p>
                    </div>
                `;
            });
        }
        // --- UI Rendering ---
        /**
         * Renders the list of vaults in the sidebar.
         */
        function renderVaultList() {
            const vaultListDiv = document.getElementById('vault-list');
            vaultListDiv.innerHTML = '';
            if (vaults.size === 0) {
                vaultListDiv.innerHTML = '<p class="text-center text-gray-500 text-sm mt-4">No vaults yet. Create or join one!</p>';
            }
            vaults.forEach(vault => {
                const vaultItem = document.createElement('div');
                vaultItem.className = `vault-item ${activeVaultId === vault.id ? 'active' : ''}`;
                vaultItem.dataset.vaultId = vault.id;
                vaultItem.innerHTML = `
                    <span>${vault.name} (${vault.type === 'private' ? 'DM' : 'Group'})</span>
                    <span class="text-xs text-gray-500">${vault.expiration === 'never' ? 'Never Exp.' : `Exp: ${vault.expiration}`}</span>
                `;
                vaultItem.addEventListener('click', () => selectVault(vault.id));
                vaultListDiv.appendChild(vaultItem);
            });
        }
        /**
         * Displays a single message in the chat window.
         * @param {object} message - The message object.
         */
        function displayMessage(message) {
            const chatWindow = document.getElementById('chat-window');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.sender === userId ? 'self' : 'other'}`;
            const senderSpan = document.createElement('div');
            senderSpan.className = 'message-sender';
            senderSpan.textContent = message.sender === userId ? 'You' : `User: ${message.sender.substring(0, 8)}...`;
            messageDiv.appendChild(senderSpan);
            if (message.isFile) {
                const fileLink = document.createElement('div');
                fileLink.className = 'message-file';
                fileLink.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path d="M19.5 7.5c-1.25 0-2.5.31-3.57.88-.85.45-1.48 1.12-1.87 1.94-.17.36-.31.75-.41 1.15a.75.75 0 0 1-1.09-.72c.16-.49.37-.96.6-1.42.34-.67.79-1.28 1.34-1.83 1.04-1.04 2.39-1.66 3.86-1.8.02-.01.04-.02.06-.02a.75.75 0 0 1 .78 1.25c-.06.05-.12.09-.18.14-.8.6-1.25 1.4-1.25 2.25v.75h.75c.85 0 1.65-.45 2.25-1.25.05-.06.09-.12.14-.18a.75.75 0 0 1 1.25.78c-.01.02-.02.04-.02.06-.14 1.47-.76 2.82-1.8 3.86-1.04 1.04-2.39 1.66-3.86 1.8-.02.01-.04.02-.06.02a.75.75 0 0 1-.78-1.25c.06-.05.12-.09.18-.14.8-.6 1.25-1.4 1.25-2.25V7.5h-.75Zm-10.5 0c-1.25 0-2.5.31-3.57.88-.85.45-1.48 1.12-1.87 1.94-.17.36-.31.75-.41 1.15a.75.75 0 0 1-1.09-.72c.16-.49.37-.96.6-1.42.34-.67.79-1.28 1.34-1.83 1.04-1.04 2.39-1.66 3.86-1.8.02-.01.04-.02.06-.02a.75.75 0 0 1 .78 1.25c-.06.05-.12.09-.18.14-.8.6-1.25 1.4-1.25 2.25v.75h.75c.85 0 1.65-.45 2.25-1.25.05-.06.09-.12.14-.18a.75.75 0 0 1 1.25.78c-.01.02-.02.04-.02.06-.14 1.47-.76 2.82-1.8 3.86-1.04 1.04-2.39 1.66-3.86 1.8-.02.01-.04.02-.06.02a.75.75 0 0 1-.78-1.25c.06-.05.12-.09.18-.14.8-.6 1.25-1.4 1.25-2.25V7.5h-.75Z" />
                    </svg>
                    <span>${message.fileName || 'File'}</span>
                `;
                fileLink.addEventListener('click', () => downloadFile(message.content, message.fileName, message.fileMimeType));
                messageDiv.appendChild(fileLink);
            } else {
                const contentSpan = document.createElement('div');
                contentSpan.className = 'message-content';
                contentSpan.textContent = message.content;
                messageDiv.appendChild(contentSpan);
            }
            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = new Date(message.timestamp).toLocaleTimeString();
            messageDiv.appendChild(timestampSpan);
            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight; // Scroll to bottom
        }
        /**
         * Renders all messages for the currently selected vault.
         * @param {string} vaultId - The ID of the vault whose messages to render.
         */
        function renderChatMessages(vaultId) {
            const chatWindow = document.getElementById('chat-window');
            chatWindow.innerHTML = ''; // Clear previous messages
            const vault = vaults.get(vaultId);
            if (vault && vault.messages) {
                // Sort messages by timestamp to ensure correct order
                vault.messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                vault.messages.forEach(msg => displayMessage(msg));
            }
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }
        /**
         * Selects a vault and displays its chat.
         * @param {string} vaultId - The ID of the vault to select.
         */
        function selectVault(vaultId) {
            if (!vaults.has(vaultId)) {
                console.warn(`Attempted to select non-existent vault: ${vaultId}`);
                showMessageBox('Vault Not Found', 'This vault no longer exists locally. It might have expired or been removed.');
                activeVaultId = null;
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                renderVaultList(); // Re-render to ensure no vault is marked active
                return;
            }
            activeVaultId = vaultId;
            localStorage.setItem('lastActiveVaultId', vaultId); // Using localStorage for persistence
            renderVaultList(); // Update active class
            document.getElementById('no-vault-selected').classList.add('hidden');
            document.getElementById('chat-window').classList.remove('hidden');
            document.getElementById('chat-input-area').classList.remove('hidden');
            renderChatMessages(vaultId);
            document.getElementById('message-input').focus();
            console.log(`Selected vault: ${vaults.get(vaultId).name} (${vaultId})`);
        }
        // --- Event Listeners and Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            // Generate or retrieve unique user ID from localStorage
            userId = localStorage.getItem('thePlatformUserId');
            if (!userId) {
                userId = crypto.randomUUID(); // Generate a new complex random ID
                localStorage.setItem('thePlatformUserId', userId);
                console.log(`Generated new user ID: ${userId}`);
            } else {
                console.log(`Loaded existing user ID: ${userId}`);
            }
            document.getElementById('current-user-id').textContent = userId;
            initWebSocket(); // Initialize WebSocket connection
            // Modals
            const createVaultModal = document.getElementById('create-vault-modal');
            const joinVaultModal = document.getElementById('join-vault-modal');
            const createVaultBtn = document.getElementById('create-vault-btn');
            const joinVaultBtn = document.getElementById('join-vault-btn');
            const createVaultClose = document.getElementById('create-vault-close');
            const joinVaultClose = document.getElementById('join-vault-close');
            createVaultBtn.addEventListener('click', () => {
                createVaultModal.classList.add('show');
                document.getElementById('create-vault-hash-display').classList.add('hidden'); // Hide hash display initially
                document.getElementById('create-vault-form').reset(); // Clear form
            });
            joinVaultBtn.addEventListener('click', () => {
                joinVaultModal.classList.add('show');
                document.getElementById('join-vault-form').reset(); // Clear form
            });
            createVaultClose.addEventListener('click', () => createVaultModal.classList.remove('show'));
            joinVaultClose.addEventListener('click', () => joinVaultModal.classList.remove('show'));
            // Create Vault Form Submission
            document.getElementById('create-vault-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const vaultName = document.getElementById('vault-name').value;
                const vaultType = document.getElementById('vault-type').value;
                const expirationTime = document.getElementById('expiration-time').value;
                
                if (vaultType === 'private') {
                    // Generate vault hash (as before)
                    const vaultHash = crypto.randomBytes(16).toString('hex');
                    
                    // Generate Kyber keypair from vault hash
                    const { publicKey, secretKey } = await generateKyberKeypairFromHash(vaultHash);
                    
                    // Store secret key temporarily
                    const vaultId = crypto.randomUUID();
                    vaults.set(vaultId, {
                        id: vaultId,
                        name: vaultName,
                        type: vaultType,
                        expiration: expirationTime,
                        vaultHash: vaultHash,
                        kyberSecretKey: secretKey,
                        messages: []
                    });
                    
                    // Send public key to server
                    sendMessageToServer({
                        type: 'create_private_vault',
                        userId: userId,
                        vaultId: vaultId,
                        vaultName: vaultName,
                        expiration: expirationTime,
                        vaultHash: vaultHash,
                        publicKey: btoa(String.fromCharCode(...publicKey))
                    });
                } else {
                    // Existing public vault flow
                    const vaultAesKey = await generateAesKey();
                    const rawVaultAesKey = await exportKey(vaultAesKey);
                    const salt = crypto.getRandomValues(new Uint8Array(16));
                    sendMessageToServer({
                        type: 'create_vault',
                        userId: userId,
                        vaultName: vaultName,
                        vaultType: vaultType,
                        expiration: expirationTime,
                        rawVaultKeyB64: btoa(String.fromCharCode(...new Uint8Array(rawVaultAesKey))),
                        saltB64: btoa(String.fromCharCode(...salt))
                    });
                }
            });
            // Copy Hash Button
            document.getElementById('copy-hash-btn').addEventListener('click', () => {
                const hash = document.getElementById('generated-vault-hash').textContent;
                if (hash) {
                    copyToClipboard(hash);
                }
            });
            // Join Vault Form Submission
            document.getElementById('join-vault-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const joinVaultHash = document.getElementById('join-vault-hash').value;
                const joinVaultName = document.getElementById('join-vault-name').value;
                
                // Check if it's a private vault (all private vaults use hash-based joining)
                // Request to join the private vault to get the public key
                sendMessageToServer({
                    type: 'request_join_private_vault',
                    userId: userId,
                    vaultHash: joinVaultHash,
                    vaultName: joinVaultName
                });
                
                joinVaultModal.classList.remove('show');
            });
            // Send Message Button
            document.getElementById('send-message-btn').addEventListener('click', async () => {
                const messageInput = document.getElementById('message-input');
                const fileInput = document.getElementById('file-input');
                const messageText = messageInput.value.trim();
                const file = fileInput.files[0];
                if (!activeVaultId) {
                    showMessageBox('No Vault Selected', 'Please select a vault to send messages.');
                    return;
                }
                if (!messageText && !file) {
                    return; // Don't send empty messages
                }
                const vault = vaults.get(activeVaultId);
                if (!vault) {
                    showMessageBox('Error', 'Active vault not found. Please re-select or refresh.');
                    console.error("Attempted to send message to a non-existent active vault.");
                    return;
                }
                let encryptedContent;
                let ivB64;
                let isFile = false;
                let fileName = null;
                let fileMimeType = null;
                // Create the message object for local display first
                const localMessageObj = {
                    sender: userId, // This message is from the current user
                    timestamp: new Date().toISOString(),
                };
                if (file) {
                    try {
                        const base64File = await fileToBase64(file);
                        const { encryptedMessage, iv } = await encryptMessage(base64File, vault.key);
                        encryptedContent = encryptedMessage;
                        ivB64 = iv;
                        isFile = true;
                        fileName = file.name;
                        fileMimeType = file.type;
                        messageInput.value = ''; // Clear text input if file is sent
                        fileInput.value = ''; // Clear file input
                        localMessageObj.content = base64File; // Store raw content for local display
                        localMessageObj.isFile = true;
                        localMessageObj.fileName = fileName;
                        localMessageObj.fileMimeType = fileMimeType;
                    } catch (error) {
                        console.error("Error encrypting file:", error);
                        showMessageBox('Encryption Error', 'Failed to encrypt file. Please try again.');
                        return;
                    }
                } else {
                    try {
                        const { encryptedMessage, iv } = await encryptMessage(messageText, vault.key);
                        encryptedContent = encryptedMessage;
                        ivB64 = iv;
                        messageInput.value = ''; // Clear text input
                        localMessageObj.content = messageText; // Store raw content for local display
                        localMessageObj.isFile = false;
                    } catch (error) {
                        console.error("Error encrypting message:", error);
                        showMessageBox('Encryption Error', 'Failed to encrypt message. Please try again.');
                        return;
                    }
                }
                // Add message to local vault and display it immediately
                vault.messages.push(localMessageObj);
                displayMessage(localMessageObj); // Display immediately
                await saveVaultsToLocalStorage(); // Ensure local storage is updated
                // Now send the encrypted message to the server
                sendMessageToServer({
                    type: 'send_message',
                    vaultId: activeVaultId,
                    senderId: userId,
                    encryptedMessage: encryptedContent,
                    iv: ivB64,
                    timestamp: localMessageObj.timestamp, // Use the same timestamp
                    isFile: isFile,
                    fileName: fileName,
                    fileMimeType: fileMimeType
                });
            });
            // Attach File Button
            document.getElementById('attach-file-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });
            // Nuke Button
            document.getElementById('nuke-btn').addEventListener('click', nukeAllData); // Call nukeAllData directly as it has its own confirmation
            // Handle Enter key for sending messages
            document.getElementById('message-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('send-message-btn').click();
                }
            });
        });
    </script>
</body>
</html>
