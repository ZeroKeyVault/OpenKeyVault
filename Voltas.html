<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0; /* Light grey background */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }
        .container {
            background-color: #ffffff; /* White background for the main app */
            border-radius: 1rem; /* Rounded corners for the container */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            width: 95%;
            margin: 1.5rem auto;
            overflow: hidden;
        }
        .header {
            background-color: #f9f9f9; /* Slightly off-white for header */
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            display: flex; /* Use flexbox for alignment */
            justify-content: center; /* Center content horizontally */
            align-items: center; /* Center content vertically */
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
        }
        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            background-color: #f5f5f5; /* Light grey for sidebar */
            border-right: 1px solid #e0e0e0;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }
        .vault-list {
            flex-grow: 1;
            overflow-y: auto;
        }
        .vault-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #e0e0e0;
        }
        .vault-item:hover {
            background-color: #f0f0f0;
        }
        .vault-item.active {
            background-color: #e0e0e0;
            font-weight: 600;
        }
        .chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            overflow: hidden; /* Ensure this doesn't create extra scrollbars */
        }
        .messages-display {
            flex-grow: 1;
            background-color: #f9f9f9;
            border-radius: 0.75rem;
            padding: 1rem;
            overflow-y: auto; /* Make messages scrollable */
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
        }
        .message {
            margin-bottom: 0.75rem;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            /* Adjusted max-width for better responsiveness */
            max-width: calc(100% - 4rem); /* Allows some margin/padding */
            word-wrap: break-word; /* Ensures long words break */
        }
        .message.self {
            background-color: #e0e0e0; /* Light grey for self messages */
            margin-left: auto; /* Aligns to the right */
            text-align: right;
        }
        .message.other {
            background-color: #f0f0f0; /* Even lighter grey for other messages */
            margin-right: auto; /* Aligns to the left */
            text-align: left;
        }
        .message-sender {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }
        .message-content {
            font-size: 1rem;
            color: #333;
        }
        .message-timestamp {
            font-size: 0.7rem;
            color: #999;
            margin-top: 0.5rem;
            display: block;
        }
        .input-area {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .input-area input[type="text"] {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
            outline: none;
        }
        .input-area button {
            padding: 0.75rem 1.5rem;
            background-color: #888; /* Grey for buttons */
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .input-area button:hover {
            background-color: #666;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.show {
            visibility: visible;
            opacity: 1;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            position: relative;
        }
        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
            color: #888;
        }
        .modal-content h2 {
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #333;
            text-align: center;
        }
        .modal-content label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #555;
        }
        .modal-content input,
        .modal-content select {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
        }
        .modal-content button {
            width: 100%;
            padding: 0.75rem;
            background-color: #888;
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            font-size: 1.1rem;
            transition: background-color 0.2s ease;
        }
        .modal-content button:hover {
            background-color: #666;
        }
        .footer {
            text-align: center;
            padding: 1rem;
            color: #666;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        .message-file {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #e0e0e0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
        }
        .message-file svg {
            width: 1.25rem;
            height: 1.25rem;
            fill: #555;
        }
        .message-file span {
            color: #333;
            font-weight: 500;
        }
        .nuke-button {
            background-color: #f44336; /* Red for Nuke button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            margin-top: auto; /* Pushes it to the bottom of the sidebar */
        }
        .nuke-button:hover {
            background-color: #d32f2f;
        }
        .info-message {
            background-color: #fff3cd;
            color: #664d03;
            padding: 0.75rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ffecb3;
            text-align: center;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
                padding-bottom: 0;
            }
            .chat-area {
                padding-top: 0;
            }
            .vault-list {
                max-height: 200px; /* Limit height of vault list on small screens */
            }
            .header {
                font-size: 2rem;
                padding: 1rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            /* Adjust message max-width on very small screens if needed */
            .message {
                max-width: calc(100% - 2rem); /* More room for padding/margin on very small screens */
            }
            .message.self, .message.other {
                margin-left: 0; /* Remove auto margins to simplify */
                margin-right: 0;
                width: 100%; /* Take full width */
            }
            .message.self {
                text-align: right; /* Keep text alignment */
                background-color: #e0e0e0;
            }
            .message.other {
                text-align: left; /* Keep text alignment */
                background-color: #f0f0f0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <span>The Platform</span>
            <img src="http://googleusercontent.com/file_content/2" alt="Logo" class="w-12 h-12 ml-4 rounded-full object-cover">
        </div>
        <div class="main-content">
            <div class="sidebar">
                <div class="info-message" id="user-id-display">
                    Your ID: <span id="current-user-id">Generating...</span>
                </div>
                <button id="create-vault-btn" class="input-area button">Create Vault</button>
                <button id="join-vault-btn" class="input-area button">Join Vault</button>

                <div class="vault-list" id="vault-list">
                    </div>

                <button id="nuke-btn" class="nuke-button">Nuke All Data</button>
            </div>

            <div class="chat-area">
                <div id="no-vault-selected" class="info-message text-center p-4 rounded-lg bg-gray-100 text-gray-700">
                    Select a vault to start chatting or create/join a new one.
                </div>
                <div id="chat-window" class="messages-display hidden">
                    </div>
                <div id="chat-input-area" class="input-area hidden">
                    <input type="text" id="message-input" placeholder="Type your message...">
                    <input type="file" id="file-input" class="hidden" accept="*/*">
                    <button id="attach-file-btn" title="Attach File">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                            <path fill-rule="evenodd" d="M18.97 3.659A2.25 2.25 0 0 0 17.023 2.25h-13.5A2.25 2.25 0 0 0 1.25 4.5v11.25c0 1.036.724 1.897 1.702 2.131a.75.75 0 0 0 .584.076l7.497-1.5a.75.75 0 0 0 .427-.715V6.25a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 .75.75v6.19l1.777.355a.75.75 0 0 0 .584-.076c.978-.234 1.702-1.095 1.702-2.131V4.5A2.25 2.25 0 0 0 18.97 3.659ZM12 15.75h.007v.008H12v-.008ZM10.5 6a.75.75 0 0 0-.75.75v4.5a.75.75 0 0 0 .75.75h.75a.75.75 0 0 0 .75-.75v-4.5a.75.75 0 0 0-.75-.75h-.75Z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button id="send-message-btn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div id="create-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="create-vault-close">&times;</span>
            <h2>Create New Vault</h2>
            <form id="create-vault-form">
                <label for="vault-name">Vault Name:</label>
                <input type="text" id="vault-name" placeholder="e.g., Family Chat, Project X" required>

                <label for="vault-type">Vault Type:</label>
                <select id="vault-type" required>
                    <option value="private">Private (Direct Message)</option>
                    <option value="public">Public (Group)</option>
                </select>

                <label for="expiration-time">Expiration Time:</label>
                <select id="expiration-time" required>
                    <option value="1h">1 Hour</option>
                    <option value="5h">5 Hours</option>
                    <option value="24h">24 Hours</option>
                    <option value="1mo">1 Month</option>
                    <option value="3mo">3 Months</option>
                    <option value="6mo">6 Months</option>
                    <option value="1yr">1 Year</option>
                    <option value="never">Never</option>
                </select>

                <button type="submit">Create Vault</button>
                <div id="create-vault-hash-display" class="info-message mt-4 hidden">
                    Vault Hash: <span id="generated-vault-hash" class="font-mono break-all"></span><br>
                    <button id="copy-hash-btn" type="button" class="mt-2 w-auto px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm">Copy Hash</button>
                </div>
            </form>
        </div>
    </div>

    <div id="join-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="join-vault-close">&times;</span>
            <h2>Join Existing Vault</h2>
            <form id="join-vault-form">
                <label for="join-vault-hash">Vault Hash:</label>
                <input type="text" id="join-vault-hash" placeholder="Enter vault hash" required>

                <label for="join-vault-name">Name for this Vault (for your reference):</label>
                <input type="text" id="join-vault-name" placeholder="e.g., John's Chat, Dev Team" required>

                <button type="submit">Join Vault</button>
            </form>
        </div>
    </div>

    <div id="message-box" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="message-box-close">&times;</span>
            <h2 id="message-box-title"></h2>
            <p id="message-box-content" class="text-center mb-4"></p>
            <button id="message-box-ok">OK</button>
        </div>
    </div>

    <footer class="footer">
        <p>Encrypted by The Laughing Buddha Protocol</p>
        <p>a Prakhar Solanki creation</p>
        <p>&copy;2025-The Platform.</p>
    </footer>

    <script>
        // Global variables for WebSocket and user ID
        let ws;
        let userId;
        let activeVaultId = null;
        // Stores vaultId -> { name, type, key, iv, messages: [], participants: [] }
        const vaults = new Map();
        // IMPORTANT: Update this to your Render WebSocket URL
        // Example: 'wss://your-app-name.onrender.com'
        const SERVER_URL = 'wss://server-2-j3cv.onrender.com'; // **UPDATE THIS LINE WITH YOUR RENDER URL**

        // For large file transfers:
        const CHUNK_SIZE = 64 * 1024; // 64 KB chunks
        // Stores fileId -> { fileName, fileMimeType, totalChunks, iv, senderId, timestamp, receivedChunks: Map<chunkIndex, encryptedChunk>, placeholderMessageElement }
        const incomingFileChunks = new Map();

        // For Peer-to-Peer (WebRTC)
        const STUN_SERVERS = [
            'stun:stun.l.google.com:19302',
            'stun:stun1.l.google.com:19302',
            'stun:stun2.l.google.com:19302',
            'stun:stun3.l.google.com:19302',
            'stun:stun4.l.google.com:19302'
            // Add TURN servers here for more robust NAT traversal in production
            // { urls: 'turn:YOUR_TURN_SERVER_IP:PORT', username: 'YOUR_USERNAME', credential: 'YOUR_PASSWORD' }
        ];
        const peerConnections = new Map(); // userId -> RTCPeerConnection
        const dataChannels = new Map();    // userId -> RTCDataChannel
        const pendingIceCandidates = new Map(); // userId -> [] of candidates
        const pendingOffers = new Map(); // userId -> {offer, timestamp} to retry if PC not ready
        const p2pChannelLabels = new Set(); // To track opened data channel labels for clean up

        // --- Utility Functions ---

        /**
         * Displays a custom message box instead of alert().
         * @param {string} title - The title of the message box.
         * @param {string} message - The content message.
         * @param {function} onOk - Callback function when OK is clicked.
         */
        function showMessageBox(title, message, onOk = () => {}) {
            const msgBox = document.getElementById('message-box');
            document.getElementById('message-box-title').textContent = title;
            document.getElementById('message-box-content').innerHTML = message; // Use innerHTML for potential HTML in message
            msgBox.classList.add('show');

            const okBtn = document.getElementById('message-box-ok');
            const closeBtn = document.getElementById('message-box-close');

            const closeMessageBox = () => {
                msgBox.classList.remove('show');
                okBtn.removeEventListener('click', okHandler);
                closeBtn.removeEventListener('click', closeHandler);
                onOk();
            };

            const okHandler = () => closeMessageBox();
            const closeHandler = () => closeMessageBox();

            okBtn.addEventListener('click', okHandler);
            closeBtn.addEventListener('click', closeHandler);
        }

        /**
         * Copies text to the clipboard.
         * @param {string} text - The text to copy.
         */
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showMessageBox('Copied!', 'Vault hash copied to clipboard.');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessageBox('Error', 'Failed to copy hash. Please copy manually: ' + text);
            }
            document.body.removeChild(textarea);
        }

        /**
         * Converts a File object to a Base64 string (Data URL).
         * @param {File} file - The file to convert.
         * @returns {Promise<string>} A promise that resolves with the Base64 string (Data URL).
         */
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result); // e.g., "data:image/png;base64,iVBORw..."
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        /**
         * Converts a Base64 string back to a Blob.
         * @param {string} base64 - The Base64 string.
         * @param {string} mimeType - The MIME type of the original file.
         * @returns {Blob} The Blob object.
         */
        function base64ToBlob(base64, mimeType) {
            // Ensure base64 string does not contain the data URL prefix
            const cleanBase64 = base64.startsWith('data:') ? base64.split(',')[1] : base64;
            const byteString = atob(cleanBase64);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            return new Blob([ab], { type: mimeType });
        }

        /**
         * Downloads a file from Base64 data.
         * @param {string} base64Data - The Base64 encoded file data (full Data URL).
         * @param {string} filename - The name of the file to download.
         * @param {string} mimeType - The MIME type of the file.
         */
        function downloadFile(base64Data, filename, mimeType) {
            const blob = base64ToBlob(base64Data, mimeType); // base64ToBlob now handles prefix
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- Cryptography (The Laughing Buddha Protocol) ---

        /**
         * Generates a random AES-GCM key.
         * @returns {Promise<CryptoKey>} The generated key.
         */
        async function generateAesKey() {
            return crypto.subtle.generateKey(
                { name: "AES-GCM", length: 256 },
                true, // extractable
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Derives a cryptographic key from a given password (hash) using PBKDF2.
         * This is used to encrypt/decrypt the vault's main AES key.
         * @param {string} password - The vault hash (password).
         * @param {Uint8Array} salt - A unique salt for key derivation.
         * @returns {Promise<CryptoKey>} The derived key.
         */
        async function deriveKeyFromHash(password, salt) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                { name: "PBKDF2" },
                false,
                ["deriveBits", "deriveKey"]
            );
            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000, // High iterations for security
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true, // extractable
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Encrypts data using AES-GCM.
         * @param {ArrayBuffer} data - The data to encrypt.
         * @param {CryptoKey} key - The AES-GCM key.
         * @returns {Promise<{encryptedData: ArrayBuffer, iv: Uint8Array}>} Encrypted data and IV.
         */
        async function encryptData(data, key) {
            const iv = crypto.getRandomValues(new Uint8Array(16)); // 96-bit IV recommended for AES-GCM
            const encryptedData = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                data
            );
            return { encryptedData, iv };
        }

        /**
         * Decrypts data using AES-GCM.
         * @param {ArrayBuffer} encryptedData - The encrypted data.
         * @param {Uint8Array} iv - The IV used for encryption.
         * @param {CryptoKey} key - The AES-GCM key.
         * @returns {Promise<ArrayBuffer>} The decrypted data.
         */
        async function decryptData(encryptedData, iv, key) {
            try {
                return await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encryptedData
                );
            } catch (e) {
                console.error("Decryption failed:", e);
                throw new Error("Decryption failed. Key or data might be corrupted.");
            }
        }

        /**
         * Exports a CryptoKey to a raw ArrayBuffer.
         * @param {CryptoKey} key - The key to export.
         * @returns {Promise<ArrayBuffer>} The raw key data.
         */
        async function exportKey(key) {
            return crypto.subtle.exportKey("raw", key);
        }

        /**
         * Imports a raw ArrayBuffer into a CryptoKey.
         * @param {ArrayBuffer} rawKey - The raw key data.
         * @returns {Promise<CryptoKey>} The imported key.
         */
        async function importKey(rawKey) {
            return crypto.subtle.importKey(
                "raw",
                rawKey,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Encrypts a string message.
         * @param {string} message - The message string (can be raw Base64 for files).
         * @param {CryptoKey} key - The AES-GCM key for the vault.
         * @returns {Promise<{encryptedMessage: string, iv: string}>} Base64 encoded encrypted message and IV.
         */
        async function encryptMessage(message, key) {
            const enc = new TextEncoder();
            const encoded = enc.encode(message);
            const { encryptedData, iv } = await encryptData(encoded, key);
            return {
                encryptedMessage: btoa(String.fromCharCode(...new Uint8Array(encryptedData))),
                iv: btoa(String.fromCharCode(...iv))
            };
        }

        /**
         * Decrypts a string message.
         * @param {string} encryptedMessageB64 - Base64 encoded encrypted message.
         * @param {string} ivB64 - Base64 encoded IV.
         * @param {CryptoKey} key - The AES-GCM key for the vault.
         * @returns {Promise<string>} The decrypted message string (can be raw Base64 for files).
         */
        async function decryptMessage(encryptedMessageB64, ivB64, key) {
            try {
                const encryptedData = Uint8Array.from(atob(encryptedMessageB64), c => c.charCodeAt(0));
                const iv = Uint8Array.from(atob(ivB64), c => c.charCodeAt(0));
                const decryptedData = await decryptData(encryptedData, iv, key);
                const dec = new TextDecoder();
                return dec.decode(decryptedData);
            } catch (e) {
                console.error("Error decrypting message:", e);
                return "[Could not decrypt message]";
            }
        }

        // --- WebRTC (Peer-to-Peer) Functions ---

        /**
         * Sends a WebRTC signaling message via the WebSocket server.
         * @param {string} toUserId - The recipient of the signal.
         * @param {object} signalData - The WebRTC offer, answer, or ICE candidate.
         */
        function sendWebRTCSignal(toUserId, signalData) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'webrtc_signal',
                    fromUserId: userId,
                    toUserId: toUserId,
                    signalData: signalData
                }));
            } else {
                console.warn("WebSocket not open, cannot send WebRTC signal. Signal for", toUserId, signalData);
            }
        }

        /**
         * Sets up a new RTCPeerConnection and data channel for a target user.
         * @param {string} targetUserId - The ID of the peer to connect to.
         * @param {string} vaultId - The ID of the vault this P2P connection is for.
         * @param {boolean} isInitiator - True if this client should create the offer.
         */
        async function setupPeerConnection(targetUserId, vaultId, isInitiator) {
            if (peerConnections.has(targetUserId)) {
                const existingPc = peerConnections.get(targetUserId);
                if (existingPc.iceConnectionState === 'connected' || existingPc.iceConnectionState === 'checking') {
                    console.log(`P2P connection already exists and is active for ${targetUserId}.`);
                    return;
                }
                // If existing connection is not active, close and re-initialize
                console.log(`P2P connection for ${targetUserId} in state ${existingPc.iceConnectionState}. Re-initializing.`);
                existingPc.close(); // Clean up existing PC
                dataChannels.delete(targetUserId);
                peerConnections.delete(targetUserId);
            }

            console.log(`Setting up P2P connection for ${targetUserId} in vault ${vaultId}. Initiator: ${isInitiator}`);
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: STUN_SERVERS }]
            });
            peerConnections.set(targetUserId, pc);

            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    // console.log(`Sending ICE candidate to ${targetUserId}`);
                    sendWebRTCSignal(targetUserId, { type: 'candidate', candidate: event.candidate, vaultId: vaultId });
                }
            };

            // Handle ICE connection state changes (for debugging)
            pc.oniceconnectionstatechange = () => {
                console.log(`ICE connection state for ${targetUserId}: ${pc.iceConnectionState}`);
                if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'closed') {
                    console.warn(`P2P connection to ${targetUserId} failed, disconnected, or closed. Removing DataChannel.`);
                    dataChannels.delete(targetUserId); // Remove data channel if connection fails
                    peerConnections.delete(targetUserId); // Also remove PC
                    p2pChannelLabels.delete(`chat-${vaultId}-${targetUserId}`); // Clean up label
                    showMessageBox('P2P Disconnected', `Direct connection to ${targetUserId.substring(0,8)}... for vault "${vaults.get(vaultId)?.name}" lost. Messages will now go via server.`);
                } else if (pc.iceConnectionState === 'connected') {
                    showMessageBox('P2P Connected!', `Direct connection established with ${targetUserId.substring(0,8)}... for vault "${vaults.get(vaultId)?.name}".`);
                }
            };

            // Handle incoming data channels (for the non-initiator)
            pc.ondatachannel = (event) => {
                const dc = event.channel;
                const expectedLabel = `chat-${vaultId}-${targetUserId}`; // Ensure correct label
                if (dc.label === expectedLabel && !dataChannels.has(targetUserId)) {
                    console.log(`Incoming DataChannel from ${targetUserId}: ${dc.label}`);
                    dataChannels.set(targetUserId, dc);
                    p2pChannelLabels.add(dc.label);
                    setupDataChannelListeners(dc, targetUserId, vaultId);
                } else if (dc.label !== expectedLabel) {
                    console.warn("Received data channel with unexpected label:", dc.label, ". Expected:", expectedLabel);
                } else {
                    console.warn(`DataChannel for ${targetUserId} already exists or is being processed.`);
                }
            };

            if (isInitiator) {
                // Create data channel (for the initiator)
                const dataChannelLabel = `chat-${vaultId}-${userId}`; // Unique label for the data channel. Use current user ID for initiator's label.
                if (!p2pChannelLabels.has(dataChannelLabel)) {
                    const dc = pc.createDataChannel(dataChannelLabel);
                    dataChannels.set(targetUserId, dc);
                    p2pChannelLabels.add(dataChannelLabel);
                    setupDataChannelListeners(dc, targetUserId, vaultId);
                    console.log(`Created DataChannel for ${targetUserId}: ${dc.label}`);
                } else {
                    console.warn(`DataChannel with label ${dataChannelLabel} already created. Skipping.`);
                }

                // Create offer
                pc.onnegotiationneeded = async () => {
                    try {
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        console.log(`Sending WebRTC offer to ${targetUserId}`);
                        sendWebRTCSignal(targetUserId, { type: 'offer', sdp: pc.localDescription, vaultId: vaultId });
                    } catch (e) {
                        console.error("Error creating or sending offer:", e);
                    }
                };
            }

            // Add any pending ICE candidates if they arrived before PC was ready
            if (pendingIceCandidates.has(targetUserId)) {
                for (const candidate of pendingIceCandidates.get(targetUserId)) {
                    try {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    } catch (e) {
                        console.warn("Error adding pending ICE candidate:", e);
                    }
                }
                pendingIceCandidates.delete(targetUserId);
            }
        }

        /**
         * Sets up listeners for an RTCDataChannel.
         * @param {RTCDataChannel} dc - The data channel.
         * @param {string} peerId - The ID of the peer.
         * @param {string} vaultId - The vault ID associated with this channel.
         */
        function setupDataChannelListeners(dc, peerId, vaultId) {
            dc.onopen = () => {
                console.log(`DataChannel to ${peerId} in vault ${vaultId} is OPEN.`);
            };

            dc.onmessage = async (event) => {
                let data;
                try {
                    data = JSON.parse(event.data);
                } catch (e) {
                    console.error("Failed to parse incoming P2P message:", e, event.data);
                    return;
                }
                console.log(`Received P2P message from ${peerId}:`, data);

                // Process P2P chat messages (similar to new_message from server)
                if (data.type === 'chat_message' || data.type === 'file_chunk') {
                    const { senderId, encryptedMessage, iv, timestamp, isFile, fileName, fileMimeType, fileId, chunkIndex, totalChunks } = data;
                    const vault = vaults.get(vaultId);

                    if (!vault) {
                        console.warn(`Received P2P message for unknown vault ID: ${vaultId}. Message:`, data);
                        return;
                    }

                    const isIncomingFilePart = (fileId !== undefined && chunkIndex !== undefined && totalChunks !== undefined);

                    if (isIncomingFilePart) {
                        if (!incomingFileChunks.has(fileId)) {
                            incomingFileChunks.set(fileId, {
                                fileName: fileName,
                                fileMimeType: fileMimeType,
                                totalChunks: totalChunks,
                                iv: iv, // IV for the whole file
                                senderId: senderId,
                                timestamp: timestamp,
                                receivedChunks: new Map(),
                                placeholderMessageElement: null
                            });

                            if (activeVaultId === vaultId) {
                                const chatWindow = document.getElementById('chat-window');
                                const placeholderDiv = document.createElement('div');
                                placeholderDiv.className = `message other`;
                                placeholderDiv.innerHTML = `
                                    <div class="message-sender">User: ${senderId.substring(0, 8)}...</div>
                                    <div class="message-content">Receiving file: ${fileName || 'unknown'} (0/${totalChunks} chunks received) via P2P...</div>
                                    <span class="message-timestamp">${new Date(timestamp).toLocaleTimeString()}</span>
                                `;
                                chatWindow.appendChild(placeholderDiv);
                                chatWindow.scrollTop = chatWindow.scrollHeight;
                                incomingFileChunks.get(fileId).placeholderMessageElement = placeholderDiv;
                            }
                        }

                        const fileData = incomingFileChunks.get(fileId);
                        fileData.receivedChunks.set(chunkIndex, encryptedMessage);

                        if (activeVaultId === vaultId && fileData.placeholderMessageElement) {
                            const contentSpan = fileData.placeholderMessageElement.querySelector('.message-content');
                            if (contentSpan) {
                                contentSpan.textContent = `Receiving file: ${fileName || 'unknown'} (${fileData.receivedChunks.size}/${totalChunks} chunks received) via P2P`;
                            }
                            document.getElementById('chat-window').scrollTop = document.getElementById('chat-window').scrollHeight;
                        }

                        if (fileData.receivedChunks.size === totalChunks) {
                            const sortedChunks = Array.from(fileData.receivedChunks.entries())
                                                          .sort(([idxA], [idxB]) => idxA - idxB)
                                                          .map(([, chunk]) => chunk);
                            const combinedEncryptedRawBase64 = sortedChunks.join('');

                            try {
                                const decryptedContent = await decryptMessage(combinedEncryptedRawBase64, fileData.iv, vault.key);

                                const messageObj = {
                                    id: crypto.randomUUID(), // New ID for the reassembled message
                                    senderId: senderId,
                                    content: decryptedContent,
                                    timestamp: fileData.timestamp,
                                    isFile: true,
                                    fileName: fileData.fileName,
                                    fileMimeType: fileData.fileMimeType,
                                    deliveryMethod: 'P2P' // Indicate P2P delivery
                                };

                                vault.messages.push(messageObj);
                                if (activeVaultId === vaultId) {
                                    if (fileData.placeholderMessageElement) {
                                        fileData.placeholderMessageElement.remove(); // Remove placeholder
                                    }
                                    displayMessage(messageObj);
                                }
                                showMessageBox('File Received!', `File "${fileData.fileName}" received via P2P in vault "${vault.name}".`);
                                incomingFileChunks.delete(fileId); // Clean up
                            } catch (e) {
                                console.error("Error decrypting/reassembling P2P file:", e);
                                const errorMsg = {
                                    id: crypto.randomUUID(),
                                    senderId: senderId,
                                    content: `[Error receiving file "${fileName || 'unknown'}" via P2P: ${e.message}]`,
                                    timestamp: timestamp,
                                    isFile: false,
                                    deliveryMethod: 'P2P'
                                };
                                vault.messages.push(errorMsg);
                                if (activeVaultId === vaultId) {
                                    if (fileData.placeholderMessageElement) {
                                        fileData.placeholderMessageElement.remove();
                                    }
                                    displayMessage(errorMsg);
                                }
                                incomingFileChunks.delete(fileId);
                            }
                        }
                    } else { // Regular P2P text message
                        decryptAndDisplayMessage(
                            vaultId,
                            senderId,
                            encryptedMessage,
                            iv,
                            timestamp,
                            false, // isFile
                            null, null, // fileName, fileMimeType
                            'P2P' // deliveryMethod
                        );
                    }
                }
            };

            dc.onclose = () => {
                console.log(`DataChannel to ${peerId} is CLOSED.`);
                dataChannels.delete(peerId);
                p2pChannelLabels.delete(dc.label); // Clean up label
                // No need to show MessageBox here, oniceconnectionstatechange handles connection state changes.
            };

            dc.onerror = (error) => {
                console.error(`DataChannel error with ${peerId}:`, error);
            };
        }

        /**
         * Handles incoming WebRTC signaling messages from the WebSocket server.
         * @param {object} data - The signaling data.
         */
        async function handleWebRTCSignal(data) {
            const { fromUserId, signalData, vaultId } = data;
            console.log(`Received WebRTC signal from ${fromUserId}:`, signalData.type, 'for vault:', vaultId);

            let pc = peerConnections.get(fromUserId);
            // If PC doesn't exist yet, it means this client is the non-initiator
            // or the initiator hasn't yet created the PC.
            // For offers, create PC and set remote description.
            // For candidates, store them until PC is ready.
            if (!pc && signalData.type === 'offer') {
                await setupPeerConnection(fromUserId, vaultId, false); // Create PC as non-initiator
                pc = peerConnections.get(fromUserId); // Get the newly created PC
                if (!pc) {
                    console.error("Failed to create PeerConnection for incoming offer.");
                    return;
                }
            } else if (!pc && signalData.type === 'candidate') {
                // If candidate arrives before offer, store it.
                if (!pendingIceCandidates.has(fromUserId)) {
                    pendingIceCandidates.set(fromUserId, []);
                }
                pendingIceCandidates.get(fromUserId).push(signalData.candidate);
                console.log(`Storing pending ICE candidate from ${fromUserId}.`);
                return; // Don't process further until PC is ready from offer
            } else if (!pc) {
                 console.warn(`Received signal of type ${signalData.type} from ${fromUserId} but no PC exists. Ignoring.`);
                 return;
            }


            try {
                if (signalData.type === 'offer') {
                    await pc.setRemoteDescription(new RTCSessionDescription(signalData.sdp));
                    // Check if there are pending ICE candidates for this peer.
                    // Add them *after* setting the remote description.
                    if (pendingIceCandidates.has(fromUserId)) {
                        for (const candidate of pendingIceCandidates.get(fromUserId)) {
                            try {
                                await pc.addIceCandidate(new RTCIceCandidate(candidate));
                            } catch (e) {
                                console.warn("Error adding pending ICE candidate during offer processing:", e);
                            }
                        }
                        pendingIceCandidates.delete(fromUserId);
                    }
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    console.log(`Sending WebRTC answer to ${fromUserId}`);
                    sendWebRTCSignal(fromUserId, { type: 'answer', sdp: pc.localDescription, vaultId: vaultId });
                } else if (signalData.type === 'answer') {
                    await pc.setRemoteDescription(new RTCSessionDescription(signalData.sdp));
                    console.log(`Set remote description (answer) for ${fromUserId}`);
                } else if (signalData.type === 'candidate') {
                    if (pc.remoteDescription && pc.remoteDescription.type) { // Ensure remote description is set
                        await pc.addIceCandidate(new RTCIceCandidate(signalData.candidate));
                        console.log(`Added ICE candidate from ${fromUserId}`);
                    } else {
                        // If remote description isn't set yet, queue the candidate
                        if (!pendingIceCandidates.has(fromUserId)) {
                            pendingIceCandidates.set(fromUserId, []);
                        }
                        pendingIceCandidates.get(fromUserId).push(signalData.candidate);
                        console.log(`Queued ICE candidate from ${fromUserId} as remote description not yet set.`);
                    }
                }
            } catch (e) {
                console.error("Error handling WebRTC signal:", e);
            }
        }


        // --- WebSocket Communication ---

        /**
         * Initializes the WebSocket connection.
         */
        function initWebSocket() {
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                console.log("WebSocket is already open or connecting.");
                return;
            }

            ws = new WebSocket(SERVER_URL);

            ws.onopen = () => {
                console.log('Connected to WebSocket server');
                // Retrieve or generate userId from localStorage
                userId = localStorage.getItem('userId');
                if (!userId) {
                    userId = crypto.randomUUID();
                    localStorage.setItem('userId', userId);
                    console.log('Generated new userId:', userId);
                }
                document.getElementById('current-user-id').textContent = userId.substring(0, 8) + '...';
                ws.send(JSON.stringify({ type: 'register', userId: userId }));

                // Re-register all known vaults upon reconnection
                vaults.forEach(vault => {
                    const saltB64 = btoa(String.fromCharCode(...vault.salt));
                    ws.send(JSON.stringify({
                        type: 'reconnect_vault',
                        vaultId: vault.id,
                        userId: userId,
                        vaultHash: vault.vaultHash, // Re-send the vault hash
                        encryptedAesKeyB64: vault.encryptedAesKeyB64,
                        saltB64: saltB64,
                        participants: vault.participants // Send participants array for P2P awareness
                    }));
                });
            };

            ws.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                // console.log('Received message:', message);

                switch (message.type) {
                    case 'error':
                        showMessageBox('Error', message.message);
                        break;
                    case 'vault_created':
                        // Store the vault hash for the user to copy
                        const createVaultHashDisplay = document.getElementById('create-vault-hash-display');
                        const generatedVaultHashSpan = document.getElementById('generated-vault-hash');
                        generatedVaultHashSpan.textContent = message.vaultHash;
                        createVaultHashDisplay.classList.remove('hidden');

                        // Import the AES key and store vault data
                        const saltBytes = Uint8Array.from(atob(message.saltB64), c => c.charCodeAt(0));
                        const derivedKey = await deriveKeyFromHash(message.vaultHash, saltBytes);
                        const decryptedAesKeyBytes = await decryptData(
                            Uint8Array.from(atob(message.encryptedAesKeyB64), c => c.charCodeAt(0)),
                            Uint8Array.from(atob(message.ivB64), c => c.charCodeAt(0)),
                            derivedKey
                        );
                        const aesKey = await importKey(decryptedAesKeyBytes);

                        const newVault = {
                            id: message.vaultId,
                            name: message.vaultName,
                            type: message.vaultType,
                            key: aesKey,
                            iv: Uint8Array.from(atob(message.ivB64), c => c.charCodeAt(0)), // Store IV too
                            vaultHash: message.vaultHash,
                            encryptedAesKeyB64: message.encryptedAesKeyB64, // Stored for reconnection
                            salt: saltBytes,
                            expiration: message.expiration,
                            messages: [],
                            participants: message.participants || [] // Store participants
                        };
                        vaults.set(message.vaultId, newVault);
                        addVaultToSidebar(newVault);
                        await saveVaultsToLocalStorage();
                        showMessageBox('Vault Created!', `Vault "${message.vaultName}" created. Share this hash with others: <span class="font-mono break-all text-sm">${message.vaultHash}</span>`, () => {
                             selectVault(message.vaultId);
                             document.getElementById('create-vault-modal').classList.remove('show');
                        });
                        break;
                    case 'vault_joined':
                        // If vault already exists locally, update it. Otherwise, add it.
                        let vault = vaults.get(message.vaultId);
                        if (!vault) {
                            const saltBytes = Uint8Array.from(atob(message.saltB64), c => c.charCodeAt(0));
                            const derivedKey = await deriveKeyFromHash(message.vaultHash, saltBytes);
                            const decryptedAesKeyBytes = await decryptData(
                                Uint8Array.from(atob(message.encryptedAesKeyB64), c => c.charCodeAt(0)),
                                Uint8Array.from(atob(message.ivB64), c => c.charCodeAt(0)),
                                derivedKey
                            );
                            const aesKey = await importKey(decryptedAesKeyBytes);

                            vault = {
                                id: message.vaultId,
                                name: message.vaultName,
                                type: message.vaultType,
                                key: aesKey,
                                iv: Uint8Array.from(atob(message.ivB64), c => c.charCodeAt(0)),
                                vaultHash: message.vaultHash,
                                encryptedAesKeyB64: message.encryptedAesKeyB64,
                                salt: saltBytes,
                                expiration: message.expiration,
                                messages: [],
                                participants: message.participants || [] // Store participants
                            };
                            vaults.set(message.vaultId, vault);
                            addVaultToSidebar(vault);
                            showMessageBox('Vault Joined!', `You have joined "${vault.name}".`);
                        } else {
                            // Update existing vault's properties, especially participants
                            vault.participants = message.participants || [];
                            console.log(`Updated participants for vault ${vault.name}:`, vault.participants);
                            // showMessageBox('Vault Joined/Updated!', `Vault "${vault.name}" updated (e.g., new participant joined).`);
                        }
                        await saveVaultsToLocalStorage();
                        selectVault(message.vaultId); // Auto-select the joined/updated vault
                        document.getElementById('join-vault-modal').classList.remove('show');
                        break;
                    case 'new_message':
                        // Handle messages relayed by the server (can be new or offline messages)
                        const targetVault = vaults.get(message.vaultId);
                        if (targetVault) {
                            // If it's a file chunk, process it as such
                            const isIncomingFilePart = (message.fileId !== undefined && message.chunkIndex !== undefined && message.totalChunks !== undefined);
                            if (isIncomingFilePart) {
                                if (!incomingFileChunks.has(message.fileId)) {
                                    incomingFileChunks.set(message.fileId, {
                                        fileName: message.fileName,
                                        fileMimeType: message.fileMimeType,
                                        totalChunks: message.totalChunks,
                                        iv: message.iv, // IV for the whole file
                                        senderId: message.senderId,
                                        timestamp: message.timestamp,
                                        receivedChunks: new Map(),
                                        placeholderMessageElement: null
                                    });

                                    // Display placeholder message for incoming file only if active vault
                                    if (activeVaultId === message.vaultId) {
                                        const chatWindow = document.getElementById('chat-window');
                                        const placeholderDiv = document.createElement('div');
                                        placeholderDiv.className = `message other`;
                                        placeholderDiv.innerHTML = `
                                            <div class="message-sender">User: ${message.senderId.substring(0, 8)}...</div>
                                            <div class="message-content">Receiving file: ${message.fileName || 'unknown'} (0/${message.totalChunks} chunks received) via Server...</div>
                                            <span class="message-timestamp">${new Date(message.timestamp).toLocaleTimeString()}</span>
                                        `;
                                        chatWindow.appendChild(placeholderDiv);
                                        chatWindow.scrollTop = chatWindow.scrollHeight;
                                        incomingFileChunks.get(message.fileId).placeholderMessageElement = placeholderDiv;
                                    }
                                }

                                const fileData = incomingFileChunks.get(message.fileId);
                                fileData.receivedChunks.set(message.chunkIndex, message.encryptedMessage);

                                if (activeVaultId === message.vaultId && fileData.placeholderMessageElement) {
                                    const contentSpan = fileData.placeholderMessageElement.querySelector('.message-content');
                                    if (contentSpan) {
                                        contentSpan.textContent = `Receiving file: ${message.fileName || 'unknown'} (${fileData.receivedChunks.size}/${message.totalChunks} chunks received) via Server`;
                                    }
                                    document.getElementById('chat-window').scrollTop = document.getElementById('chat-window').scrollHeight;
                                }


                                if (fileData.receivedChunks.size === fileData.totalChunks) {
                                    const sortedChunks = Array.from(fileData.receivedChunks.entries())
                                                              .sort(([idxA], [idxB]) => idxA - idxB)
                                                              .map(([, chunk]) => chunk);
                                    const combinedEncryptedRawBase64 = sortedChunks.join('');

                                    try {
                                        const decryptedContent = await decryptMessage(combinedEncryptedRawBase64, fileData.iv, targetVault.key);

                                        const messageObj = {
                                            id: message.id, // Keep server ID if available
                                            senderId: message.senderId,
                                            content: decryptedContent,
                                            timestamp: fileData.timestamp, // Use file's original timestamp
                                            isFile: true,
                                            fileName: fileData.fileName,
                                            fileMimeType: fileData.fileMimeType,
                                            deliveryMethod: 'Server' // Indicate server delivery
                                        };

                                        targetVault.messages.push(messageObj);
                                        if (activeVaultId === message.vaultId) {
                                            if (fileData.placeholderMessageElement) {
                                                fileData.placeholderMessageElement.remove(); // Remove placeholder
                                            }
                                            displayMessage(messageObj);
                                        }
                                        showMessageBox('File Received!', `File "${fileData.fileName}" received via server in vault "${targetVault.name}".`);
                                        incomingFileChunks.delete(message.fileId); // Clean up
                                    }
                                    catch (e) {
                                        console.error("Error decrypting/reassembling server-relayed file:", e);
                                        const errorMsg = {
                                            id: message.id,
                                            senderId: message.senderId,
                                            content: `[Error receiving file "${fileName || 'unknown'}" via Server: ${e.message}]`,
                                            timestamp: message.timestamp,
                                            isFile: false,
                                            deliveryMethod: 'Server'
                                        };
                                        targetVault.messages.push(errorMsg);
                                        if (activeVaultId === message.vaultId) {
                                            if (fileData.placeholderMessageElement) {
                                                fileData.placeholderMessageElement.remove();
                                            }
                                            displayMessage(errorMsg);
                                        }
                                        incomingFileChunks.delete(message.fileId);
                                    }
                                }

                            } else { // Regular text message via server
                                decryptAndDisplayMessage(
                                    message.vaultId,
                                    message.senderId,
                                    message.encryptedMessage,
                                    message.iv,
                                    message.timestamp,
                                    message.isFile,
                                    message.fileName,
                                    message.fileMimeType,
                                    'Server' // Delivery method
                                );
                            }
                            await saveVaultsToLocalStorage();
                        } else {
                            console.warn(`Received message for unknown vault ID: ${message.vaultId}`);
                        }
                        break;
                    case 'webrtc_signal':
                        handleWebRTCSignal(message);
                        break;
                    case 'offline_messages':
                         // Handle offline messages when reconnecting/registering
                        console.log("Received offline messages:", message.messages.length);
                        for (const msg of message.messages) {
                            const targetVault = vaults.get(msg.vaultId);
                            if (targetVault) {
                                // Re-process as new_message, ensuring file reassembly works
                                if (msg.isFile && msg.fileId && msg.totalChunks) {
                                    // Treat as a server-relayed chunk
                                     if (!incomingFileChunks.has(msg.fileId)) {
                                        incomingFileChunks.set(msg.fileId, {
                                            fileName: msg.fileName,
                                            fileMimeType: msg.fileMimeType,
                                            totalChunks: msg.totalChunks,
                                            iv: msg.iv,
                                            senderId: msg.senderId,
                                            timestamp: msg.timestamp,
                                            receivedChunks: new Map(),
                                            placeholderMessageElement: null
                                        });
                                    }
                                    const fileData = incomingFileChunks.get(msg.fileId);
                                    fileData.receivedChunks.set(msg.chunkIndex, msg.encryptedMessage);

                                    if (fileData.receivedChunks.size === fileData.totalChunks) {
                                        const sortedChunks = Array.from(fileData.receivedChunks.entries())
                                                              .sort(([idxA], [idxB]) => idxA - idxB)
                                                              .map(([, chunk]) => chunk);
                                        const combinedEncryptedRawBase64 = sortedChunks.join('');

                                        try {
                                            const decryptedContent = await decryptMessage(combinedEncryptedRawBase64, fileData.iv, targetVault.key);
                                            const messageObj = {
                                                id: msg.id || crypto.randomUUID(),
                                                senderId: msg.senderId,
                                                content: decryptedContent,
                                                timestamp: fileData.timestamp,
                                                isFile: true,
                                                fileName: fileData.fileName,
                                                fileMimeType: fileData.fileMimeType,
                                                deliveryMethod: 'Server (Offline)'
                                            };
                                            targetVault.messages.push(messageObj);
                                            if (activeVaultId === msg.vaultId) {
                                                displayMessage(messageObj);
                                            }
                                            incomingFileChunks.delete(msg.fileId);
                                        } catch (e) {
                                            console.error("Error decrypting/reassembling offline file:", e);
                                            // Fallback to displaying error message
                                            targetVault.messages.push({
                                                id: msg.id || crypto.randomUUID(),
                                                senderId: msg.senderId,
                                                content: `[Error receiving offline file "${msg.fileName || 'unknown'}": ${e.message}]`,
                                                timestamp: msg.timestamp,
                                                isFile: false,
                                                deliveryMethod: 'Server (Offline)'
                                            });
                                            if (activeVaultId === msg.vaultId) {
                                                displayMessage(targetVault.messages[targetVault.messages.length - 1]);
                                            }
                                            incomingFileChunks.delete(msg.fileId);
                                        }
                                    }
                                } else { // Regular text message
                                    decryptAndDisplayMessage(
                                        msg.vaultId,
                                        msg.senderId,
                                        msg.encryptedMessage,
                                        msg.iv,
                                        msg.timestamp,
                                        msg.isFile,
                                        msg.fileName,
                                        msg.fileMimeType,
                                        'Server (Offline)'
                                    );
                                }
                            }
                        }
                        await saveVaultsToLocalStorage();
                        break;
                    default:
                        console.warn('Unknown message type:', message.type);
                }
            };

            ws.onclose = (event) => {
                console.log('WebSocket disconnected:', event);
                // Attempt to reconnect after a delay
                setTimeout(initWebSocket, 5000); // Try to reconnect every 5 seconds
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                ws.close(); // Close the connection to trigger onclose and retry
            };
        }

        /**
         * Sends a message (or file chunk) to the server.
         * @param {object} messageData - The message data object.
         */
        function sendMessageToServer(messageData) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(messageData));
            } else {
                showMessageBox('Connection Error', 'Not connected to the server. Message cannot be sent.');
            }
        }


        /**
         * Decrypts and displays a message.
         * @param {string} vaultId - The vault ID.
         * @param {string} senderId - The ID of the sender.
         * @param {string} encryptedMessage - The Base64 encrypted message content.
         * @param {string} ivB64 - The Base64 encoded IV.
         * @param {number} timestamp - The message timestamp.
         * @param {boolean} isFile - Whether the message is a file.
         * @param {string} fileName - File name if it's a file.
         * @param {string} fileMimeType - File MIME type if it's a file.
         * @param {string} deliveryMethod - 'Server' or 'P2P'
         */
        async function decryptAndDisplayMessage(vaultId, senderId, encryptedMessage, ivB64, timestamp, isFile, fileName, fileMimeType, deliveryMethod) {
            const vault = vaults.get(vaultId);
            if (!vault) {
                console.error("Vault not found for decryption:", vaultId);
                return;
            }

            let decryptedContent;
            try {
                decryptedContent = await decryptMessage(encryptedMessage, ivB64, vault.key);
            } catch (e) {
                console.error("Decryption failed for message:", e);
                decryptedContent = "[Decryption Failed - Message Corrupted]";
            }

            const messageObj = {
                id: crypto.randomUUID(), // Generate a local ID
                senderId: senderId,
                content: decryptedContent,
                timestamp: timestamp,
                isFile: isFile,
                fileName: fileName,
                fileMimeType: fileMimeType,
                deliveryMethod: deliveryMethod // Store delivery method
            };

            vault.messages.push(messageObj);
            if (activeVaultId === vaultId) {
                displayMessage(messageObj);
            }
            // No need to call saveVaultsToLocalStorage here, it's handled after message processing.
        }

        // --- UI and Local Storage Management ---

        /**
         * Saves all vaults to local storage.
         */
        async function saveVaultsToLocalStorage() {
            const serializableVaults = [];
            for (const [id, vault] of vaults.entries()) {
                // To save CryptoKey, we need to export it to a raw format
                const rawKey = await exportKey(vault.key);
                serializableVaults.push({
                    id: vault.id,
                    name: vault.name,
                    type: vault.type,
                    // Store encryptedAesKeyB64 and salt, not the raw key, so it can be re-derived
                    encryptedAesKeyB64: vault.encryptedAesKeyB64,
                    saltB64: btoa(String.fromCharCode(...vault.salt)),
                    ivB64: btoa(String.fromCharCode(...vault.iv)),
                    vaultHash: vault.vaultHash,
                    expiration: vault.expiration,
                    messages: vault.messages,
                    participants: vault.participants // Save participants
                });
            }
            localStorage.setItem('vaults', JSON.stringify(serializableVaults));
            localStorage.setItem('activeVaultId', activeVaultId);
        }

        /**
         * Loads vaults from local storage.
         */
        async function loadVaultsFromLocalStorage() {
            const storedVaults = JSON.parse(localStorage.getItem('vaults') || '[]');
            for (const sVault of storedVaults) {
                try {
                    // Re-derive the AES key from hash using stored salt
                    const saltBytes = Uint8Array.from(atob(sVault.saltB64), c => c.charCodeAt(0));
                    const derivedKey = await deriveKeyFromHash(sVault.vaultHash, saltBytes);
                    const decryptedAesKeyBytes = await decryptData(
                        Uint8Array.from(atob(sVault.encryptedAesKeyB64), c => c.charCodeAt(0)),
                        Uint8Array.from(atob(sVault.ivB64), c => c.charCodeAt(0)),
                        derivedKey
                    );
                    const aesKey = await importKey(decryptedAesKeyBytes);

                    vaults.set(sVault.id, {
                        id: sVault.id,
                        name: sVault.name,
                        type: sVault.type,
                        key: aesKey,
                        iv: Uint8Array.from(atob(sVault.ivB64), c => c.charCodeAt(0)),
                        vaultHash: sVault.vaultHash,
                        encryptedAesKeyB64: sVault.encryptedAesKeyB64,
                        salt: saltBytes,
                        expiration: sVault.expiration,
                        messages: sVault.messages || [],
                        participants: sVault.participants || [] // Load participants
                    });
                    addVaultToSidebar(vaults.get(sVault.id));
                } catch (e) {
                    console.error(`Failed to load vault ${sVault.id}:`, e);
                    // Optionally remove corrupted vault from local storage
                }
            }
            const storedActiveVaultId = localStorage.getItem('activeVaultId');
            if (storedActiveVaultId && vaults.has(storedActiveVaultId)) {
                selectVault(storedActiveVaultId);
            }
        }

        /**
         * Adds a vault to the sidebar list.
         * @param {object} vault - The vault object.
         */
        function addVaultToSidebar(vault) {
            const vaultList = document.getElementById('vault-list');
            let vaultItem = document.getElementById(`vault-${vault.id}`);
            if (!vaultItem) { // Only create if it doesn't exist
                vaultItem = document.createElement('div');
                vaultItem.id = `vault-${vault.id}`;
                vaultItem.className = 'vault-item';
                vaultItem.onclick = () => selectVault(vault.id);
                vaultList.appendChild(vaultItem);
            }
            // Update content in case vault properties changed (e.g., name, participants)
            const participantCount = vault.participants ? ` (${vault.participants.length})` : '';
            vaultItem.innerHTML = `
                <span>${vault.name} (${vault.type})</span>
                <span class="text-xs text-gray-500">${new Date(vault.expiration).toLocaleDateString() === 'Invalid Date' ? 'Never' : new Date(vault.expiration).toLocaleDateString()}</span>
            `;
            // Add tooltip for participants if it's a private vault
            if (vault.type === 'private' && vault.participants && vault.participants.length > 0) {
                 const otherParticipant = vault.participants.find(p => p !== userId);
                 if (otherParticipant) {
                     vaultItem.title = `Direct message with: ${otherParticipant.substring(0,8)}...`;
                 }
            }
        }

        /**
         * Selects a vault and displays its messages.
         * @param {string} vaultId - The ID of the vault to select.
         */
        function selectVault(vaultId) {
            if (activeVaultId) {
                const prevActiveItem = document.getElementById(`vault-${activeVaultId}`);
                if (prevActiveItem) {
                    prevActiveItem.classList.remove('active');
                }
            }

            activeVaultId = vaultId;
            localStorage.setItem('activeVaultId', activeVaultId);

            const selectedVault = vaults.get(vaultId);
            if (selectedVault) {
                document.getElementById('no-vault-selected').classList.add('hidden');
                document.getElementById('chat-window').classList.remove('hidden');
                document.getElementById('chat-input-area').classList.remove('hidden');

                const vaultItem = document.getElementById(`vault-${vaultId}`);
                if (vaultItem) {
                    vaultItem.classList.add('active');
                }

                document.getElementById('chat-window').innerHTML = ''; // Clear previous messages
                selectedVault.messages.forEach(msg => displayMessage(msg));
                document.getElementById('chat-window').scrollTop = document.getElementById('chat-window').scrollHeight;

                // For private vaults, try to establish P2P connection with the other participant
                if (selectedVault.type === 'private' && selectedVault.participants.length === 2) {
                    const otherParticipantId = selectedVault.participants.find(p => p !== userId);
                    if (otherParticipantId) {
                        console.log(`Attempting P2P connection with ${otherParticipantId} for vault ${vaultId}`);
                        setupPeerConnection(otherParticipantId, vaultId, true); // This client is the initiator
                    }
                }

            } else {
                console.error('Vault not found:', vaultId);
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
            }
        }

        /**
         * Displays a single message in the chat window.
         * @param {object} message - The message object.
         */
        function displayMessage(message) {
            const chatWindow = document.getElementById('chat-window');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.senderId === userId ? 'self' : 'other'}`;
            // Add a data attribute to uniquely identify messages for updates (e.g., file transfer progress)
            messageDiv.setAttribute('data-message-id', message.id);

            const sender = message.senderId === userId ? 'You' : `User: ${message.senderId.substring(0, 8)}...`;
            const timestamp = new Date(message.timestamp).toLocaleTimeString(); // Only time for conciseness

            let contentHtml = '';
            if (message.isFile) {
                // Ensure the content for files is a full Data URL before creating the download link
                const fullDataUrl = message.content.startsWith('data:') ? message.content : `data:${message.fileMimeType};base64,${message.content}`;
                contentHtml = `
                    <div class="message-file" data-base64="${fullDataUrl}" data-filename="${message.fileName}" data-mimetype="${message.fileMimeType}">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                            <path fill-rule="evenodd" d="M19.5 7.5a3 3 0 0 0-3-3h-8.25a3 3 0 0 0-3 3v9a3 3 0 0 0 3 3h8.25a3 3 0 0 0 3-3v-9Z" clip-rule="evenodd" />
                        </svg>
                        <span>${message.fileName} (${(fullDataUrl.length * 0.75 / 1024 / 1024).toFixed(2)} MB)</span>
                    </div>
                `;
            } else {
                contentHtml = `<div class="message-content">${message.content}</div>`;
            }

            messageDiv.innerHTML = `
                <div class="message-sender">${sender} <span class="text-xs text-gray-400">(${message.deliveryMethod})</span></div>
                ${contentHtml}
                <span class="message-timestamp">${timestamp}</span>
            `;
            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight;

            // Add event listener for file download
            if (message.isFile) {
                const fileLink = messageDiv.querySelector('.message-file');
                if (fileLink) {
                    fileLink.addEventListener('click', (e) => {
                        const base64Data = e.currentTarget.dataset.base64;
                        const filename = e.currentTarget.dataset.filename;
                        const mimeType = e.currentTarget.dataset.mimetype;
                        downloadFile(base64Data, filename, mimeType);
                    });
                }
            }
        }


        // --- Event Listeners and Initial Setup ---

        document.addEventListener('DOMContentLoaded', async () => {
            initWebSocket();
            await loadVaultsFromLocalStorage();

            // Modals Logic
            const createVaultModal = document.getElementById('create-vault-modal');
            const joinVaultModal = document.getElementById('join-vault-modal');

            document.getElementById('create-vault-btn').addEventListener('click', () => {
                createVaultModal.classList.add('show');
                document.getElementById('create-vault-hash-display').classList.add('hidden'); // Hide hash display on opening
            });
            document.getElementById('create-vault-close').addEventListener('click', () => {
                createVaultModal.classList.remove('show');
            });

            document.getElementById('join-vault-btn').addEventListener('click', () => {
                joinVaultModal.classList.add('show');
            });
            document.getElementById('join-vault-close').addEventListener('click', () => {
                joinVaultModal.classList.remove('show');
            });

            // Handle create vault form submission
            document.getElementById('create-vault-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const vaultName = document.getElementById('vault-name').value;
                const vaultType = document.getElementById('vault-type').value;
                const expirationTime = document.getElementById('expiration-time').value;

                const aesKey = await generateAesKey();
                const rawKey = await exportKey(aesKey);
                const iv = crypto.getRandomValues(new Uint8Array(16)); // IV for vault key encryption
                const salt = crypto.getRandomValues(new Uint8Array(16)); // Salt for PBKDF2

                // Generate a random, cryptographically strong hash as the vault password
                const vaultHashArray = crypto.getRandomValues(new Uint8Array(32)); // 256-bit hash
                const vaultHash = Array.from(vaultHashArray).map(b => b.toString(16).padStart(2, '0')).join(''); // Convert to hex string

                const derivedKey = await deriveKeyFromHash(vaultHash, salt);
                const { encryptedData: encryptedAesKey, iv: ivForAesKey } = await encryptData(rawKey, derivedKey);

                sendMessageToServer({
                    type: 'create_vault',
                    vaultName: vaultName,
                    vaultType: vaultType,
                    expiration: expirationTime,
                    encryptedAesKeyB64: btoa(String.fromCharCode(...new Uint8Array(encryptedAesKey))),
                    saltB64: btoa(String.fromCharCode(...salt)),
                    ivB64: btoa(String.fromCharCode(...ivForAesKey)), // IV for AES key encryption
                    vaultHash: vaultHash,
                    userId: userId
                });
            });

            document.getElementById('copy-hash-btn').addEventListener('click', () => {
                const hash = document.getElementById('generated-vault-hash').textContent;
                copyToClipboard(hash);
            });


            // Handle join vault form submission
            document.getElementById('join-vault-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const joinVaultHash = document.getElementById('join-vault-hash').value;
                const joinVaultName = document.getElementById('join-vault-name').value;

                sendMessageToServer({
                    type: 'join_vault',
                    vaultHash: joinVaultHash,
                    vaultName: joinVaultName, // Client-side name for reference
                    userId: userId
                });
            });

            // Handle message sending
            document.getElementById('send-message-btn').addEventListener('click', async () => {
                const messageInput = document.getElementById('message-input');
                const fileInput = document.getElementById('file-input');
                const messageText = messageInput.value.trim();
                const file = fileInput.files[0];

                if (!activeVaultId) {
                    showMessageBox('Error', 'Please select a vault first.');
                    return;
                }

                if (!messageText && !file) {
                    showMessageBox('Empty Message', 'Please type a message or select a file.');
                    return;
                }

                const vault = vaults.get(activeVaultId);
                if (!vault) {
                    showMessageBox('Error', 'Active vault not found. Please re-select or refresh.');
                    return;
                }

                const timestamp = Date.now();
                const messageId = crypto.randomUUID(); // Unique ID for this message/file transfer

                // --- Handle file sending ---
                if (file) {
                    const base64File = await fileToBase64(file);
                    // Get only the base64 data part, remove "data:mime/type;base64," prefix
                    const rawBase64Data = base64File.split(',')[1];
                    const fileMimeType = file.type || 'application/octet-stream';

                    const totalChunks = Math.ceil(rawBase64Data.length / CHUNK_SIZE);
                    const iv = crypto.getRandomValues(new Uint8Array(16)); // IV for the whole file
                    const ivB64 = btoa(String.fromCharCode(...iv));

                    // Display pending message locally
                    const localMessageObj = {
                        id: messageId,
                        senderId: userId,
                        content: `Sending file: ${file.name} (0/${totalChunks} chunks sent)...`,
                        timestamp: timestamp,
                        isFile: true,
                        fileName: file.name,
                        fileMimeType: fileMimeType,
                        deliveryMethod: 'Pending' // Initial status
                    };
                    vault.messages.push(localMessageObj);
                    displayMessage(localMessageObj);
                    await saveVaultsToLocalStorage();

                    let sentViaP2P = false;
                    let recipientId = null;

                    if (vault.type === 'private' && vault.participants && vault.participants.length === 2) {
                        recipientId = vault.participants.find(p => p !== userId);
                        const dc = dataChannels.get(recipientId);
                        if (dc && dc.readyState === 'open') {
                             sentViaP2P = true;
                        }
                    }

                    // Loop through chunks and send
                    for (let i = 0; i < totalChunks; i++) {
                        const start = i * CHUNK_SIZE;
                        const end = start + CHUNK_SIZE;
                        const chunk = rawBase64Data.substring(start, end);

                        const { encryptedMessage: encryptedChunk, iv: chunkIvB64 } = await encryptMessage(chunk, vault.key);

                        const messageData = {
                            type: isFile ? 'file_chunk' : 'chat_message', // Use file_chunk type for P2P/server
                            vaultId: activeVaultId,
                            senderId: userId,
                            encryptedMessage: encryptedChunk,
                            iv: chunkIvB64, // Each chunk gets its own IV for encryption
                            timestamp: timestamp, // Use the same timestamp for all chunks of a file
                            isFile: true,
                            fileName: file.name,
                            fileMimeType: fileMimeType,
                            fileId: messageId, // Unique ID for this file transfer
                            chunkIndex: i,
                            totalChunks: totalChunks
                        };

                        if (sentViaP2P && recipientId) {
                            try {
                                const dc = dataChannels.get(recipientId);
                                if (dc && dc.readyState === 'open') {
                                    dc.send(JSON.stringify(messageData));
                                    // console.log(`Sent file chunk ${i} via P2P to ${recipientId}`);
                                } else {
                                    sentViaP2P = false; // Data channel closed mid-transfer, fallback to server
                                    console.warn(`P2P data channel closed for ${recipientId}. Falling back to server for chunk ${i}.`);
                                    sendMessageToServer(messageData);
                                }
                            } catch (e) {
                                console.warn(`P2P send failed for chunk ${i}:`, e, "Falling back to server.");
                                sentViaP2P = false;
                                sendMessageToServer(messageData);
                            }
                        } else {
                            sendMessageToServer(messageData);
                            // console.log(`Sent file chunk ${i} via Server.`);
                        }

                        // Update local display for progress
                        localMessageObj.content = `Sending file: ${file.name} (${i + 1}/${totalChunks} chunks sent)...`;
                        localMessageObj.deliveryMethod = sentViaP2P ? 'P2P' : 'Server'; // Update delivery method based on last chunk
                        const messageDivToUpdate = document.getElementById('chat-window').querySelector(`[data-message-id="${messageId}"]`);
                        if (messageDivToUpdate) {
                            messageDivToUpdate.querySelector('.message-content').textContent = localMessageObj.content;
                             messageDivToUpdate.querySelector('.message-sender span.text-xs').textContent = `(${localMessageObj.deliveryMethod})`;
                        }
                        document.getElementById('chat-window').scrollTop = document.getElementById('chat-window').scrollHeight;
                    }
                    showMessageBox('File Sent!', `File "${file.name}" sent.`);
                    // Reset file input
                    fileInput.value = '';
                }

                // --- Handle text message sending ---
                if (messageText) {
                    const { encryptedMessage: encryptedContent, iv: ivB64 } = await encryptMessage(messageText, vault.key);

                    const localMessageObj = {
                        id: messageId,
                        senderId: userId,
                        content: messageText, // Store unencrypted content locally for immediate display
                        timestamp: timestamp,
                        isFile: false,
                        deliveryMethod: 'Pending' // Initial status
                    };

                    let sentViaP2P = false;
                    if (vault.type === 'private' && vault.participants && vault.participants.length === 2) {
                        const otherParticipantId = vault.participants.find(p => p !== userId);
                        const dc = dataChannels.get(otherParticipantId);
                        if (dc && dc.readyState === 'open') {
                            try {
                                const messageData = {
                                    type: 'chat_message', // Use a distinct type for P2P messages
                                    vaultId: activeVaultId,
                                    senderId: userId,
                                    encryptedMessage: encryptedContent,
                                    iv: ivB64,
                                    timestamp: timestamp,
                                    isFile: false
                                };
                                dc.send(JSON.stringify(messageData));
                                sentViaP2P = true;
                                console.log(`Sent text message via P2P to ${otherParticipantId}`);
                                localMessageObj.deliveryMethod = 'P2P'; // Update status for local display
                            } catch (e) {
                                console.warn("P2P send failed for text message:", e, "Falling back to server.");
                            }
                        }
                    }

                    if (!sentViaP2P) {
                        sendMessageToServer({
                            type: 'send_message', // Server expects 'send_message' for text
                            vaultId: activeVaultId,
                            senderId: userId,
                            encryptedMessage: encryptedContent,
                            iv: ivB64,
                            timestamp: timestamp, // Use the same timestamp
                            isFile: false
                        });
                        console.log("Sent text message via Server.");
                        localMessageObj.deliveryMethod = 'Server'; // Update status for local display
                    }

                    vault.messages.push(localMessageObj);
                    displayMessage(localMessageObj); // Display immediately
                    await saveVaultsToLocalStorage(); // Ensure local storage is updated

                    messageInput.value = ''; // Clear input field
                }
            });

            // Attach File Button
            document.getElementById('attach-file-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            // Nuke Button
            document.getElementById('nuke-btn').addEventListener('click', nukeAllData); // Call nukeAllData directly as it has its own confirmation

            // Handle Enter key for sending messages
            document.getElementById('message-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('send-message-btn').click();
                }
            });

            // Handle window beforeunload to ensure data is saved
            window.addEventListener('beforeunload', async () => {
                await saveVaultsToLocalStorage();
                // Close all WebRTC peer connections and data channels cleanly
                peerConnections.forEach(pc => pc.close());
                dataChannels.forEach(dc => dc.close());
            });

            // Nuke All Data function
            async function nukeAllData() {
                showMessageBox(
                    'Confirm Nuke',
                    'Are you sure you want to delete ALL your local vaults and messages, and clear your user ID? This cannot be undone.',
                    () => {
                        // User clicked OK in the first confirmation
                        const confirmation = prompt('Type "NUKE" to confirm irreversible data deletion:');
                        if (confirmation === 'NUKE') {
                            localStorage.clear(); // Clears all local storage
                            vaults.clear(); // Clears in-memory vaults
                            activeVaultId = null;
                            userId = null; // Clear userId

                            // Close all WebRTC connections
                            peerConnections.forEach(pc => pc.close());
                            dataChannels.forEach(dc => dc.close());
                            peerConnections.clear();
                            dataChannels.clear();
                            pendingIceCandidates.clear();
                            pendingOffers.clear();
                            p2pChannelLabels.clear();


                            // Clear UI
                            document.getElementById('vault-list').innerHTML = '';
                            document.getElementById('chat-window').innerHTML = '';
                            document.getElementById('no-vault-selected').classList.remove('hidden');
                            document.getElementById('chat-window').classList.add('hidden');
                            document.getElementById('chat-input-area').classList.add('hidden');
                            document.getElementById('current-user-id').textContent = 'Regenerating...';

                            // Optionally send a 'nuke' command to the server to clear server-side data
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({ type: 'nuke', userId: userId })); // Send current userId before clearing
                            }

                            showMessageBox('Data Nuked!', 'All local data and user ID have been cleared. A new user ID will be generated on next connection.');
                            // Reinitialize WebSocket to get new ID
                            initWebSocket();
                        } else {
                            showMessageBox('Nuke Cancelled', 'Data deletion cancelled.');
                        }
                    }
                );
            }
        });
    </script>
</body>
</html>
