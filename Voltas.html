<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0; /* Light grey background */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }
        .container {
            background-color: #ffffff; /* White background for the main app */
            border-radius: 1rem; /* Rounded corners for the container */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            width: 95%;
            margin: 1.5rem auto;
            overflow: hidden;
        }
        .header {
            background-color: #f9f9f9; /* Slightly off-white for header */
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            text-align: center;
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
        }
        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            background-color: #f5f5f5; /* Light grey for sidebar */
            border-right: 1px solid #e0e0e0;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }
        .vault-list {
            flex-grow: 1;
            overflow-y: auto;
        }
        .vault-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #e0e0e0;
        }
        .vault-item:hover {
            background-color: #f0f0f0;
        }
        .vault-item.active {
            background-color: #e0e0e0;
            font-weight: 600;
        }
        .chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            overflow: hidden; /* Ensure this doesn't create extra scrollbars */
        }
        .messages-display {
            flex-grow: 1;
            background-color: #f9f9f9;
            border-radius: 0.75rem;
            padding: 1rem;
            overflow-y: auto; /* Make messages scrollable */
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
        }
        .message {
            margin-bottom: 0.75rem;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            /* Adjusted max-width for better responsiveness */
            max-width: calc(100% - 4rem); /* Allows some margin/padding */
            word-wrap: break-word; /* Ensures long words break */
        }
        .message.self {
            background-color: #e0e0e0; /* Light grey for self messages */
            margin-left: auto; /* Aligns to the right */
            text-align: right;
        }
        .message.other {
            background-color: #f0f0f0; /* Even lighter grey for other messages */
            margin-right: auto; /* Aligns to the left */
            text-align: left;
        }
        .message-sender {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }
        .message-content {
            font-size: 1rem;
            color: #333;
        }
        .message-timestamp {
            font-size: 0.7rem;
            color: #999;
            margin-top: 0.5rem;
            display: block;
        }
        .input-area {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .input-area input[type="text"] {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
            outline: none;
        }
        .input-area button {
            padding: 0.75rem 1.5rem;
            background-color: #888; /* Grey for buttons */
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .input-area button:hover {
            background-color: #666;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.show {
            visibility: visible;
            opacity: 1;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            position: relative;
        }
        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
            color: #888;
        }
        .modal-content h2 {
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #333;
            text-align: center;
        }
        .modal-content label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #555;
        }
        .modal-content input,
        .modal-content select {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
        }
        .modal-content button {
            width: 100%;
            padding: 0.75rem;
            background-color: #888;
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            font-size: 1.1rem;
            transition: background-color 0.2s ease;
        }
        .modal-content button:hover {
            background-color: #666;
        }
        .footer {
            text-align: center;
            padding: 1rem;
            color: #666;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        .message-file {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #e0e0e0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
        }
        .message-file svg {
            width: 1.25rem;
            height: 1.25rem;
            fill: #555;
        }
        .message-file span {
            color: #333;
            font-weight: 500;
        }
        .nuke-button {
            background-color: #f44336; /* Red for Nuke button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            margin-top: auto; /* Pushes it to the bottom of the sidebar */
        }
        .nuke-button:hover {
            background-color: #d32f2f;
        }
        .info-message {
            background-color: #fff3cd;
            color: #664d03;
            padding: 0.75rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ffecb3;
            text-align: center;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
                padding-bottom: 0;
            }
            .chat-area {
                padding-top: 0;
            }
            .vault-list {
                max-height: 200px; /* Limit height of vault list on small screens */
            }
            .header {
                font-size: 2rem;
                padding: 1rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            /* Adjust message max-width on very small screens if needed */
            .message {
                max-width: calc(100% - 2rem); /* More room for padding/margin on very small screens */
            }
            .message.self, .message.other {
                margin-left: 0; /* Remove auto margins to simplify */
                margin-right: 0;
                width: 100%; /* Take full width */
            }
            .message.self {
                text-align: right; /* Keep text alignment */
                background-color: #e0e0e0;
            }
            .message.other {
                text-align: left; /* Keep text alignment */
                background-color: #f0f0f0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">The Platform</div>
        <div class="main-content">
            <div class="sidebar">
                <div class="info-message" id="user-id-display">
                    Your ID: <span id="current-user-id">Generating...</span>
                </div>
                <button id="create-vault-btn" class="input-area button">Create Vault</button>
                <button id="join-vault-btn" class="input-area button">Join Vault</button>

                <div class="vault-list" id="vault-list">
                    </div>

                <button id="nuke-btn" class="nuke-button">Nuke All Data</button>
            </div>

            <div class="chat-area">
                <div id="no-vault-selected" class="info-message text-center p-4 rounded-lg bg-gray-100 text-gray-700">
                    Select a vault to start chatting or create/join a new one.
                </div>
                <div id="chat-window" class="messages-display hidden">
                    </div>
                <div id="chat-input-area" class="input-area hidden">
                    <input type="text" id="message-input" placeholder="Type your message...">
                    <input type="file" id="file-input" class="hidden" accept="*/*">
                    <button id="attach-file-btn" title="Attach File">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                            <path fill-rule="evenodd" d="M18.97 3.659A2.25 2.25 0 0 0 17.023 2.25h-13.5A2.25 2.25 0 0 0 1.25 4.5v11.25c0 1.036.724 1.897 1.702 2.131a.75.75 0 0 0 .584.076l7.497-1.5a.75.75 0 0 0 .427-.715V6.25a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 .75.75v6.19l1.777.355a.75.75 0 0 0 .584-.076c.978-.234 1.702-1.095 1.702-2.131V4.5A2.25 2.25 0 0 0 18.97 3.659ZM12 15.75h.007v.008H12v-.008ZM10.5 6a.75.75 0 0 0-.75.75v4.5a.75.75 0 0 0 .75.75h.75a.75.75 0 0 0 .75-.75v-4.5a.75.75 0 0 0-.75-.75h-.75Z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button id="send-message-btn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div id="create-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="create-vault-close">&times;</span>
            <h2>Create New Vault</h2>
            <form id="create-vault-form">
                <label for="vault-name">Vault Name:</label>
                <input type="text" id="vault-name" placeholder="e.g., Family Chat, Project X" required>

                <label for="vault-type">Vault Type:</label>
                <select id="vault-type" required>
                    <option value="private">Private (Direct Message)</option>
                    <option value="public">Public (Group)</option>
                </select>

                <label for="expiration-time">Expiration Time:</label>
                <select id="expiration-time" required>
                    <option value="1h">1 Hour</option>
                    <option value="5h">5 Hours</option>
                    <option value="24h">24 Hours</option>
                    <option value="1mo">1 Month</option>
                    <option value="3mo">3 Months</option>
                    <option value="6mo">6 Months</option>
                    <option value="1yr">1 Year</option>
                    <option value="never">Never</option>
                </select>

                <button type="submit">Create Vault</button>
                <div id="create-vault-hash-display" class="info-message mt-4 hidden">
                    Vault Hash: <span id="generated-vault-hash" class="font-mono break-all"></span><br>
                    <button id="copy-hash-btn" type="button" class="mt-2 w-auto px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm">Copy Hash</button>
                </div>
            </form>
        </div>
    </div>

    <div id="join-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="join-vault-close">&times;</span>
            <h2>Join Existing Vault</h2>
            <form id="join-vault-form">
                <label for="join-vault-hash">Vault Hash:</label>
                <input type="text" id="join-vault-hash" placeholder="Enter vault hash" required>

                <label for="join-vault-name">Name for this Vault (for your reference):</label>
                <input type="text" id="join-vault-name" placeholder="e.g., John's Chat, Dev Team" required>

                <button type="submit">Join Vault</button>
            </form>
        </div>
    </div>

    <div id="message-box" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="message-box-close">&times;</span>
            <h2 id="message-box-title"></h2>
            <p id="message-box-content" class="text-center mb-4"></p>
            <button id="message-box-ok">OK</button>
        </div>
    </div>

    <footer class="footer">
        <p>Encrypted by The Laughing Buddha Protocol</p>
        <p>a Prakhar Solanki creation</p>
        <p>&copy;2025-The Platform.</p>
    </footer>

    <script>
        // Global variables for WebSocket and user ID
        let ws;
        let userId;
        let activeVaultId = null;
        const vaults = new Map(); // Stores vaultId -> { name, type, key, iv, messages: [] }
        // IMPORTANT: Update this to your Render WebSocket URL
        // Example: 'wss://your-app-name.onrender.com'
        const SERVER_URL = 'wss://server-4-e7ch.onrender.com'; // **UPDATE THIS LINE WITH YOUR RENDER URL**

        // New global/scope-level variables for managing file transfers
        const CHUNK_SIZE = 1 * 1024 * 1024; // 1 MB chunks
        let fileTransferProgress = new Map(); // Stores { fileId: { totalChunks, receivedChunks: Map<index, ArrayBuffer>, fileName, fileMimeType, senderId, timestamp } }


        // --- Utility Functions ---

        /**
         * Displays a custom message box instead of alert().
         * @param {string} title - The title of the message box.
         * @param {string} message - The content message.
         * @param {function} onOk - Callback function when OK is clicked.
         */
        function showMessageBox(title, message, onOk = () => {}) {
            const msgBox = document.getElementById('message-box');
            document.getElementById('message-box-title').textContent = title;
            document.getElementById('message-box-content').textContent = message;
            msgBox.classList.add('show');

            const okBtn = document.getElementById('message-box-ok');
            const closeBtn = document.getElementById('message-box-close');

            const closeMessageBox = () => {
                msgBox.classList.remove('show');
                okBtn.removeEventListener('click', okHandler);
                closeBtn.removeEventListener('click', closeHandler);
                onOk();
            };

            const okHandler = () => closeMessageBox();
            const closeHandler = () => closeMessageBox();

            okBtn.addEventListener('click', okHandler);
            closeBtn.addEventListener('click', closeHandler);
        }

        /**
         * Copies text to the clipboard.
         * @param {string} text - The text to copy.
         */
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showMessageBox('Copied!', 'Vault hash copied to clipboard.');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessageBox('Error', 'Failed to copy hash. Please copy manually: ' + text);
            }
            document.body.removeChild(textarea);
        }

        // --- Cryptography (The Laughing Buddha Protocol) ---

        /**
         * Generates a random AES-GCM key.
         * @returns {Promise<CryptoKey>} The generated key.
         */
        async function generateAesKey() {
            return crypto.subtle.generateKey(
                { name: "AES-GCM", length: 256 },
                true, // extractable
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Derives a cryptographic key from a given password (hash) using PBKDF2.
         * This is used to encrypt/decrypt the vault's main AES key.
         * @param {string} password - The vault hash (password).
         * @param {Uint8Array} salt - A unique salt for key derivation.
         * @returns {Promise<CryptoKey>} The derived key.
         */
        async function deriveKeyFromHash(password, salt) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                { name: "PBKDF2" },
                false,
                ["deriveBits", "deriveKey"]
            );
            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000, // High iterations for security
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true, // extractable
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Encrypts data using AES-GCM.
         * @param {ArrayBuffer} data - The data to encrypt.
         * @param {CryptoKey} key - The AES-GCM key.
         * @returns {Promise<{encryptedData: ArrayBuffer, iv: Uint8Array}>} Encrypted data and IV.
         */
        async function encryptData(data, key) {
            const iv = crypto.getRandomValues(new Uint8Array(16)); // 96-bit IV recommended for AES-GCM
            const encryptedData = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                data
            );
            return { encryptedData, iv };
        }

        /**
         * Decrypts data using AES-GCM.
         * @param {ArrayBuffer} encryptedData - The encrypted data.
         * @param {Uint8Array} iv - The IV used for encryption.
         * @param {CryptoKey} key - The AES-GCM key.
         * @returns {Promise<ArrayBuffer>} The decrypted data.
         */
        async function decryptData(encryptedData, iv, key) {
            try {
                return await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encryptedData
                );
            } catch (e) {
                console.error("Decryption failed:", e);
                throw new Error("Decryption failed. Key or data might be corrupted.");
            }
        }

        /**
         * Exports a CryptoKey to a raw ArrayBuffer.
         * @param {CryptoKey} key - The key to export.
         * @returns {Promise<ArrayBuffer>} The raw key data.
         */
        async function exportKey(key) {
            return crypto.subtle.exportKey("raw", key);
        }

        /**
         * Imports a raw ArrayBuffer into a CryptoKey.
         * @param {ArrayBuffer} rawKey - The raw key data.
         * @returns {Promise<CryptoKey>} The imported key.
         */
        async function importKey(rawKey) {
            return crypto.subtle.importKey(
                "raw",
                rawKey,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Encrypts a string message.
         * @param {string} message - The message string.
         * @param {CryptoKey} key - The AES-GCM key for the vault.
         * @returns {Promise<{encryptedMessage: string, iv: string}>} Base64 encoded encrypted message and IV.
         */
        async function encryptMessage(message, key) {
            const enc = new TextEncoder();
            const encoded = enc.encode(message);
            const { encryptedData, iv } = await encryptData(encoded, key);
            return {
                encryptedMessage: btoa(String.fromCharCode(...new Uint8Array(encryptedData))),
                iv: btoa(String.fromCharCode(...iv))
            };
        }

        /**
         * Decrypts a string message.
         * @param {string} encryptedMessageB64 - Base64 encoded encrypted message.
         * @param {string} ivB64 - Base64 encoded IV.
         * @param {CryptoKey} key - The AES-GCM key for the vault.
         * @returns {Promise<string>} The decrypted message string.
         */
        async function decryptMessage(encryptedMessageB64, ivB64, key) {
            try {
                const encryptedData = Uint8Array.from(atob(encryptedMessageB64), c => c.charCodeAt(0));
                const iv = Uint8Array.from(atob(ivB64), c => c.charCodeAt(0));
                const decryptedData = await decryptData(encryptedData, iv, key);
                const dec = new TextDecoder();
                return dec.decode(decryptedData);
            } catch (e) {
                console.error("Error decrypting message:", e);
                return "[Could not decrypt message]";
            }
        }

        // --- File Transfer Engine (Sender Side) ---

        /**
         * Sends a file by chunking, encrypting each chunk, and sending them over WebSocket.
         * @param {File} file - The file to send.
         * @param {string} vaultId - The ID of the vault to send the file to.
         */
        async function sendFileInChunks(file, vaultId) {
            const vault = vaults.get(vaultId);
            if (!vault || !vault.key) {
                showMessageBox('Encryption Error', 'Vault key not available for file encryption.');
                return;
            }

            const fileId = crypto.randomUUID(); // Unique ID for this file transfer
            const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
            const timestamp = new Date().toISOString();

            // 1. Send file metadata first
            sendMessageToServer({
                type: 'send_file_metadata',
                vaultId: vaultId,
                senderId: userId,
                fileId: fileId,
                fileName: file.name,
                fileMimeType: file.type,
                fileSize: file.size,
                totalChunks: totalChunks,
                timestamp: timestamp
            });

            // Display a local message indicating file sending
            const localMessageObj = {
                sender: userId,
                content: `Sending file: ${file.name}... (0%)`, // Initial progress message
                timestamp: timestamp,
                isFile: false, // This is a status message, not the file itself
                fileId: fileId, // Link status message to file transfer
            };
            vault.messages.push(localMessageObj);
            displayMessage(localMessageObj);
            await saveVaultsToLocalStorage();


            let offset = 0;
            let chunkIndex = 0;

            const reader = new FileReader();

            reader.onload = async (e) => {
                const chunkBuffer = e.target.result; // ArrayBuffer of the chunk
                const originalChunkSize = chunkBuffer.byteLength;

                try {
                    // Encrypt the chunk
                    const { encryptedData, iv } = await encryptData(chunkBuffer, vault.key);
                    const encryptedChunkSize = encryptedData.byteLength;

                    // Create binary header (similar to Python's struct.pack)
                    // Header structure:
                    // 0-3: chunkIndex (Uint32)
                    // 4-7: totalChunks (Uint32)
                    // 8-23: fileId (16 bytes from UUID)
                    // 24-27: encryptedChunkSize (Uint32)
                    // 28-31: originalChunkSize (Uint32)
                    const headerBuffer = new ArrayBuffer(32);
                    const headerView = new DataView(headerBuffer);

                    headerView.setUint32(0, chunkIndex, true); // Little-endian
                    headerView.setUint32(4, totalChunks, true); // Little-endian
                    // Convert UUID string to 16-byte array for fileId
                    const fileIdBytes = new Uint8Array(16);
                    let uuidParts = fileId.replace(/-/g, '').match(/.{1,2}/g);
                    for (let i = 0; i < 16; i++) {
                        fileIdBytes[i] = parseInt(uuidParts[i], 16);
                    }
                    new Uint8Array(headerBuffer, 8, 16).set(fileIdBytes); // Copy fileId bytes

                    headerView.setUint32(24, encryptedChunkSize, true); // Little-endian
                    headerView.setUint32(28, originalChunkSize, true); // Little-endian

                    // Combine header, IV, and encrypted chunk
                    const combinedBuffer = new Uint8Array(headerBuffer.byteLength + iv.byteLength + encryptedData.byteLength);
                    combinedBuffer.set(new Uint8Array(headerBuffer), 0);
                    combinedBuffer.set(iv, headerBuffer.byteLength);
                    combinedBuffer.set(new Uint8Array(encryptedData), headerBuffer.byteLength + iv.byteLength);

                    // Convert combined buffer to Base64 for sending over WebSocket
                    const encryptedChunkB64 = btoa(String.fromCharCode(...combinedBuffer));

                    // Send the chunk message
                    sendMessageToServer({
                        type: 'send_file_chunk',
                        vaultId: vaultId,
                        senderId: userId,
                        fileId: fileId,
                        chunkIndex: chunkIndex,
                        totalChunks: totalChunks,
                        encryptedChunk: encryptedChunkB64, // The combined header+IV+ciphertext
                        timestamp: timestamp,
                        fileName: file.name, // Include filename for receiver convenience
                        fileMimeType: file.type // Include mime type for receiver convenience
                    });

                    // Update progress message (optional, but good for UX)
                    const progress = Math.min(100, Math.floor(((chunkIndex + 1) / totalChunks) * 100));
                    const latestMessage = vault.messages.find(msg => msg.fileId === fileId);
                    if (latestMessage) {
                        latestMessage.content = `Sending file: ${file.name}... (${progress}%)`;
                        // Re-render the specific message or update UI
                        const chatWindow = document.getElementById('chat-window');
                        const messageElements = chatWindow.querySelectorAll('.message');
                        messageElements.forEach(el => {
                            if (el.dataset.fileId === fileId) { // Assuming you add data-file-id to message elements
                                el.querySelector('.message-content').textContent = latestMessage.content;
                            }
                        });
                    }


                    offset += originalChunkSize;
                    chunkIndex++;

                    if (offset < file.size) {
                        readNextChunk();
                    } else {
                        // All chunks sent
                        console.log(`File ${file.name} sent in ${totalChunks} chunks.`);
                        // Final update to message
                        if (latestMessage) {
                            latestMessage.content = `File sent: ${file.name}`;
                            const chatWindow = document.getElementById('chat-window');
                            const messageElements = chatWindow.querySelectorAll('.message');
                            messageElements.forEach(el => {
                                if (el.dataset.fileId === fileId) {
                                    el.querySelector('.message-content').textContent = latestMessage.content;
                                }
                            });
                        }
                        await saveVaultsToLocalStorage();
                        showMessageBox('File Sent!', `File "${file.name}" has been sent.`);
                    }
                } catch (error) {
                    console.error("Error encrypting or sending chunk:", error);
                    showMessageBox('File Send Error', `Failed to send file "${file.name}".`);
                    // Clean up any partial transfer state if needed
                }
            };

            reader.onerror = (error) => {
                console.error('Error reading file slice:', error);
                showMessageBox('File Read Error', 'Failed to read file for sending.');
            };

            const readNextChunk = () => {
                const slice = file.slice(offset, offset + CHUNK_SIZE);
                reader.readAsArrayBuffer(slice);
            };

            readNextChunk(); // Start reading the first chunk
        }


        // --- WebSocket Communication ---

        /**
         * Sends a message object to the WebSocket server.
         * @param {object} message - The message object to send.
         */
        function sendMessageToServer(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                console.error('WebSocket not connected. Message not sent:', message);
                showMessageBox('Connection Error', 'Not connected to server. Message could not be sent.');
            }
        }

        /**
         * Initializes the WebSocket connection.
         */
        function initWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            console.warn(`Attempting to connect to WebSocket server at: ${SERVER_URL}`);
            ws = new WebSocket(SERVER_URL);

            ws.onopen = async () => {
                console.log('WebSocket connected.');
                // Send user ID to server upon connection
                sendMessageToServer({ type: 'register', userId: userId });
                // Load vaults from local storage AFTER registering with the server
                // This ensures we have our ID before trying to retrieve offline messages
                await loadVaultsFromLocalStorage();
            };

            ws.onmessage = async (event) => {
                let data;
                try {
                    data = JSON.parse(event.data);
                } catch (e) {
                    console.error("Failed to parse incoming WebSocket message:", e, event.data);
                    showMessageBox('Data Error', 'Received malformed data from server.');
                    return;
                }
                console.log('Received:', data);

                switch (data.type) {
                    case 'vault_created':
                        // Server sends back the hash and encrypted key for the creator
                        const { vaultId, vaultHash, vaultName, vaultType, expiration, encryptedKeyB64, ivB64, saltB64 } = data;
                        const salt = Uint8Array.from(atob(saltB64), c => c.charCodeAt(0));
                        const derivedKeyForVaultKey = await deriveKeyFromHash(vaultHash, salt);
                        const decryptedVaultKeyRaw = await decryptData(
                            Uint8Array.from(atob(encryptedKeyB64), c => c.charCodeAt(0)),
                            Uint8Array.from(atob(ivB64), c => c.charCodeAt(0)),
                            derivedKeyForVaultKey
                        );
                        const vaultAesKey = await importKey(decryptedVaultKeyRaw);

                        vaults.set(vaultId, { id: vaultId, name: vaultName, type: vaultType, expiration: expiration, key: vaultAesKey, messages: [] });
                        await saveVaultsToLocalStorage(); // Await saving
                        renderVaultList();
                        document.getElementById('generated-vault-hash').textContent = vaultHash;
                        document.getElementById('create-vault-hash-display').classList.remove('hidden');
                        showMessageBox('Vault Created!', `Your vault "${vaultName}" has been created. Share this hash: ${vaultHash}`, () => {
                            // Automatically select the new vault after creation
                            selectVault(vaultId);
                        });
                        break;
                    case 'vault_joined':
                        // Server sends back the encrypted key for the joiner
                        const { joinedVaultId, joinedVaultName, joinedVaultType, joinedExpiration, encryptedKeyB64: joinedEncryptedKeyB64, ivB64: joinedIvB64, saltB64: joinedSaltB64, vaultHash: joinHashUsed } = data;
                        const joinSalt = Uint8Array.from(atob(joinedSaltB64), c => c.charCodeAt(0));
                        const derivedKeyForJoinedVaultKey = await deriveKeyFromHash(joinHashUsed, joinSalt);
                        const decryptedJoinedVaultKeyRaw = await decryptData(
                            Uint8Array.from(atob(joinedEncryptedKeyB64), c => c.charCodeAt(0)),
                            Uint8Array.from(atob(joinedIvB64), c => c.charCodeAt(0)),
                            derivedKeyForJoinedVaultKey
                        );
                        const joinedVaultAesKey = await importKey(decryptedJoinedVaultKeyRaw);

                        vaults.set(joinedVaultId, { id: joinedVaultId, name: joinedVaultName, type: joinedVaultType, expiration: joinedExpiration, key: joinedVaultAesKey, messages: [] });
                        await saveVaultsToLocalStorage(); // Await saving
                        renderVaultList();
                        showMessageBox('Vault Joined!', `You have joined "${joinedVaultName}".`, () => {
                            selectVault(joinedVaultId);
                        });
                        break;
                    case 'new_message': // Handles text messages
                        const { vaultId: msgVaultId, senderId, encryptedMessage, iv, timestamp, isFile } = data;
                        const vault = vaults.get(msgVaultId);

                        if (vault) {
                            try {
                                if (!isFile) { // Ensure it's a text message
                                    const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                                    const messageObj = { sender: senderId, content: decryptedContent, timestamp: timestamp, isFile: false };
                                    vault.messages.push(messageObj);
                                    await saveVaultsToLocalStorage(); // Await saving
                                    if (activeVaultId === msgVaultId) {
                                        displayMessage(messageObj);
                                    }
                                } else {
                                    console.warn("Received a file message via 'new_message' type. This should ideally be handled by 'send_file_chunk' now.");
                                    // Fallback for old file message type if it still comes through
                                    const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                                    const messageObj = { sender: senderId, content: decryptedContent, timestamp: timestamp, isFile: isFile, fileName: data.fileName, fileMimeType: data.fileMimeType };
                                    vault.messages.push(messageObj);
                                    await saveVaultsToLocalStorage();
                                    if (activeVaultId === msgVaultId) {
                                        displayMessage(messageObj);
                                    }
                                }
                            } catch (e) {
                                console.error("Failed to decrypt incoming message:", e);
                                // Display a placeholder or error message if decryption fails
                                const messageObj = { sender: senderId, content: "[Could not decrypt message]", timestamp: timestamp, isFile: isFile || false };
                                vault.messages.push(messageObj);
                                await saveVaultsToLocalStorage(); // Await saving
                                if (activeVaultId === msgVaultId) {
                                    displayMessage(messageObj);
                                }
                            }
                        } else {
                            console.warn(`Received message for unknown vault ID: ${msgVaultId}.`);
                        }
                        break;
                    case 'send_file_metadata':
                        // Receiver side: Initialize file transfer progress
                        const {
                            vaultId: metaVaultId,
                            senderId: metaSenderId,
                            fileId: metaFileId,
                            fileName: metaFileName,
                            fileMimeType: metaFileMimeType,
                            fileSize: metaFileSize,
                            totalChunks: metaTotalChunks,
                            timestamp: metaTimestamp
                        } = data;

                        const metaVault = vaults.get(metaVaultId);
                        if (!metaVault) {
                            console.error(`Vault ${metaVaultId} not found for file metadata.`);
                            return;
                        }

                        fileTransferProgress.set(metaFileId, {
                            totalChunks: metaTotalChunks,
                            receivedChunks: new Map(), // Use a Map to store chunks by index
                            fileName: metaFileName,
                            fileMimeType: metaFileMimeType,
                            fileSize: metaFileSize,
                            senderId: metaSenderId,
                            timestamp: metaTimestamp
                        });

                        console.log(`Receiving metadata for file ${metaFileName} (ID: ${metaFileId})`);
                        if (activeVaultId === metaVaultId) {
                            // Display a placeholder message indicating file transfer in progress
                            displayMessage({
                                sender: metaSenderId,
                                content: `Receiving file: ${metaFileName}... (0%)`,
                                timestamp: metaTimestamp,
                                isFile: false, // This is a status message
                                fileId: metaFileId // Link status message to file transfer
                            });
                        }
                        break;
                    case 'send_file_chunk':
                        const {
                            vaultId: chunkVaultId,
                            senderId: chunkSenderId,
                            fileId: chunkFileId,
                            chunkIndex,
                            encryptedChunk, // This now contains header + IV + ciphertext
                            timestamp: chunkTimestamp
                        } = data;

                        const currentVault = vaults.get(chunkVaultId);
                        if (!currentVault || !currentVault.key) {
                            console.error(`Vault ${chunkVaultId} or its key not found for file chunk.`);
                            // Optionally, request metadata again or inform sender of failure
                            return;
                        }

                        const fileTransfer = fileTransferProgress.get(chunkFileId);
                        if (!fileTransfer) {
                            console.warn(`Received chunk for unknown file ID ${chunkFileId}. Metadata might be missing or arrived late.`);
                            // This could happen if metadata was lost or arrived after chunks.
                            // In a real system, you might buffer chunks and request metadata, or drop.
                            return;
                        }

                        try {
                            const combinedBuffer = Uint8Array.from(atob(encryptedChunk), c => c.charCodeAt(0));

                            // Parse the combined buffer to extract header, IV, and ciphertext
                            const headerBuffer = combinedBuffer.slice(0, 32);
                            const headerView = new DataView(headerBuffer.buffer);

                            const receivedChunkIndex = headerView.getUint32(0, true);
                            const receivedTotalChunks = headerView.getUint32(4, true);
                            // fileId bytes are at offset 8, length 16
                            const receivedEncryptedChunkSize = headerView.getUint32(24, true);
                            const receivedOriginalChunkSize = headerView.getUint32(28, true);

                            const iv = combinedBuffer.slice(32, 48); // IV is 16 bytes after header
                            const ciphertext = combinedBuffer.slice(48, 48 + receivedEncryptedChunkSize);

                            const decryptedChunkBuffer = await decryptData(ciphertext.buffer, iv, currentVault.key);

                            // Ensure the decrypted chunk matches original size (important for padding)
                            const finalDecryptedChunk = decryptedChunkBuffer.slice(0, receivedOriginalChunkSize);

                            fileTransfer.receivedChunks.set(receivedChunkIndex, finalDecryptedChunk);

                            console.log(`Received chunk ${receivedChunkIndex + 1}/${receivedTotalChunks} for file ${chunkFileId}`);

                            // Update progress message in chat
                            if (activeVaultId === chunkVaultId) {
                                const progress = Math.min(100, Math.floor((fileTransfer.receivedChunks.size / fileTransfer.totalChunks) * 100));
                                const latestMessage = currentVault.messages.find(msg => msg.fileId === chunkFileId);
                                if (latestMessage) {
                                    latestMessage.content = `Receiving file: ${fileTransfer.fileName}... (${progress}%)`;
                                    // Find and update the specific message element
                                    const chatWindow = document.getElementById('chat-window');
                                    const messageElements = chatWindow.querySelectorAll('.message');
                                    messageElements.forEach(el => {
                                        if (el.dataset.fileId === chunkFileId) {
                                            el.querySelector('.message-content').textContent = latestMessage.content;
                                        }
                                    });
                                }
                            }


                            // Check if all chunks are received
                            if (fileTransfer.receivedChunks.size === fileTransfer.totalChunks) {
                                console.log(`All chunks received for file ${chunkFileId}. Reassembling...`);
                                const allDecryptedBuffers = [];
                                for (let i = 0; i < fileTransfer.totalChunks; i++) {
                                    if (fileTransfer.receivedChunks.has(i)) {
                                        allDecryptedBuffers.push(fileTransfer.receivedChunks.get(i));
                                    } else {
                                        console.error(`Missing chunk ${i} for file ${chunkFileId}`);
                                        showMessageBox('File Error', `Missing chunk ${i} for file ${fileTransfer.fileName}. Reassembly failed.`);
                                        fileTransferProgress.delete(chunkFileId); // Clear incomplete transfer
                                        return;
                                    }
                                }

                                const reassembledBlob = new Blob(allDecryptedBuffers, { type: fileTransfer.fileMimeType });
                                const reassembledUrl = URL.createObjectURL(reassembledBlob);

                                const messageObj = {
                                    sender: fileTransfer.senderId,
                                    content: reassembledUrl, // Store URL for display/download
                                    timestamp: fileTransfer.timestamp,
                                    isFile: true,
                                    fileName: fileTransfer.fileName,
                                    fileMimeType: fileTransfer.fileMimeType,
                                    fileId: chunkFileId // Keep fileId for potential future reference
                                };

                                currentVault.messages.push(messageObj);
                                await saveVaultsToLocalStorage();

                                if (activeVaultId === chunkVaultId) {
                                    displayMessage(messageObj);
                                }
                                fileTransferProgress.delete(chunkFileId); // Clean up
                                showMessageBox('File Received', `File "${fileTransfer.fileName}" received and reassembled!`);
                            }
                        } catch (e) {
                            console.error("Error processing file chunk:", e);
                            showMessageBox('Processing Error', `Failed to process chunk for ${fileTransfer.fileName}.`);
                            fileTransferProgress.delete(chunkFileId); // Clear incomplete transfer
                        }
                        break;
                    case 'user_online':
                    case 'user_offline':
                        // Handle online/offline status updates if needed
                        console.log(`User ${data.userId} is ${data.type}`);
                        break;
                    case 'error':
                        console.error('Server error:', data.message);
                        showMessageBox('Server Error', data.message);
                        break;
                    default:
                        console.warn('Unknown message type:', data.type, data);
                }
                // Scroll to the bottom of the chat display
                const messagesDisplay = document.getElementById('chat-window');
                messagesDisplay.scrollTop = messagesDisplay.scrollHeight;
            };

            ws.onclose = (event) => {
                console.log('WebSocket disconnected:', event);
                showMessageBox('Disconnected', 'Lost connection to the server. Attempting to reconnect...', initWebSocket);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                showMessageBox('Connection Error', 'WebSocket error. Check console for details.');
            };
        }

        // --- UI Rendering Functions ---

        /**
         * Renders the list of vaults in the sidebar.
         */
        function renderVaultList() {
            const vaultListDiv = document.getElementById('vault-list');
            vaultListDiv.innerHTML = ''; // Clear existing list

            vaults.forEach(vault => {
                const vaultItem = document.createElement('div');
                vaultItem.className = `vault-item ${activeVaultId === vault.id ? 'active' : ''}`;
                vaultItem.dataset.vaultId = vault.id;
                vaultItem.innerHTML = `
                    <span>${vault.name}</span>
                    <span class="text-xs text-gray-500">${vault.type === 'private' ? '&#128274;' : '&#128101;'}</span>
                `;
                vaultItem.addEventListener('click', () => selectVault(vault.id));
                vaultListDiv.appendChild(vaultItem);
            });
        }

        /**
         * Selects a vault and displays its messages.
         * @param {string} vaultId - The ID of the vault to select.
         */
        function selectVault(vaultId) {
            activeVaultId = vaultId;
            const chatWindow = document.getElementById('chat-window');
            const noVaultSelected = document.getElementById('no-vault-selected');
            const chatInputArea = document.getElementById('chat-input-area');

            noVaultSelected.classList.add('hidden');
            chatWindow.classList.remove('hidden');
            chatInputArea.classList.remove('hidden');

            renderVaultList(); // Update active state
            displayVaultMessages();

            // Scroll to bottom after loading messages
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /**
         * Displays messages for the currently active vault.
         */
        function displayVaultMessages() {
            const chatWindow = document.getElementById('chat-window');
            chatWindow.innerHTML = ''; // Clear existing messages

            if (!activeVaultId) return;

            const vault = vaults.get(activeVaultId);
            if (!vault) {
                console.error(`Vault with ID ${activeVaultId} not found.`);
                return;
            }

            vault.messages.forEach(msg => displayMessage(msg, false)); // Pass false to avoid redundant scroll on initial load
            chatWindow.scrollTop = chatWindow.scrollHeight; // Scroll to bottom once all messages are rendered
        }

        /**
         * Displays a single message in the chat window.
         * @param {object} messageObj - The message object to display.
         * @param {boolean} [shouldScroll=true] - Whether to scroll to the bottom after displaying.
         */
        function displayMessage(messageObj, shouldScroll = true) {
            const chatWindow = document.getElementById('chat-window');
            const messageElement = document.createElement('div');
            messageElement.className = `message ${messageObj.sender === userId ? 'self' : 'other'}`;
            // Add data-file-id for updating progress messages
            if (messageObj.fileId) {
                messageElement.dataset.fileId = messageObj.fileId;
            }


            const senderName = messageObj.sender === userId ? 'You' : `User ${messageObj.sender.substring(0, 8)}...`;
            const timestamp = new Date(messageObj.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            if (messageObj.isFile) {
                // If it's a file, content is a Blob URL for chunked files
                const fileIcon = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 inline-block mr-1">
                        <path d="M18.97 3.659A2.25 2.25 0 0017.023 2.25h-13.5A2.25 2.25 0 001.25 4.5v11.25c0 1.036.724 1.897 1.702 2.131a.75.75 0 00.584.076l7.497-1.5a.75.75 0 00.427-.715V6.25a.75.75 0 01.75-.75h2.25a.75.75 0 01.75.75v6.19l1.777.355a.75.75 0 00.584-.076c.978-.234 1.702-1.095 1.702-2.131V4.5A2.25 2.25 0 0018.97 3.659z" />
                    </svg>
                `;
                messageElement.innerHTML = `
                    <div class="message-sender">${senderName}</div>
                    <div class="message-content">
                        <a href="${messageObj.content}" download="${messageObj.fileName}" class="message-file">
                            ${fileIcon} <span>${messageObj.fileName}</span>
                        </a>
                    </div>
                    <span class="message-timestamp">${timestamp}</span>
                `;
                // Revoke object URL after download to free memory if it's a blob URL
                if (typeof messageObj.content === 'string' && messageObj.content.startsWith('blob:')) {
                    messageElement.querySelector('a').addEventListener('click', () => {
                        // Small delay to allow browser to start download before revoking
                        setTimeout(() => URL.revokeObjectURL(messageObj.content), 100);
                    });
                }

            } else {
                // Regular text message or file transfer status message
                messageElement.innerHTML = `
                    <div class="message-sender">${senderName}</div>
                    <div class="message-content">${messageObj.content}</div>
                    <span class="message-timestamp">${timestamp}</span>
                `;
            }

            chatWindow.appendChild(messageElement);
            if (shouldScroll) {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }
        }


        // --- Local Storage Management ---

        /**
         * Generates a persistent user ID or retrieves an existing one.
         */
        function getOrCreateUserId() {
            let id = localStorage.getItem('thePlatformUserId'); // Corrected key
            if (!id) {
                id = crypto.randomUUID();
                localStorage.setItem('thePlatformUserId', id); // Corrected key
            }
            document.getElementById('current-user-id').textContent = id;
            return id;
        }

        /**
         * Saves all vault data to local storage.
         */
        async function saveVaultsToLocalStorage() {
            const vaultsToStore = [];
            for (const [vaultId, vault] of vaults.entries()) {
                // Export the CryptoKey to a storable format (raw ArrayBuffer, then Base64)
                let exportedKeyB64 = '';
                if (vault.key) {
                    try {
                        const exportedKey = await exportKey(vault.key);
                        exportedKeyB64 = btoa(String.fromCharCode(...new Uint8Array(exportedKey)));
                    } catch (e) {
                        console.error('Failed to export key for saving:', e);
                        // Handle error, maybe don't save this vault or store a flag
                    }
                }

                vaultsToStore.push({
                    id: vault.id,
                    name: vault.name,
                    type: vault.type,
                    expiration: vault.expiration,
                    exportedKeyB64: exportedKeyB64, // Store exported key
                    // Ensure messages are stored correctly. Blob URLs cannot be directly stored.
                    // For files, we store the URL and filename. On reload, the URL will be invalid.
                    // A real app would need to re-download or store files in IndexedDB.
                    messages: vault.messages.map(msg => {
                        if (msg.isFile && typeof msg.content === 'string' && msg.content.startsWith('blob:')) {
                            // For blob URLs, just store metadata, not the URL itself.
                            // The actual file content would need to be re-fetched or stored persistently (e.g., IndexedDB).
                            // For this demo, we'll store a placeholder or just the filename for display.
                            return { ...msg, content: `[File: ${msg.fileName}]` }; // Placeholder for stored blob URLs
                        }
                        return msg;
                    })
                });
            }
            localStorage.setItem('thePlatformVaults', JSON.stringify(vaultsToStore)); // Corrected key
            console.log('Vaults saved to local storage.');
        }

        /**
         * Loads vault data from local storage.
         */
        async function loadVaultsFromLocalStorage() {
            const storedVaults = JSON.parse(localStorage.getItem('thePlatformVaults') || '[]'); // Corrected key
            vaults.clear(); // Clear current in-memory vaults

            for (const storedVault of storedVaults) {
                let importedKey = null;
                if (storedVault.exportedKeyB64) {
                    try {
                        const rawKey = Uint8Array.from(atob(storedVault.exportedKeyB64), c => c.charCodeAt(0));
                        importedKey = await importKey(rawKey);
                    } catch (e) {
                        console.error('Failed to import key from local storage:', e);
                        showMessageBox('Security Warning', `Failed to load key for vault "${storedVault.name}". Messages may not be decryptable.`);
                    }
                }

                vaults.set(storedVault.id, {
                    id: storedVault.id,
                    name: storedVault.name,
                    type: storedVault.type,
                    expiration: storedVault.expiration,
                    key: importedKey, // Set the imported key
                    messages: storedVault.messages || []
                });
            }
            renderVaultList();
            console.log('Vaults loaded from local storage.');
        }

        /**
         * Clears all local storage data related to the app.
         */
        function nukeAllData() {
            showMessageBox('Confirm Nuke', 'Are you sure you want to wipe ALL your local data and disconnect? This action cannot be undone. This will also attempt to clear your data on the server.', async () => {
                localStorage.removeItem('thePlatformVaults');
                localStorage.removeItem('thePlatformUserId');
                localStorage.removeItem('lastActiveVaultId');
                vaults.clear();
                activeVaultId = null;
                document.getElementById('chat-window').innerHTML = '';
                document.getElementById('vault-list').innerHTML = '';
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('current-user-id').textContent = 'Nuked! Reopen for new ID.';

                // Inform server to remove user's data
                sendMessageToServer({ type: 'nuke', userId: userId });

                // Simulate closing the page by clearing content and displaying a message
                document.body.innerHTML = `
                    <div class="flex flex-col items-center justify-center min-h-screen bg-gray-100 text-gray-700">
                        <h1 class="text-4xl font-bold mb-4">Data Nuked!</h1>
                        <p class="text-lg">All your local data has been wiped.</p>
                        <p class="text-lg">To start fresh, please reopen "The Platform".</p>
                    </div>
                `;
            });
        }


        // --- Event Listeners and Initial Setup ---

        document.addEventListener('DOMContentLoaded', async () => {
            userId = getOrCreateUserId();
            initWebSocket();

            // Modals setup
            const createVaultModal = document.getElementById('create-vault-modal');
            const joinVaultModal = document.getElementById('join-vault-modal');
            document.getElementById('create-vault-btn').addEventListener('click', () => createVaultModal.classList.add('show'));
            document.getElementById('join-vault-btn').addEventListener('click', () => joinVaultModal.classList.add('show'));
            document.getElementById('create-vault-close').addEventListener('click', () => createVaultModal.classList.remove('show'));
            document.getElementById('join-vault-close').addEventListener('click', () => joinVaultModal.classList.remove('show'));

            // Create Vault Form Submission
            document.getElementById('create-vault-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const vaultName = document.getElementById('vault-name').value;
                const vaultType = document.getElementById('vault-type').value;
                const expirationTime = document.getElementById('expiration-time').value;

                if (!userId) {
                    showMessageBox('Error', 'User ID not available. Please refresh.');
                    return;
                }
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    showMessageBox('Connection Error', 'Not connected to server. Cannot create vault.');
                    return;
                }

                // Generate a fresh AES key for the new vault
                const vaultAesKey = await generateAesKey();
                const rawVaultKey = await exportKey(vaultAesKey); // Export to raw bytes

                // Generate a salt for PBKDF2
                const salt = crypto.getRandomValues(new Uint8Array(16)); // 16 bytes for salt

                // Use a temporary hash (e.g., UUID) for the vault until the server returns the actual hash
                // This temporary hash will be used to derive a key to encrypt the vault's AES key
                // which will then be sent to the server. The server will generate a permanent hash.
                const tempVaultHash = crypto.randomUUID(); // This is just a placeholder for the client-side derivation
                const derivedKeyForVaultKeyEncryption = await deriveKeyFromHash(tempVaultHash, salt);

                // Encrypt the vault's AES key using the derived key
                const { encryptedData: encryptedVaultKey, iv: vaultKeyIv } = await encryptData(rawVaultKey, derivedKeyForVaultKeyEncryption);

                sendMessageToServer({
                    type: 'create_vault',
                    creatorId: userId,
                    vaultName: vaultName,
                    vaultType: vaultType,
                    expiration: expirationTime,
                    encryptedKeyB64: btoa(String.fromCharCode(...new Uint8Array(encryptedVaultKey))),
                    ivB64: btoa(String.fromCharCode(...vaultKeyIv)),
                    saltB64: btoa(String.fromCharCode(...salt))
                });

                createVaultModal.classList.remove('show');
                document.getElementById('create-vault-form').reset();
            });

            // Copy Vault Hash Button
            document.getElementById('copy-hash-btn').addEventListener('click', () => {
                const hash = document.getElementById('generated-vault-hash').textContent;
                if (hash) {
                    copyToClipboard(hash);
                }
            });

            // Join Vault Form Submission
            document.getElementById('join-vault-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const joinVaultHash = document.getElementById('join-vault-hash').value;
                const joinVaultName = document.getElementById('join-vault-name').value;

                if (!userId) {
                    showMessageBox('Error', 'User ID not available. Please refresh.');
                    return;
                }
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    showMessageBox('Connection Error', 'Not connected to server. Cannot join vault.');
                    return;
                }

                sendMessageToServer({
                    type: 'join_vault',
                    joinerId: userId,
                    vaultHash: joinVaultHash,
                    vaultName: joinVaultName
                });

                joinVaultModal.classList.remove('show');
                document.getElementById('join-vault-form').reset();
            });

            // Send Message Button
            document.getElementById('send-message-btn').addEventListener('click', async () => {
                const messageInput = document.getElementById('message-input');
                const fileInput = document.getElementById('file-input');
                const messageContent = messageInput.value.trim();
                const selectedFile = fileInput.files[0];

                if (!activeVaultId) {
                    showMessageBox('Error', 'Please select a vault first.');
                    return;
                }

                if (!messageContent && !selectedFile) {
                    showMessageBox('Input Needed', 'Please type a message or attach a file.');
                    return;
                }

                const vault = vaults.get(activeVaultId);
                if (!vault || !vault.key) {
                    showMessageBox('Encryption Error', 'Vault key not available for encryption. Cannot send message or file.');
                    return;
                }

                if (selectedFile) {
                    // Handle file sending via chunking
                    await sendFileInChunks(selectedFile, activeVaultId);
                    fileInput.value = ''; // Clear file input
                    messageInput.value = ''; // Clear message input if text was also typed
                } else if (messageContent) {
                    // Handle text message sending
                    const localMessageObj = {
                        sender: userId,
                        content: messageContent,
                        timestamp: new Date().toISOString(),
                        isFile: false
                    };

                    // Display the message locally right away
                    vault.messages.push(localMessageObj);
                    displayMessage(localMessageObj); // Display immediately
                    await saveVaultsToLocalStorage(); // Ensure local storage is updated

                    // Encrypt and send the text message to the server
                    const { encryptedMessage, iv } = await encryptMessage(messageContent, vault.key);
                    sendMessageToServer({
                        type: 'send_message',
                        vaultId: activeVaultId,
                        senderId: userId,
                        encryptedMessage: encryptedMessage,
                        iv: iv,
                        timestamp: localMessageObj.timestamp, // Use the same timestamp
                        isFile: false,
                        fileName: null,
                        fileMimeType: null
                    });
                    messageInput.value = ''; // Clear input field
                }
            });

            // Attach File Button
            document.getElementById('attach-file-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            // Nuke Button
            document.getElementById('nuke-btn').addEventListener('click', nukeAllData); // Call nukeAllData directly as it has its own confirmation

            // Handle Enter key for sending messages
            document.getElementById('message-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('send-message-btn').click();
                }
            });
        });
    </script>
</body>
</html>
