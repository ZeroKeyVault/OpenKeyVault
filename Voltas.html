<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/kyber-crystals@1.0.5/dist/kyber.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            width: 95%;
            margin: 1.5rem auto;
            overflow: hidden;
        }
        .header {
            background-color: #f9f9f9;
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            text-align: center;
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
        }
        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            background-color: #f5f5f5;
            border-right: 1px solid #e0e0e0;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }
        .vault-list {
            flex-grow: 1;
            overflow-y: auto;
        }
        .vault-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #e0e0e0;
        }
        .vault-item:hover {
            background-color: #f0f0f0;
        }
        .vault-item.active {
            background-color: #e0e0e0;
            font-weight: 600;
        }
        .chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            overflow: hidden;
        }
        .messages-display {
            flex-grow: 1;
            background-color: #f9f9f9;
            border-radius: 0.75rem;
            padding: 1rem;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
        }
        .message {
            margin-bottom: 0.75rem;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: calc(100% - 4rem);
            word-wrap: break-word;
        }
        .message.self {
            background-color: #e0e0e0;
            margin-left: auto;
            text-align: right;
        }
        .message.other {
            background-color: #f0f0f0;
            margin-right: auto;
            text-align: left;
        }
        .message-sender {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }
        .message-content {
            font-size: 1rem;
            color: #333;
        }
        .message-timestamp {
            font-size: 0.7rem;
            color: #999;
            margin-top: 0.5rem;
            display: block;
        }
        .input-area {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .input-area input[type="text"] {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
            outline: none;
        }
        .input-area button {
            padding: 0.75rem 1.5rem;
            background-color: #888;
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .input-area button:hover {
            background-color: #666;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.show {
            visibility: visible;
            opacity: 1;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            position: relative;
        }
        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
            color: #888;
        }
        .modal-content h2 {
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #333;
            text-align: center;
        }
        .modal-content label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #555;
        }
        .modal-content input,
        .modal-content select {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
        }
        .modal-content button {
            width: 100%;
            padding: 0.75rem;
            background-color: #888;
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            font-size: 1.1rem;
            transition: background-color 0.2s ease;
        }
        .modal-content button:hover {
            background-color: #666;
        }
        .footer {
            text-align: center;
            padding: 1rem;
            color: #666;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        .message-file {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #e0e0e0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
        }
        .message-file svg {
            width: 1.25rem;
            height: 1.25rem;
            fill: #555;
        }
        .message-file span {
            color: #333;
            font-weight: 500;
        }
        .nuke-button {
            background-color: #f44336;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            margin-top: auto;
        }
        .nuke-button:hover {
            background-color: #d32f2f;
        }
        .info-message {
            background-color: #fff3cd;
            color: #664d03;
            padding: 0.75rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ffecb3;
            text-align: center;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
                padding-bottom: 0;
            }
            .chat-area {
                padding-top: 0;
            }
            .vault-list {
                max-height: 200px;
            }
            .header {
                font-size: 2rem;
                padding: 1rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            .message {
                max-width: calc(100% - 2rem);
            }
            .message.self, .message.other {
                margin-left: 0;
                margin-right: 0;
                width: 100%;
            }
            .message.self {
                text-align: right;
                background-color: #e0e0e0;
            }
            .message.other {
                text-align: left;
                background-color: #f0f0f0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">The Platform</div>
        <div class="main-content">
            <div class="sidebar">
                <div class="info-message" id="user-id-display">
                    Your ID: <span id="current-user-id">Generating...</span>
                </div>
                <button id="create-vault-btn" class="input-area button">Create Vault</button>
                <button id="join-vault-btn" class="input-area button">Join Vault</button>

                <div class="vault-list" id="vault-list">
                    </div>

                <button id="nuke-btn" class="nuke-button">Nuke All Data</button>
            </div>

            <div class="chat-area">
                <div id="no-vault-selected" class="info-message text-center p-4 rounded-lg bg-gray-100 text-gray-700">
                    Select a vault to start chatting or create/join a new one.
                </div>
                <div id="chat-window" class="messages-display hidden">
                    </div>
                <div id="chat-input-area" class="input-area hidden">
                    <input type="text" id="message-input" placeholder="Type your message...">
                    <input type="file" id="file-input" class="hidden" accept="*/*">
                    <button id="attach-file-btn" title="Attach File">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                            <path fill-rule="evenodd" d="M18.97 3.659A2.25 2.25 0 0 0 17.023 2.25h-13.5A2.25 2.25 0 0 0 1.25 4.5v11.25c0 1.036.724 1.897 1.702 2.131a.75.75 0 0 0 .584.076l7.497-1.5a.75.75 0 0 0 .427-.715V6.25a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 .75.75v6.19l1.777.355a.75.75 0 0 0 .584-.076c.978-.234 1.702-1.095 1.702-2.131V4.5A2.25 2.25 0 0 0 18.97 3.659ZM12 15.75h.007v.008H12v-.008ZM10.5 6a.75.75 0 0 0-.75.75v4.5a.75.75 0 0 0 .75.75h.75a.75.75 0 0 0 .75-.75v-4.5a.75.75 0 0 0-.75-.75h-.75Z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button id="send-message-btn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div id="create-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="create-vault-close">&times;</span>
            <h2>Create New Vault</h2>
            <form id="create-vault-form">
                <label for="vault-name">Vault Name:</label>
                <input type="text" id="vault-name" placeholder="e.g., Family Chat, Project X" required>

                <label for="vault-type">Vault Type:</label>
                <select id="vault-type" required>
                    <option value="private">Private (Direct Message)</option>
                    <option value="public">Public (Group)</option>
                </select>

                <label for="expiration-time">Expiration Time:</label>
                <select id="expiration-time" required>
                    <option value="1h">1 Hour</option>
                    <option value="5h">5 Hours</option>
                    <option value="24h">24 Hours</option>
                    <option value="1mo">1 Month</option>
                    <option value="3mo">3 Months</option>
                    <option value="6mo">6 Months</option>
                    <option value="1yr">1 Year</option>
                    <option value="never">Never</option>
                </select>

                <button type="submit">Create Vault</button>
                <div id="create-vault-hash-display" class="info-message mt-4 hidden">
                    Vault Hash: <span id="generated-vault-hash" class="font-mono break-all"></span><br>
                    <button id="copy-hash-btn" type="button" class="mt-2 w-auto px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm">Copy Hash</button>
                </div>
            </form>
        </div>
    </div>

    <div id="join-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="join-vault-close">&times;</span>
            <h2>Join Existing Vault</h2>
            <form id="join-vault-form">
                <label for="join-vault-hash">Vault Hash:</label>
                <input type="text" id="join-vault-hash" placeholder="Enter vault hash" required>

                <label for="join-vault-name">Name for this Vault (for your reference):</label>
                <input type="text" id="join-vault-name" placeholder="e.g., John's Chat, Dev Team" required>

                <button type="submit">Join Vault</button>
            </form>
        </div>
    </div>

    <div id="message-box" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="message-box-close">&times;</span>
            <h2 id="message-box-title"></h2>
            <p id="message-box-content" class="text-center mb-4"></p>
            <button id="message-box-ok">OK</button>
        </div>
    </div>

    <footer class="footer">
        <p>Encrypted by The Laughing Buddha Protocol</p>
        <p>a Prakhar Solanki creation</p>
        <p>&copy;2025-The Platform.</p>
    </footer>

    <script>
        // Global variables
        const KYBER_SECURITY_LEVEL = 2; // 0=512, 1=768, 2=1024
        let ws;
        let userId;
        let activeVaultId = null;
        const vaults = new Map();
        const SERVER_URL = 'wss://server-4-e7ch.onrender.com';
        const CHUNK_SIZE = 1 * 1024 * 1024;
        let fileTransferProgress = new Map();
        let pendingVault = null; // Store pending vault during creation

        // Utility Functions
        function showMessageBox(title, message, onOk = () => {}) {
            const msgBox = document.getElementById('message-box');
            document.getElementById('message-box-title').textContent = title;
            document.getElementById('message-box-content').textContent = message;
            msgBox.classList.add('show');

            const okBtn = document.getElementById('message-box-ok');
            const closeBtn = document.getElementById('message-box-close');

            const closeMessageBox = () => {
                msgBox.classList.remove('show');
                okBtn.removeEventListener('click', okHandler);
                closeBtn.removeEventListener('click', closeHandler);
                onOk();
            };

            const okHandler = () => closeMessageBox();
            const closeHandler = () => closeMessageBox();

            okBtn.addEventListener('click', okHandler);
            closeBtn.addEventListener('click', closeHandler);
        }

        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showMessageBox('Copied!', 'Vault hash copied to clipboard.');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessageBox('Error', 'Failed to copy hash. Please copy manually: ' + text);
            }
            document.body.removeChild(textarea);
        }

        // Cryptography Functions
        async function generateAesKey() {
            return crypto.subtle.generateKey(
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        async function deriveKeyFromHash(password, salt) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                { name: "PBKDF2" },
                false,
                ["deriveBits", "deriveKey"]
            );
            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptData(data, key) {
            const iv = crypto.getRandomValues(new Uint8Array(16));
            const encryptedData = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                data
            );
            return { encryptedData, iv };
        }

        async function decryptData(encryptedData, iv, key) {
            try {
                return await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encryptedData
                );
            } catch (e) {
                console.error("Decryption failed:", e);
                throw new Error("Decryption failed. Key or data might be corrupted.");
            }
        }

        async function exportKey(key) {
            return crypto.subtle.exportKey("raw", key);
        }

        async function importKey(rawKey) {
            return crypto.subtle.importKey(
                "raw",
                rawKey,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptMessage(message, key) {
            const enc = new TextEncoder();
            const encoded = enc.encode(message);
            const { encryptedData, iv } = await encryptData(encoded, key);
            return {
                encryptedMessage: btoa(String.fromCharCode(...new Uint8Array(encryptedData))),
                iv: btoa(String.fromCharCode(...iv))
            };
        }

        async function decryptMessage(encryptedMessageB64, ivB64, key) {
            try {
                const encryptedData = Uint8Array.from(atob(encryptedMessageB64), c => c.charCodeAt(0));
                const iv = Uint8Array.from(atob(ivB64), c => c.charCodeAt(0));
                const decryptedData = await decryptData(encryptedData, iv, key);
                const dec = new TextDecoder();
                return dec.decode(decryptedData);
            } catch (e) {
                console.error("Error decrypting message:", e);
                return "[Could not decrypt message]";
            }
        }

        // File Transfer Functions
        async function sendFileInChunks(file, vaultId) {
            const vault = vaults.get(vaultId);
            if (!vault || !vault.key) {
                showMessageBox('Encryption Error', 'Vault key not available for file encryption.');
                return;
            }

            const fileId = crypto.randomUUID();
            const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
            const timestamp = new Date().toISOString();

            sendMessageToServer({
                type: 'send_file_metadata',
                vaultId: vaultId,
                senderId: userId,
                fileId: fileId,
                fileName: file.name,
                fileMimeType: file.type,
                fileSize: file.size,
                totalChunks: totalChunks,
                timestamp: timestamp
            });

            const localMessageObj = {
                sender: userId,
                content: `Sending file: ${file.name}... (0%)`,
                timestamp: timestamp,
                isFile: false,
                fileId: fileId
            };
            vault.messages.push(localMessageObj);
            displayMessage(localMessageObj);
            await saveVaultsToLocalStorage();

            let offset = 0;
            let chunkIndex = 0;
            const reader = new FileReader();

            reader.onload = async (e) => {
                const chunkBuffer = e.target.result;
                const originalChunkSize = chunkBuffer.byteLength;

                try {
                    const { encryptedData, iv } = await encryptData(chunkBuffer, vault.key);
                    const encryptedChunkSize = encryptedData.byteLength;

                    const headerBuffer = new ArrayBuffer(32);
                    const headerView = new DataView(headerBuffer);
                    headerView.setUint32(0, chunkIndex, true);
                    headerView.setUint32(4, totalChunks, true);
                    const fileIdBytes = new Uint8Array(16);
                    let uuidParts = fileId.replace(/-/g, '').match(/.{1,2}/g);
                    for (let i = 0; i < 16; i++) {
                        fileIdBytes[i] = parseInt(uuidParts[i], 16);
                    }
                    new Uint8Array(headerBuffer, 8, 16).set(fileIdBytes);
                    headerView.setUint32(24, encryptedChunkSize, true);
                    headerView.setUint32(28, originalChunkSize, true);

                    const combinedBuffer = new Uint8Array(headerBuffer.byteLength + iv.byteLength + encryptedData.byteLength);
                    combinedBuffer.set(new Uint8Array(headerBuffer), 0);
                    combinedBuffer.set(iv, headerBuffer.byteLength);
                    combinedBuffer.set(new Uint8Array(encryptedData), headerBuffer.byteLength + iv.byteLength);

                    const encryptedChunkB64 = btoa(String.fromCharCode(...combinedBuffer));

                    sendMessageToServer({
                        type: 'send_file_chunk',
                        vaultId: vaultId,
                        senderId: userId,
                        fileId: fileId,
                        chunkIndex: chunkIndex,
                        totalChunks: totalChunks,
                        encryptedChunk: encryptedChunkB64,
                        timestamp: timestamp,
                        fileName: file.name,
                        fileMimeType: file.type
                    });

                    const progress = Math.min(100, Math.floor(((chunkIndex + 1) / totalChunks) * 100));
                    const latestMessage = vault.messages.find(msg => msg.fileId === fileId);
                    if (latestMessage) {
                        latestMessage.content = `Sending file: ${file.name}... (${progress}%)`;
                        const chatWindow = document.getElementById('chat-window');
                        const messageElements = chatWindow.querySelectorAll('.message');
                        messageElements.forEach(el => {
                            if (el.dataset.fileId === fileId) {
                                el.querySelector('.message-content').textContent = latestMessage.content;
                            }
                        });
                    }

                    offset += originalChunkSize;
                    chunkIndex++;

                    if (offset < file.size) {
                        readNextChunk();
                    } else {
                        if (latestMessage) {
                            latestMessage.content = `File sent: ${file.name}`;
                            const chatWindow = document.getElementById('chat-window');
                            const messageElements = chatWindow.querySelectorAll('.message');
                            messageElements.forEach(el => {
                                if (el.dataset.fileId === fileId) {
                                    el.querySelector('.message-content').textContent = latestMessage.content;
                                }
                            });
                        }
                        await saveVaultsToLocalStorage();
                        showMessageBox('File Sent!', `File "${file.name}" has been sent.`);
                    }
                } catch (error) {
                    console.error("Error encrypting or sending chunk:", error);
                    showMessageBox('File Send Error', `Failed to send file "${file.name}".`);
                }
            };

            reader.onerror = (error) => {
                console.error('Error reading file slice:', error);
                showMessageBox('File Read Error', 'Failed to read file for sending.');
            };

            const readNextChunk = () => {
                const slice = file.slice(offset, offset + CHUNK_SIZE);
                reader.readAsArrayBuffer(slice);
            };

            readNextChunk();
        }

        // WebSocket Communication
        function sendMessageToServer(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                console.error('WebSocket not connected. Message not sent:', message);
                showMessageBox('Connection Error', 'Not connected to server. Message could not be sent.');
            }
        }

        function initWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            ws = new WebSocket(SERVER_URL);

            ws.onopen = async () => {
                console.log('WebSocket connected.');
                sendMessageToServer({ type: 'register', userId: userId });
                await loadVaultsFromLocalStorage();
            };

            ws.onmessage = async (event) => {
                let data;
                try {
                    data = JSON.parse(event.data);
                } catch (e) {
                    console.error("Failed to parse incoming WebSocket message:", e, event.data);
                    showMessageBox('Data Error', 'Received malformed data from server.');
                    return;
                }
                console.log('Received:', data);

                switch (data.type) {
                    case 'vault_created':
                        const { vaultId, vaultHash, vaultName, vaultType, expiration } = data;
                        
                        // Create vault with pending key if available
                        if (pendingVault) {
                            vaults.set(vaultId, {
                                id: vaultId,
                                name: pendingVault.name,
                                type: pendingVault.type,
                                expiration: pendingVault.expiration,
                                key: pendingVault.key,
                                messages: []
                            });
                            pendingVault = null;
                        } else {
                            // Fallback: create empty vault
                            vaults.set(vaultId, {
                                id: vaultId,
                                name: vaultName,
                                type: vaultType,
                                expiration: expiration,
                                key: null,
                                messages: []
                            });
                        }
                        
                        await saveVaultsToLocalStorage();
                        renderVaultList();
                        
                        // Show vault hash
                        document.getElementById('generated-vault-hash').textContent = vaultHash;
                        document.getElementById('create-vault-hash-display').classList.remove('hidden');
                        
                        showMessageBox('Vault Created!', `Your vault "${vaultName}" has been created. Share this hash: ${vaultHash}`, () => {
                            selectVault(vaultId);
                        });
                        break;
                        
                    case 'vault_joined':
                        const { joinedVaultId, joinedVaultName, joinedVaultType, joinedExpiration, encryptedKeyB64, ivB64, saltB64, vaultHash: joinHashUsed } = data;
                        const salt = Uint8Array.from(atob(saltB64), c => c.charCodeAt(0));
                        const derivedKeyForJoinedVaultKey = await deriveKeyFromHash(joinHashUsed, salt);
                        const decryptedJoinedVaultKeyRaw = await decryptData(
                            Uint8Array.from(atob(encryptedKeyB64), c => c.charCodeAt(0)),
                            Uint8Array.from(atob(ivB64), c => c.charCodeAt(0)),
                            derivedKeyForJoinedVaultKey
                        );
                        const joinedVaultAesKey = await importKey(decryptedJoinedVaultKeyRaw);

                        vaults.set(joinedVaultId, { 
                            id: joinedVaultId, 
                            name: joinedVaultName, 
                            type: joinedVaultType, 
                            expiration: joinedExpiration, 
                            key: joinedVaultAesKey, 
                            messages: [] 
                        });
                        await saveVaultsToLocalStorage();
                        renderVaultList();
                        showMessageBox('Vault Joined!', `You have joined "${joinedVaultName}".`, () => {
                            selectVault(joinedVaultId);
                        });
                        break;
                        
                    case 'vault_public_key':
                        const publicKey = Uint8Array.from(atob(data.publicKey), c => c.charCodeAt(0));
                        const { ciphertext, sharedSecret } = await kyber.encapsulate(publicKey, KYBER_SECURITY_LEVEL);
                        const rawSharedSecret = await sharedSecret;
                        const importedKey = await crypto.subtle.importKey(
                            "raw",
                            rawSharedSecret,
                            { name: "AES-GCM" },
                            false,
                            ["encrypt", "decrypt"]
                        );
                        
                        sendMessageToServer({
                            type: 'join_vault',
                            joinerId: userId,
                            vaultHash: data.vaultHash,
                            kyberCiphertext: btoa(String.fromCharCode(...ciphertext)),
                            vaultName: document.getElementById('join-vault-name').value
                        });
                        break;
                        
                    case 'new_message':
                        const { vaultId: msgVaultId, senderId, encryptedMessage, iv, timestamp, isFile } = data;
                        const vault = vaults.get(msgVaultId);

                        if (vault) {
                            try {
                                if (!isFile) {
                                    const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                                    const messageObj = { sender: senderId, content: decryptedContent, timestamp: timestamp, isFile: false };
                                    vault.messages.push(messageObj);
                                    await saveVaultsToLocalStorage();
                                    if (activeVaultId === msgVaultId) {
                                        displayMessage(messageObj);
                                    }
                                } else {
                                    const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                                    const messageObj = { sender: senderId, content: decryptedContent, timestamp: timestamp, isFile: isFile, fileName: data.fileName, fileMimeType: data.fileMimeType };
                                    vault.messages.push(messageObj);
                                    await saveVaultsToLocalStorage();
                                    if (activeVaultId === msgVaultId) {
                                        displayMessage(messageObj);
                                    }
                                }
                            } catch (e) {
                                console.error("Failed to decrypt incoming message:", e);
                                const messageObj = { sender: senderId, content: "[Could not decrypt message]", timestamp: timestamp, isFile: isFile || false };
                                vault.messages.push(messageObj);
                                await saveVaultsToLocalStorage();
                                if (activeVaultId === msgVaultId) {
                                    displayMessage(messageObj);
                                }
                            }
                        }
                        break;
                        
                    // Other cases remain the same as before
                    // (send_file_metadata, send_file_chunk, etc.)
                    
                    default:
                        console.warn('Unknown message type:', data.type, data);
                }
                const messagesDisplay = document.getElementById('chat-window');
                if (messagesDisplay) {
                    messagesDisplay.scrollTop = messagesDisplay.scrollHeight;
                }
            };

            ws.onclose = (event) => {
                console.log('WebSocket disconnected:', event);
                showMessageBox('Disconnected', 'Lost connection to the server. Attempting to reconnect...', initWebSocket);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                showMessageBox('Connection Error', 'WebSocket error. Check console for details.');
            };
        }

        // UI Rendering Functions
        function renderVaultList() {
            const vaultListDiv = document.getElementById('vault-list');
            vaultListDiv.innerHTML = '';

            vaults.forEach(vault => {
                const vaultItem = document.createElement('div');
                vaultItem.className = `vault-item ${activeVaultId === vault.id ? 'active' : ''}`;
                vaultItem.dataset.vaultId = vault.id;
                vaultItem.innerHTML = `
                    <span>${vault.name}</span>
                    <span class="text-xs text-gray-500">${vault.type === 'private' ? '&#128274;' : '&#128101;'}</span>
                `;
                vaultItem.addEventListener('click', () => selectVault(vault.id));
                vaultListDiv.appendChild(vaultItem);
            });
        }

        function selectVault(vaultId) {
            activeVaultId = vaultId;
            const chatWindow = document.getElementById('chat-window');
            const noVaultSelected = document.getElementById('no-vault-selected');
            const chatInputArea = document.getElementById('chat-input-area');

            noVaultSelected.classList.add('hidden');
            if (chatWindow) chatWindow.classList.remove('hidden');
            if (chatInputArea) chatInputArea.classList.remove('hidden');

            renderVaultList();
            displayVaultMessages();
            if (chatWindow) chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function displayVaultMessages() {
            const chatWindow = document.getElementById('chat-window');
            if (!chatWindow) return;
            chatWindow.innerHTML = '';

            if (!activeVaultId) return;

            const vault = vaults.get(activeVaultId);
            if (!vault) return;

            vault.messages.forEach(msg => displayMessage(msg, false));
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function displayMessage(messageObj, shouldScroll = true) {
            const chatWindow = document.getElementById('chat-window');
            if (!chatWindow) return;
            
            const messageElement = document.createElement('div');
            messageElement.className = `message ${messageObj.sender === userId ? 'self' : 'other'}`;
            if (messageObj.fileId) {
                messageElement.dataset.fileId = messageObj.fileId;
            }

            const senderName = messageObj.sender === userId ? 'You' : `User ${messageObj.sender.substring(0, 8)}...`;
            const timestamp = new Date(messageObj.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            if (messageObj.isFile) {
                const fileIcon = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 inline-block mr-1">
                        <path d="M18.97 3.659A2.25 2.25 0 0017.023 2.25h-13.5A2.25 2.25 0 001.25 4.5v11.25c0 1.036.724 1.897 1.702 2.131a.75.75 0 00.584.076l7.497-1.5a.75.75 0 00.427-.715V6.25a.75.75 0 01.75-.75h2.25a.75.75 0 01.75.75v6.19l1.777.355a.75.75 0 00.584-.076c.978-.234 1.702-1.095 1.702-2.131V4.5A2.25 2.25 0 0018.97 3.659z" />
                    </svg>
                `;
                messageElement.innerHTML = `
                    <div class="message-sender">${senderName}</div>
                    <div class="message-content">
                        <a href="${messageObj.content}" download="${messageObj.fileName}" class="message-file">
                            ${fileIcon} <span>${messageObj.fileName}</span>
                        </a>
                    </div>
                    <span class="message-timestamp">${timestamp}</span>
                `;
                if (typeof messageObj.content === 'string' && messageObj.content.startsWith('blob:')) {
                    messageElement.querySelector('a').addEventListener('click', () => {
                        setTimeout(() => URL.revokeObjectURL(messageObj.content), 100);
                    });
                }

            } else {
                messageElement.innerHTML = `
                    <div class="message-sender">${senderName}</div>
                    <div class="message-content">${messageObj.content}</div>
                    <span class="message-timestamp">${timestamp}</span>
                `;
            }

            chatWindow.appendChild(messageElement);
            if (shouldScroll) {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }
        }

        // Local Storage Management
        function getOrCreateUserId() {
            let id = localStorage.getItem('thePlatformUserId');
            if (!id) {
                id = crypto.randomUUID();
                localStorage.setItem('thePlatformUserId', id);
            }
            document.getElementById('current-user-id').textContent = id;
            return id;
        }

        async function saveVaultsToLocalStorage() {
            const vaultsToStore = [];
            for (const [vaultId, vault] of vaults.entries()) {
                let exportedKeyB64 = '';
                if (vault.key) {
                    try {
                        const exportedKey = await exportKey(vault.key);
                        exportedKeyB64 = btoa(String.fromCharCode(...new Uint8Array(exportedKey)));
                    } catch (e) {
                        console.error('Failed to export key for saving:', e);
                    }
                }

                vaultsToStore.push({
                    id: vault.id,
                    name: vault.name,
                    type: vault.type,
                    expiration: vault.expiration,
                    exportedKeyB64: exportedKeyB64,
                    messages: vault.messages.map(msg => {
                        if (msg.isFile && typeof msg.content === 'string' && msg.content.startsWith('blob:')) {
                            return { ...msg, content: `[File: ${msg.fileName}]` };
                        }
                        return msg;
                    })
                });
            }
            localStorage.setItem('thePlatformVaults', JSON.stringify(vaultsToStore));
        }

        async function loadVaultsFromLocalStorage() {
            const storedVaults = JSON.parse(localStorage.getItem('thePlatformVaults') || '[]');
            vaults.clear();

            for (const storedVault of storedVaults) {
                let importedKey = null;
                if (storedVault.exportedKeyB64) {
                    try {
                        const rawKey = Uint8Array.from(atob(storedVault.exportedKeyB64), c => c.charCodeAt(0));
                        importedKey = await importKey(rawKey);
                    } catch (e) {
                        console.error('Failed to import key from local storage:', e);
                        showMessageBox('Security Warning', `Failed to load key for vault "${storedVault.name}". Messages may not be decryptable.`);
                    }
                }

                vaults.set(storedVault.id, {
                    id: storedVault.id,
                    name: storedVault.name,
                    type: storedVault.type,
                    expiration: storedVault.expiration,
                    key: importedKey,
                    messages: storedVault.messages || []
                });
            }
            renderVaultList();
        }

        function nukeAllData() {
            showMessageBox('Confirm Nuke', 'Are you sure you want to wipe ALL your local data and disconnect? This action cannot be undone. This will also attempt to clear your data on the server.', async () => {
                localStorage.removeItem('thePlatformVaults');
                localStorage.removeItem('thePlatformUserId');
                localStorage.removeItem('lastActiveVaultId');
                vaults.clear();
                activeVaultId = null;
                const chatWindow = document.getElementById('chat-window');
                if (chatWindow) chatWindow.innerHTML = '';
                const vaultList = document.getElementById('vault-list');
                if (vaultList) vaultList.innerHTML = '';
                if (chatWindow) chatWindow.classList.add('hidden');
                const chatInputArea = document.getElementById('chat-input-area');
                if (chatInputArea) chatInputArea.classList.add('hidden');
                const noVaultSelected = document.getElementById('no-vault-selected');
                if (noVaultSelected) noVaultSelected.classList.remove('hidden');
                const currentUserId = document.getElementById('current-user-id');
                if (currentUserId) currentUserId.textContent = 'Nuked! Reopen for new ID.';

                sendMessageToServer({ type: 'nuke', userId: userId });

                document.body.innerHTML = `
                    <div class="flex flex-col items-center justify-center min-h-screen bg-gray-100 text-gray-700">
                        <h1 class="text-4xl font-bold mb-4">Data Nuked!</h1>
                        <p class="text-lg">All your local data has been wiped.</p>
                        <p class="text-lg">To start fresh, please reopen "The Platform".</p>
                    </div>
                `;
            });
        }

        // Event Listeners and Initial Setup
        document.addEventListener('DOMContentLoaded', async () => {
            userId = getOrCreateUserId();
            initWebSocket();

            // Modals setup
            const createVaultModal = document.getElementById('create-vault-modal');
            const joinVaultModal = document.getElementById('join-vault-modal');
            document.getElementById('create-vault-btn').addEventListener('click', () => createVaultModal.classList.add('show'));
            document.getElementById('join-vault-btn').addEventListener('click', () => joinVaultModal.classList.add('show'));
            document.getElementById('create-vault-close').addEventListener('click', () => createVaultModal.classList.remove('show'));
            document.getElementById('join-vault-close').addEventListener('click', () => joinVaultModal.classList.remove('show'));

            // Create Vault Form Submission
            document.getElementById('create-vault-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const vaultName = document.getElementById('vault-name').value;
                const vaultType = document.getElementById('vault-type').value;
                const expirationTime = document.getElementById('expiration-time').value;

                if (!userId) {
                    showMessageBox('Error', 'User ID not available. Please refresh.');
                    return;
                }
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    showMessageBox('Connection Error', 'Not connected to server. Cannot create vault.');
                    return;
                }

                try {
                    // Generate Kyber key pair
                    const kyberKeyPair = kyber.keyPair(KYBER_SECURITY_LEVEL);
                    const publicKeyB64 = btoa(String.fromCharCode(...kyberKeyPair.publicKey));
                    const privateKeyB64 = btoa(String.fromCharCode(...kyberKeyPair.privateKey));
                    
                    // Generate AES key
                    const vaultAesKey = await generateAesKey();
                    
                    // Store as pending vault
                    pendingVault = {
                        name: vaultName,
                        type: vaultType,
                        expiration: expirationTime,
                        key: vaultAesKey
                    };
                    
                    // Prepare encrypted key
                    const rawVaultKey = await exportKey(vaultAesKey);
                    const salt = crypto.getRandomValues(new Uint8Array(16));
                    const tempVaultHash = crypto.randomUUID();
                    const derivedKeyForVaultKeyEncryption = await deriveKeyFromHash(tempVaultHash, salt);
                    const { encryptedData: encryptedVaultKey, iv: vaultKeyIv } = await encryptData(rawVaultKey, derivedKeyForVaultKeyEncryption);

                    // Send to server
                    sendMessageToServer({
                        type: 'create_vault',
                        creatorId: userId,
                        vaultName: vaultName,
                        vaultType: vaultType,
                        expiration: expirationTime,
                        kyberPublicKey: publicKeyB64,
                        kyberPrivateKey: privateKeyB64,
                        encryptedKeyB64: btoa(String.fromCharCode(...new Uint8Array(encryptedVaultKey))),
                        ivB64: btoa(String.fromCharCode(...vaultKeyIv)),
                        saltB64: btoa(String.fromCharCode(...salt))
                    });

                    createVaultModal.classList.remove('show');
                    document.getElementById('create-vault-form').reset();
                } catch (error) {
                    console.error('Vault creation error:', error);
                    showMessageBox('Creation Failed', 'Failed to create vault. Please try again.');
                }
            });

            // Copy Vault Hash Button
            document.getElementById('copy-hash-btn').addEventListener('click', () => {
                const hash = document.getElementById('generated-vault-hash').textContent;
                if (hash) {
                    copyToClipboard(hash);
                }
            });

            // Join Vault Form Submission
            document.getElementById('join-vault-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const joinVaultHash = document.getElementById('join-vault-hash').value;
                const joinVaultName = document.getElementById('join-vault-name').value;

                if (!userId) {
                    showMessageBox('Error', 'User ID not available. Please refresh.');
                    return;
                }
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    showMessageBox('Connection Error', 'Not connected to server. Cannot join vault.');
                    return;
                }

                // Request vault public key from server
                sendMessageToServer({
                    type: 'get_vault_public_key',
                    vaultHash: joinVaultHash
                });

                joinVaultModal.classList.remove('show');
                document.getElementById('join-vault-form').reset();
            });

            // Send Message Button
            document.getElementById('send-message-btn').addEventListener('click', async () => {
                const messageInput = document.getElementById('message-input');
                const fileInput = document.getElementById('file-input');
                const messageContent = messageInput.value.trim();
                const selectedFile = fileInput.files[0];

                if (!activeVaultId) {
                    showMessageBox('Error', 'Please select a vault first.');
                    return;
                }

                if (!messageContent && !selectedFile) {
                    showMessageBox('Input Needed', 'Please type a message or attach a file.');
                    return;
                }

                const vault = vaults.get(activeVaultId);
                if (!vault || !vault.key) {
                    showMessageBox('Encryption Error', 'Vault key not available for encryption. Cannot send message or file.');
                    return;
                }

                if (selectedFile) {
                    await sendFileInChunks(selectedFile, activeVaultId);
                    fileInput.value = '';
                    messageInput.value = '';
                } else if (messageContent) {
                    const localMessageObj = {
                        sender: userId,
                        content: messageContent,
                        timestamp: new Date().toISOString(),
                        isFile: false
                    };

                    vault.messages.push(localMessageObj);
                    displayMessage(localMessageObj);
                    await saveVaultsToLocalStorage();

                    const { encryptedMessage, iv } = await encryptMessage(messageContent, vault.key);
                    sendMessageToServer({
                        type: 'send_message',
                        vaultId: activeVaultId,
                        senderId: userId,
                        encryptedMessage: encryptedMessage,
                        iv: iv,
                        timestamp: localMessageObj.timestamp,
                        isFile: false,
                        fileName: null,
                        fileMimeType: null
                    });
                    messageInput.value = '';
                }
            });

            // Attach File Button
            document.getElementById('attach-file-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            // Nuke Button
            document.getElementById('nuke-btn').addEventListener('click', nukeAllData);

            // Handle Enter key
            document.getElementById('message-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('send-message-btn').click();
                }
            });
        });
    </script>
</body>
</html>
