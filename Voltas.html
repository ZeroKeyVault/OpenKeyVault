<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Import Kyber Library -->
    <script src="https://unpkg.com/@noble/post-quantum@0.1.0/index.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            width: 95%;
            margin: 1.5rem auto;
            overflow: hidden;
        }
        .header {
            background-color: #f9f9f9;
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            text-align: center;
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
        }
        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            background-color: #f5f5f5;
            border-right: 1px solid #e0e0e0;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }
        .vault-list {
            flex-grow: 1;
            overflow-y: auto;
        }
        .vault-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #e0e0e0;
        }
        .vault-item:hover {
            background-color: #f0f0f0;
        }
        .vault-item.active {
            background-color: #e0e0e0;
            font-weight: 600;
        }
        .chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            overflow: hidden;
        }
        .messages-display {
            flex-grow: 1;
            background-color: #f9f9f9;
            border-radius: 0.75rem;
            padding: 1rem;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
        }
        .message {
            margin-bottom: 0.75rem;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: calc(100% - 4rem);
            word-wrap: break-word;
        }
        .message.self {
            background-color: #e0e0e0;
            margin-left: auto;
            text-align: right;
        }
        .message.other {
            background-color: #f0f0f0;
            margin-right: auto;
            text-align: left;
        }
        .message-sender {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }
        .message-content {
            font-size: 1rem;
            color: #333;
        }
        .message-timestamp {
            font-size: 0.7rem;
            color: #999;
            margin-top: 0.5rem;
            display: block;
        }
        .input-area {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .input-area input[type="text"] {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
            outline: none;
        }
        .input-area button {
            padding: 0.75rem 1.5rem;
            background-color: #888;
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .input-area button:hover {
            background-color: #666;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.show {
            visibility: visible;
            opacity: 1;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            position: relative;
        }
        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
            color: #888;
        }
        .modal-content h2 {
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #333;
            text-align: center;
        }
        .modal-content label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #555;
        }
        .modal-content input,
        .modal-content select {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
        }
        .modal-content button {
            width: 100%;
            padding: 0.75rem;
            background-color: #888;
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            font-size: 1.1rem;
            transition: background-color 0.2s ease;
        }
        .modal-content button:hover {
            background-color: #666;
        }
        .footer {
            text-align: center;
            padding: 1rem;
            color: #666;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        .message-file {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #e0e0e0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
        }
        .message-file svg {
            width: 1.25rem;
            height: 1.25rem;
            fill: #555;
        }
        .message-file span {
            color: #333;
            font-weight: 500;
        }
        .nuke-button {
            background-color: #f44336;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            margin-top: auto;
        }
        .nuke-button:hover {
            background-color: #d32f2f;
        }
        .info-message {
            background-color: #fff3cd;
            color: #664d03;
            padding: 0.75rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ffecb3;
            text-align: center;
        }
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
                padding-bottom: 0;
            }
            .chat-area {
                padding-top: 0;
            }
            .vault-list {
                max-height: 200px;
            }
            .header {
                font-size: 2rem;
                padding: 1rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            .message {
                max-width: calc(100% - 2rem);
            }
            .message.self, .message.other {
                margin-left: 0;
                margin-right: 0;
                width: 100%;
            }
            .message.self {
                text-align: right;
                background-color: #e0e0e0;
            }
            .message.other {
                text-align: left;
                background-color: #f0f0f0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">The Platform</div>
        <div class="main-content">
            <div class="sidebar">
                <div class="info-message" id="user-id-display">
                    Your ID: <span id="current-user-id">Generating...</span>
                </div>
                <button id="create-vault-btn" class="input-area button">Create Vault</button>
                <button id="join-vault-btn" class="input-area button">Join Vault</button>
                <div class="vault-list" id="vault-list">
                </div>
                <button id="nuke-btn" class="nuke-button">Nuke All Data</button>
            </div>
            <div class="chat-area">
                <div id="no-vault-selected" class="info-message text-center p-4 rounded-lg bg-gray-100 text-gray-700">
                    Select a vault to start chatting or create/join a new one.
                </div>
                <div id="chat-window" class="messages-display hidden">
                </div>
                <div id="chat-input-area" class="input-area hidden">
                    <input type="text" id="message-input" placeholder="Type your message...">
                    <input type="file" id="file-input" class="hidden" accept="*/*">
                    <button id="attach-file-btn" title="Attach File">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                            <path fill-rule="evenodd" d="M18.97 3.659A2.25 2.25 0 0 0 17.023 2.25h-13.5A2.25 2.25 0 0 0 1.25 4.5v11.25c0 1.036.724 1.897 1.702 2.131a.75.75 0 0 0 .584.076l7.497-1.5a.75.75 0 0 0 .427-.715V6.25a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 .75.75v6.19l1.777.355a.75.75 0 0 0 .584-.076c.978-.234 1.702-1.095 1.702-2.131V4.5A2.25 2.25 0 0 0 18.97 3.659ZM12 15.75h.007v.008H12v-.008ZM10.5 6a.75.75 0 0 0-.75.75v4.5a.75.75 0 0 0 .75.75h.75a.75.75 0 0 0 .75-.75v-4.5a.75.75 0 0 0-.75-.75h-.75Z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button id="send-message-btn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div id="create-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="create-vault-close">&times;</span>
            <h2>Create New Vault</h2>
            <form id="create-vault-form">
                <label for="vault-name">Vault Name:</label>
                <input type="text" id="vault-name" placeholder="e.g., Family Chat, Project X" required>
                <label for="vault-type">Vault Type:</label>
                <select id="vault-type" required>
                    <option value="private">Private (Direct Message)</option>
                    <option value="public">Public (Group)</option>
                </select>
                <label for="expiration-time">Expiration Time:</label>
                <select id="expiration-time" required>
                    <option value="1h">1 Hour</option>
                    <option value="5h">5 Hours</option>
                    <option value="24h">24 Hours</option>
                    <option value="1mo">1 Month</option>
                    <option value="3mo">3 Months</option>
                    <option value="6mo">6 Months</option>
                    <option value="1yr">1 Year</option>
                    <option value="never">Never</option>
                </select>
                <button type="submit">Create Vault</button>
                <div id="create-vault-hash-display" class="info-message mt-4 hidden">
                    Vault Hash: <span id="generated-vault-hash" class="font-mono break-all"></span><br>
                    <button id="copy-hash-btn" type="button" class="mt-2 w-auto px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm">Copy Hash</button>
                </div>
            </form>
        </div>
    </div>

    <div id="join-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="join-vault-close">&times;</span>
            <h2>Join Existing Vault</h2>
            <form id="join-vault-form">
                <label for="join-vault-hash">Vault Hash:</label>
                <input type="text" id="join-vault-hash" placeholder="Enter vault hash" required>
                <label for="join-vault-name">Name for this Vault (for your reference):</label>
                <input type="text" id="join-vault-name" placeholder="e.g., John's Chat, Dev Team" required>
                <button type="submit">Join Vault</button>
            </form>
        </div>
    </div>

    <div id="message-box" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="message-box-close">&times;</span>
            <h2 id="message-box-title"></h2>
            <p id="message-box-content" class="text-center mb-4"></p>
            <button id="message-box-ok">OK</button>
        </div>
    </div>

    <footer class="footer">
        <p>Encrypted by The Laughing Buddha Protocol</p>
        <p>a Prakhar Solanki creation</p>
        <p>&copy;2025-The Platform.</p>
    </footer>

    <script>
        // Global variables for WebSocket and user ID
        let ws;
        let userId;
        let activeVaultId = null;
        // Updated Vault structure in Map to include Kyber keys for private vaults
        const vaults = new Map(); // Stores vaultId -> { id, name, type, expiration, key (AES), sk_enc (Kyber private key Uint8Array for private), pk_enc_b64 (for private), ciphertext_b64 (for private), messages: [] }
        // IMPORTANT: Update this to your Render WebSocket URL
        const SERVER_URL = 'wss://server-8-urh0.onrender.com'; // **UPDATE THIS LINE WITH YOUR RENDER URL**

        // --- Utility Functions ---
        function showMessageBox(title, message, onOk = () => {}) {
            const msgBox = document.getElementById('message-box');
            document.getElementById('message-box-title').textContent = title;
            document.getElementById('message-box-content').textContent = message;
            msgBox.classList.add('show');
            const okBtn = document.getElementById('message-box-ok');
            const closeBtn = document.getElementById('message-box-close');
            const closeMessageBox = () => {
                msgBox.classList.remove('show');
                okBtn.removeEventListener('click', okHandler);
                closeBtn.removeEventListener('click', closeHandler);
                onOk();
            };
            const okHandler = () => closeMessageBox();
            const closeHandler = () => closeMessageBox();
            okBtn.addEventListener('click', okHandler);
            closeBtn.addEventListener('click', closeHandler);
        }

        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showMessageBox('Copied!', 'Vault hash copied to clipboard.');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessageBox('Error', 'Failed to copy hash. Please copy manually: ' + text);
            }
            document.body.removeChild(textarea);
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        function base64ToBlob(base64, mimeType) {
            const byteString = atob(base64.split(',')[1]);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            return new Blob([ab], { type: mimeType });
        }

        function downloadFile(base64Data, filename, mimeType) {
            const blob = base64ToBlob(base64Data, mimeType);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- Cryptography (The Laughing Buddha Protocol) ---
        // Standard AES-GCM functions remain unchanged
        async function generateAesKey() {
            return crypto.subtle.generateKey(
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        // PBKDF2 derivation remains for Public Vaults
        async function deriveKeyFromHash(password, salt) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                { name: "PBKDF2" },
                false,
                ["deriveBits", "deriveKey"]
            );
            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptData(data, key) {
            const iv = crypto.getRandomValues(new Uint8Array(16));
            const encryptedData = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                data
            );
            return { encryptedData, iv };
        }

        async function decryptData(encryptedData, iv, key) {
            try {
                return await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encryptedData
                );
            } catch (e) {
                console.error("Decryption failed:", e);
                throw new Error("Decryption failed. Key or data might be corrupted.");
            }
        }

        async function exportKey(key) {
            return crypto.subtle.exportKey("raw", key);
        }

        async function importKey(rawKey) {
            return crypto.subtle.importKey(
                "raw",
                rawKey,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptMessage(message, key) {
            const enc = new TextEncoder();
            const encoded = enc.encode(message);
            const { encryptedData, iv } = await encryptData(encoded, key);
            return {
                encryptedMessage: btoa(String.fromCharCode(...new Uint8Array(encryptedData))),
                iv: btoa(String.fromCharCode(...iv))
            };
        }

        async function decryptMessage(encryptedMessageB64, ivB64, key) {
            try {
                const encryptedData = Uint8Array.from(atob(encryptedMessageB64), c => c.charCodeAt(0));
                const iv = Uint8Array.from(atob(ivB64), c => c.charCodeAt(0));
                const decryptedData = await decryptData(encryptedData, iv, key);
                const dec = new TextDecoder();
                return dec.decode(decryptedData);
            } catch (e) {
                console.error("Error decrypting message:", e);
                return "[Could not decrypt message]";
            }
        }

        // --- Kyber PQC Integration (Client-side) ---
        // HKDF-SHA256 implementation for deriving AES key from Kyber shared secret
        async function hkdfSha256(ikm, salt = new Uint8Array(32).fill(0), info = new TextEncoder().encode("ThePlatformKyberDerivedKey"), length = 32) {
             // Import the salt
             const saltKey = await crypto.subtle.importKey(
                 "raw",
                 salt,
                 { name: "HMAC", hash: "SHA-256" },
                 false,
                 ["sign"]
             );

             // Extract step
             const prk = await crypto.subtle.sign("HMAC", saltKey, ikm);
             const prkBytes = new Uint8Array(prk);

             // Expand step
             const infoBytes = new TextEncoder().encode(info);
             const n = Math.ceil(length / 32); // 32 is hash length for SHA-256
             let okm = new Uint8Array();
             let t = new Uint8Array();

             for (let i = 1; i <= n; i++) {
                 const input = new Uint8Array(t.length + infoBytes.length + 1);
                 input.set(t, 0);
                 input.set(infoBytes, t.length);
                 input[input.length - 1] = i;

                 const tKey = await crypto.subtle.importKey(
                     "raw",
                     prkBytes,
                     { name: "HMAC", hash: "SHA-256" },
                     false,
                     ["sign"]
                 );
                 t = new Uint8Array(await crypto.subtle.sign("HMAC", tKey, input));
                 okm = new Uint8Array([...okm, ...t]);
             }

             return okm.slice(0, length);
        }

        // Function to derive the AES-GCM key from the Kyber shared secret
        async function deriveAesKeyFromKyberSecret(sharedSecret) {
             // Use HKDF-SHA256 to derive a 32-byte key from the shared secret
             const derivedKeyBytes = await hkdfSha256(sharedSecret);
             // Import the derived bytes as an AES-GCM key
             return await importKey(derivedKeyBytes);
        }


        // --- WebSocket Communication ---
        function initWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            console.warn(`Attempting to connect to WebSocket server at: ${SERVER_URL}`);
            ws = new WebSocket(SERVER_URL);
            ws.onopen = async () => {
                console.log('WebSocket connected.');
                ws.send(JSON.stringify({ type: 'register', userId: userId }));
                await loadVaultsFromLocalStorage();
            };
            ws.onmessage = async (event) => {
                let data;
                try {
                    data = JSON.parse(event.data);
                } catch (e) {
                    console.error("Failed to parse incoming WebSocket message:", e, event.data);
                    showMessageBox('Data Error', 'Received malformed data from server.');
                    return;
                }
                console.log('Received:', data);
                switch (data.type) {
                    case 'vault_created':
                        const { vaultId, vaultHash, vaultName, vaultType, expiration } = data;
                        let vaultAesKey = null;

                        if (vaultType === 'public') {
                            // --- Public Vault Creation Response (Unchanged) ---
                            const { encryptedKeyB64, ivB64, saltB64 } = data;
                            const salt = Uint8Array.from(atob(saltB64), c => c.charCodeAt(0));
                            const derivedKeyForVaultKey = await deriveKeyFromHash(vaultHash, salt);
                            const decryptedVaultKeyRaw = await decryptData(
                                Uint8Array.from(atob(encryptedKeyB64), c => c.charCodeAt(0)),
                                Uint8Array.from(atob(ivB64), c => c.charCodeAt(0)),
                                derivedKeyForVaultKey
                            );
                            vaultAesKey = await importKey(decryptedVaultKeyRaw);

                            vaults.set(vaultId, {
                                id: vaultId,
                                name: vaultName,
                                type: vaultType,
                                expiration: expiration,
                                key: vaultAesKey,
                                messages: []
                            });

                        } else if (vaultType === 'private') {
                            // --- Private Vault Creation Response (Kyber PQC) ---
                            // 1. Retrieve pk_enc and ciphertext sent by the server
                            const { pk_enc_b64, ciphertext_b64 } = data;

                            // 2. Retrieve the secret key (sk_enc) that was generated locally during creation
                            //    It should be available in the temporary state or re-derived if needed.
                            //    For this flow, we assume it was generated just before sending the request.
                            //    Let's retrieve it from a temporary global variable or state.
                            //    We need to make sure the sk_enc generated during form submission is accessible here.
                            //    Let's assume we stored it temporarily before sending the WS message.
                            //    A cleaner way is to manage state better, but for this direct translation:
                            //    We will assume the key generation happened just before and `tempSkEnc` holds it.
                            //    *** IMPORTANT: This requires careful state management in the form submit handler ***
                            //    Let's define `tempSkEnc` globally for this purpose.

                            if (!window.tempSkEnc) {
                                console.error("Kyber secret key (sk_enc) not found for newly created private vault.");
                                showMessageBox('Key Error', 'Failed to retrieve private key for the new vault.');
                                break;
                            }
                            const sk_enc = window.tempSkEnc; // Uint8Array
                            delete window.tempSkEnc; // Clear temporary storage

                            // 3. Perform decapsulation using the locally stored secret key and server-provided ciphertext
                            const pk_enc = new Uint8Array(atob(pk_enc_b64).match(/.{1,2}/g).map(byte => parseInt(byte, 16))); // Hex string to Uint8Array
                            const ciphertext = new Uint8Array(atob(ciphertext_b64).match(/.{1,2}/g).map(byte => parseInt(byte, 16))); // Hex string to Uint8Array

                            let sharedSecret;
                            try {
                                sharedSecret = noble.postQuantum.kyber.decapsulate(ciphertext, sk_enc); // Uint8Array
                            } catch (e) {
                                console.error("Kyber decapsulation failed for created vault:", e);
                                showMessageBox('Decryption Error', 'Failed to derive key for the new private vault.');
                                break;
                            }

                            // 4. Derive the actual AES-GCM key from the shared secret
                            try {
                                vaultAesKey = await deriveAesKeyFromKyberSecret(sharedSecret);
                            } catch (e) {
                                console.error("Failed to derive AES key from Kyber shared secret:", e);
                                showMessageBox('Key Derivation Error', 'Failed to setup encryption for the new private vault.');
                                break;
                            }

                            // 5. Store vault data including the derived AES key and Kyber materials for persistence
                            vaults.set(vaultId, {
                                id: vaultId,
                                name: vaultName,
                                type: vaultType,
                                expiration: expiration,
                                key: vaultAesKey, // The derived AES key
                                sk_enc: sk_enc, // Store for future loads
                                pk_enc_b64: pk_enc_b64, // Store for future loads/verification if needed
                                ciphertext_b64: ciphertext_b64, // Store for future loads
                                messages: []
                            });
                        }

                        if (vaultAesKey) { // Only proceed if key was successfully obtained
                             await saveVaultsToLocalStorage();
                             renderVaultList();
                             document.getElementById('generated-vault-hash').textContent = vaultHash;
                             document.getElementById('create-vault-hash-display').classList.remove('hidden');
                             showMessageBox('Vault Created!', `Your vault "${vaultName}" has been created. Share this hash: ${vaultHash}`, () => {
                                 selectVault(vaultId);
                             });
                        }
                        break;

                    case 'vault_joined':
                        const { joinedVaultId, joinedVaultName, joinedVaultType, joinedExpiration, vaultHash: joinHashUsed } = data;
                        let joinedVaultAesKey = null;

                         if (joinedVaultType === 'public') {
                             // --- Public Vault Join Response (Unchanged) ---
                             const { encryptedKeyB64: joinedEncryptedKeyB64, ivB64: joinedIvB64, saltB64: joinedSaltB64 } = data;
                             const joinSalt = Uint8Array.from(atob(joinedSaltB64), c => c.charCodeAt(0));
                             const derivedKeyForJoinedVaultKey = await deriveKeyFromHash(joinHashUsed, joinSalt);
                             const decryptedJoinedVaultKeyRaw = await decryptData(
                                 Uint8Array.from(atob(joinedEncryptedKeyB64), c => c.charCodeAt(0)),
                                 Uint8Array.from(atob(joinedIvB64), c => c.charCodeAt(0)),
                                 derivedKeyForJoinedVaultKey
                             );
                             joinedVaultAesKey = await importKey(decryptedJoinedVaultKeyRaw);

                             vaults.set(joinedVaultId, {
                                 id: joinedVaultId,
                                 name: joinedVaultName,
                                 type: joinedVaultType,
                                 expiration: joinedExpiration,
                                 key: joinedVaultAesKey,
                                 messages: []
                             });

                         } else if (joinedVaultType === 'private') {
                             // --- Private Vault Join Response (Kyber PQC) ---
                             // 1. Retrieve pk_enc and ciphertext sent by the server
                             const { pk_enc_b64: joinedPkEncB64, ciphertext_b64: joinedCiphertextB64 } = data;

                             // 2. Store pk_enc and ciphertext for this vault (no sk_enc yet for joiner)
                             //    The AES key will be derived when the vault is loaded/selected.

                             vaults.set(joinedVaultId, {
                                 id: joinedVaultId,
                                 name: joinedVaultName,
                                 type: joinedVaultType,
                                 expiration: joinedExpiration,
                                 key: null, // Key will be derived on load
                                 sk_enc: null, // Joiner doesn't have sk_enc initially
                                 pk_enc_b64: joinedPkEncB64,
                                 ciphertext_b64: joinedCiphertextB64,
                                 messages: []
                             });
                             joinedVaultAesKey = null; // Indicate key derivation is deferred
                         }

                         await saveVaultsToLocalStorage();
                         renderVaultList();
                         showMessageBox('Vault Joined!', `You have joined "${joinedVaultName}".`, () => {
                             selectVault(joinedVaultId);
                         });
                        break;

                    case 'new_message':
                        const { vaultId: msgVaultId, senderId, encryptedMessage, iv, timestamp, isFile, fileName, fileMimeType } = data;
                        const vault = vaults.get(msgVaultId);
                        if (vault) {
                            try {
                                const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                                const messageObj = {
                                    sender: senderId,
                                    content: decryptedContent,
                                    timestamp: timestamp,
                                    isFile: isFile,
                                    fileName: fileName,
                                    fileMimeType: fileMimeType
                                };
                                vault.messages.push(messageObj);
                                console.log(`New message for vault ${msgVaultId}:`, messageObj);
                                await saveVaultsToLocalStorage();
                                if (activeVaultId === msgVaultId) {
                                    displayMessage(messageObj);
                                }
                            } catch (e) {
                                console.error("Failed to decrypt incoming message:", e);
                                const messageObj = {
                                    sender: senderId,
                                    content: "[Could not decrypt message]",
                                    timestamp: timestamp,
                                    isFile: false
                                };
                                vault.messages.push(messageObj);
                                await saveVaultsToLocalStorage();
                                if (activeVaultId === msgVaultId) {
                                    displayMessage(messageObj);
                                }
                            }
                        } else {
                            console.warn(`Received message for unknown vault ID: ${msgVaultId}. Message:`, data);
                        }
                        break;

                    case 'offline_messages':
                        console.log(`Received ${data.messages.length} offline messages.`);
                        for (const msg of data.messages) {
                            const { vaultId: msgVaultId, senderId, encryptedMessage, iv, timestamp, isFile, fileName, fileMimeType } = msg;
                            const vault = vaults.get(msgVaultId);
                            if (vault) {
                                try {
                                    const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                                    const messageObj = {
                                        sender: senderId,
                                        content: decryptedContent,
                                        timestamp: timestamp,
                                        isFile: isFile,
                                        fileName: fileName,
                                        fileMimeType: fileMimeType
                                    };
                                    vault.messages.push(messageObj);
                                    console.log(`Processed offline message for vault ${msgVaultId}:`, messageObj);
                                } catch (e) {
                                    console.error("Failed to decrypt offline message:", e);
                                    vault.messages.push({
                                        sender: senderId,
                                        content: "[Decryption Failed]",
                                        timestamp: timestamp,
                                        isFile: false
                                    });
                                }
                            } else {
                                console.warn(`Received offline message for unknown vault ID: ${msgVaultId}. Message:`, msg);
                            }
                        }
                        await saveVaultsToLocalStorage();
                        if (activeVaultId && vaults.has(activeVaultId)) {
                            renderChatMessages(activeVaultId);
                        }
                        break;

                    case 'error':
                        showMessageBox('Error', data.message);
                        break;

                    case 'vault_expired_notification':
                         const { expiredVaultId, expiredVaultName } = data;
                         if (vaults.has(expiredVaultId)) {
                              vaults.delete(expiredVaultId);
                              await saveVaultsToLocalStorage();
                              renderVaultList();
                              if (activeVaultId === expiredVaultId) {
                                  activeVaultId = null;
                                  document.getElementById('chat-window').classList.add('hidden');
                                  document.getElementById('chat-input-area').classList.add('hidden');
                                  document.getElementById('no-vault-selected').classList.remove('hidden');
                              }
                              showMessageBox('Vault Expired', `The vault "${expiredVaultName}" has expired and all its data has been wiped.`);
                         } else {
                             console.log(`Received expiration for unknown or already removed vault: ${expiredVaultName} (${expiredVaultId})`);
                         }
                        break;
                }
            };
            ws.onclose = () => {
                console.log('WebSocket disconnected. Attempting to reconnect in 5 seconds...');
                setTimeout(initWebSocket, 5000);
            };
            ws.onerror = (event) => {
                console.error('WebSocket error event:', event);
                showMessageBox('Connection Error',
                    `Could not connect to the server at ${SERVER_URL}. ` +
                    `Please ensure:
                    1. The Node.js server is running.
                    2. The SERVER_URL in index.html is correct.
                    3. If deployed (e.g., to Render), use 'wss://' for the SERVER_URL.`);
            };
        }

        function sendMessageToServer(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                showMessageBox('Connection Error', 'Not connected to server. Please wait or refresh.');
                console.warn("Attempted to send message while WebSocket is not open.", message);
            }
        }

        // --- Local Storage Management ---
        async function saveVaultsToLocalStorage() {
            console.log("Saving vaults to localStorage...");
            const serializableVaults = [];
            for (const [id, vault] of vaults.entries()) {
                try {
                    let keyData = null;
                    let sk_enc_b64 = null;
                    if (vault.key) {
                        const exportedKey = await exportKey(vault.key);
                        keyData = btoa(String.fromCharCode(...new Uint8Array(exportedKey)));
                    }
                    if (vault.sk_enc) {
                         sk_enc_b64 = btoa(String.fromCharCode(...vault.sk_enc)); // Uint8Array to Base64
                    }
                    serializableVaults.push({
                        id: vault.id,
                        name: vault.name,
                        type: vault.type,
                        expiration: vault.expiration,
                        key: keyData, // Base64 encoded AES key or null
                        sk_enc_b64: sk_enc_b64, // Base64 encoded Kyber sk or null
                        pk_enc_b64: vault.pk_enc_b64 || null, // Base64 encoded Kyber pk or null
                        ciphertext_b64: vault.ciphertext_b64 || null, // Base64 encoded Kyber ciphertext or null
                        messages: vault.messages || []
                    });
                } catch (e) {
                    console.error(`Failed to export key for vault ${id}:`, e);
                }
            }
            try {
                localStorage.setItem('thePlatformVaults', JSON.stringify(serializableVaults));
                console.log("Vaults successfully saved to localStorage.");
            } catch (e) {
                console.error("Error saving vaults to localStorage:", e);
                showMessageBox('Storage Error', 'Could not save data to local storage. Your browser might be full or private browsing is enabled.');
            }
        }

        async function loadVaultsFromLocalStorage() {
            console.log("Loading vaults from localStorage...");
            const storedVaults = localStorage.getItem('thePlatformVaults');
            vaults.clear();
            if (storedVaults) {
                try {
                    const parsedVaults = JSON.parse(storedVaults);
                    for (const serializedVault of parsedVaults) {
                        try {
                            let importedKey = null;
                            let sk_enc = null;
                            // Import AES key if present
                            if (serializedVault.key) {
                                importedKey = await importKey(Uint8Array.from(atob(serializedVault.key), c => c.charCodeAt(0)));
                            }
                            // Import Kyber sk_enc if present
                            if (serializedVault.sk_enc_b64) {
                                sk_enc = new Uint8Array(atob(serializedVault.sk_enc_b64).split('').map(c => c.charCodeAt(0)));
                            }

                            // Handle deferred key derivation for private vaults loaded from storage
                            if (serializedVault.type === 'private' && !importedKey && sk_enc && serializedVault.ciphertext_b64) {
                                console.log(`Deriving key for private vault ${serializedVault.id} on load...`);
                                const ciphertext = new Uint8Array(atob(serializedVault.ciphertext_b64).split('').map(c => c.charCodeAt(0)));
                                let sharedSecret;
                                try {
                                     sharedSecret = noble.postQuantum.kyber.decapsulate(ciphertext, sk_enc);
                                } catch (e) {
                                    console.error(`Kyber decapsulation failed for loaded private vault ${serializedVault.id}:`, e);
                                    showMessageBox('Key Error', `Failed to load key for private vault "${serializedVault.name}". It might be corrupted.`);
                                    // Add vault without key? Or skip? Let's skip for security.
                                    continue;
                                }
                                try {
                                     importedKey = await deriveAesKeyFromKyberSecret(sharedSecret);
                                } catch (e) {
                                     console.error(`Failed to derive AES key for loaded private vault ${serializedVault.id}:`, e);
                                     showMessageBox('Key Derivation Error', `Failed to setup encryption for private vault "${serializedVault.name}".`);
                                     continue; // Skip this vault
                                }
                            }

                            vaults.set(serializedVault.id, {
                                id: serializedVault.id,
                                name: serializedVault.name,
                                type: serializedVault.type,
                                expiration: serializedVault.expiration,
                                key: importedKey, // Could be null if key derivation failed or deferred and not possible
                                sk_enc: sk_enc, // Uint8Array or null
                                pk_enc_b64: serializedVault.pk_enc_b64 || null,
                                ciphertext_b64: serializedVault.ciphertext_b64 || null,
                                messages: serializedVault.messages || []
                            });
                            console.log(`Loaded vault: ${serializedVault.name} (${serializedVault.id})`);
                        } catch (e) {
                            console.error(`Failed to load vault ${serializedVault.id} from localStorage:`, e);
                        }
                    }
                    console.log(`Finished loading ${vaults.size} vaults from localStorage.`);
                    renderVaultList();
                    if (vaults.size > 0) {
                        const lastActiveVaultId = localStorage.getItem('lastActiveVaultId');
                        if (lastActiveVaultId && vaults.has(lastActiveVaultId)) {
                            selectVault(lastActiveVaultId);
                        } else {
                            selectVault(vaults.keys().next().value);
                        }
                    } else {
                        console.log("No vaults found in localStorage.");
                        document.getElementById('no-vault-selected').classList.remove('hidden');
                        document.getElementById('chat-window').classList.add('hidden');
                        document.getElementById('chat-input-area').classList.add('hidden');
                    }
                } catch (e) {
                    console.error("Error parsing vaults from localStorage:", e);
                    showMessageBox('Data Corruption', 'Local vault data is corrupted. Clearing data and starting fresh.');
                    localStorage.removeItem('thePlatformVaults');
                    renderVaultList();
                }
            } else {
                console.log("No vaults found in localStorage initially.");
            }
        }

        function nukeAllData() {
            showMessageBox('Confirm Nuke', 'Are you sure you want to wipe ALL your local data and disconnect? This action cannot be undone. This will also attempt to clear your data on the server.', async () => {
                localStorage.removeItem('thePlatformVaults');
                localStorage.removeItem('thePlatformUserId');
                localStorage.removeItem('lastActiveVaultId');
                vaults.clear();
                activeVaultId = null;
                document.getElementById('chat-window').innerHTML = '';
                document.getElementById('vault-list').innerHTML = '';
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('current-user-id').textContent = 'Nuked! Reopen for new ID.';
                sendMessageToServer({ type: 'nuke', userId: userId });
                document.body.innerHTML = `
                    <div class="flex flex-col items-center justify-center min-h-screen bg-gray-100 text-gray-700">
                        <h1 class="text-4xl font-bold mb-4">Data Nuked!</h1>
                        <p class="text-lg">All your local data has been wiped.</p>
                        <p class="text-lg">To start fresh, please reopen "The Platform".</p>
                    </div>
                `;
            });
        }

        // --- UI Rendering ---
        function renderVaultList() {
            const vaultListDiv = document.getElementById('vault-list');
            vaultListDiv.innerHTML = '';
            if (vaults.size === 0) {
                vaultListDiv.innerHTML = '<p class="text-center text-gray-500 text-sm mt-4">No vaults yet. Create or join one!</p>';
            }
            vaults.forEach(vault => {
                const vaultItem = document.createElement('div');
                vaultItem.className = `vault-item ${activeVaultId === vault.id ? 'active' : ''}`;
                vaultItem.dataset.vaultId = vault.id;
                vaultItem.innerHTML = `
                    <span>${vault.name} (${vault.type === 'private' ? 'DM' : 'Group'})</span>
                    <span class="text-xs text-gray-500">${vault.expiration === 'never' ? 'Never Exp.' : `Exp: ${vault.expiration}`}</span>
                `;
                vaultItem.addEventListener('click', () => selectVault(vault.id));
                vaultListDiv.appendChild(vaultItem);
            });
        }

        function displayMessage(message) {
            const chatWindow = document.getElementById('chat-window');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.sender === userId ? 'self' : 'other'}`;
            const senderSpan = document.createElement('div');
            senderSpan.className = 'message-sender';
            senderSpan.textContent = message.sender === userId ? 'You' : `User: ${message.sender.substring(0, 8)}...`;
            messageDiv.appendChild(senderSpan);
            if (message.isFile) {
                const fileLink = document.createElement('div');
                fileLink.className = 'message-file';
                fileLink.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path d="M19.5 7.5c-1.25 0-2.5.31-3.57.88-.85.45-1.48 1.12-1.87 1.94-.17.36-.31.75-.41 1.15a.75.75 0 0 1-1.09-.72c.16-.49.37-.96.6-1.42.34-.67.79-1.28 1.34-1.83 1.04-1.04 2.39-1.66 3.86-1.8.02-.01.04-.02.06-.02a.75.75 0 0 1 .78 1.25c-.06.05-.12.09-.18.14-.8.6-1.25 1.4-1.25 2.25v.75h.75c.85 0 1.65-.45 2.25-1.25.05-.06.09-.12.14-.18a.75.75 0 0 1 1.25.78c-.01.02-.02.04-.02.06-.14 1.47-.76 2.82-1.8 3.86-1.04 1.04-2.39 1.66-3.86 1.8-.02.01-.04.02-.06.02a.75.75 0 0 1-.78-1.25c.06-.05.12-.09.18-.14.8-.6 1.25-1.4 1.25-2.25V7.5h-.75Zm-10.5 0c-1.25 0-2.5.31-3.57.88-.85.45-1.48 1.12-1.87 1.94-.17.36-.31.75-.41 1.15a.75.75 0 0 1-1.09-.72c.16-.49.37-.96.6-1.42.34-.67.79-1.28 1.34-1.83 1.04-1.04 2.39-1.66 3.86-1.8.02-.01.04-.02.06-.02a.75.75 0 0 1 .78 1.25c-.06.05-.12.09-.18.14-.8.6-1.25 1.4-1.25 2.25v.75h.75c.85 0 1.65-.45 2.25-1.25.05-.06.09-.12.14-.18a.75.75 0 0 1 1.25.78c-.01.02-.02.04-.02.06-.14 1.47-.76 2.82-1.8 3.86-1.04 1.04-2.39 1.66-3.86 1.8-.02.01-.04.02-.06.02a.75.75 0 0 1-.78-1.25c.06-.05.12-.09.18-.14.8-.6 1.25-1.4 1.25-2.25V7.5h-.75Z" />
                    </svg>
                    <span>${message.fileName || 'File'}</span>
                `;
                fileLink.addEventListener('click', () => downloadFile(message.content, message.fileName, message.fileMimeType));
                messageDiv.appendChild(fileLink);
            } else {
                const contentSpan = document.createElement('div');
                contentSpan.className = 'message-content';
                contentSpan.textContent = message.content;
                messageDiv.appendChild(contentSpan);
            }
            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = new Date(message.timestamp).toLocaleTimeString();
            messageDiv.appendChild(timestampSpan);
            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function renderChatMessages(vaultId) {
            const chatWindow = document.getElementById('chat-window');
            chatWindow.innerHTML = '';
            const vault = vaults.get(vaultId);
            if (vault && vault.messages) {
                vault.messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                vault.messages.forEach(msg => displayMessage(msg));
            }
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        async function selectVault(vaultId) {
            if (!vaults.has(vaultId)) {
                console.warn(`Attempted to select non-existent vault: ${vaultId}`);
                showMessageBox('Vault Not Found', 'This vault no longer exists locally. It might have expired or been removed.');
                activeVaultId = null;
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                renderVaultList();
                return;
            }
            const vault = vaults.get(vaultId);

            // --- Handle deferred key derivation for joined private vaults ---
            if (vault.type === 'private' && !vault.key && vault.sk_enc && vault.ciphertext_b64) {
                 console.log(`Deriving key for private vault ${vaultId} on selection...`);
                 const ciphertext = new Uint8Array(atob(vault.ciphertext_b64).split('').map(c => c.charCodeAt(0)));
                 let sharedSecret;
                 try {
                      sharedSecret = noble.postQuantum.kyber.decapsulate(ciphertext, vault.sk_enc);
                 } catch (e) {
                      console.error(`Kyber decapsulation failed for selected private vault ${vaultId}:`, e);
                      showMessageBox('Key Error', `Failed to load key for private vault "${vault.name}".`);
                      return; // Don't select the vault if key can't be derived
                 }
                 try {
                      vault.key = await deriveAesKeyFromKyberSecret(sharedSecret); // Update vault object with derived key
                      await saveVaultsToLocalStorage(); // Save the now-derived key
                 } catch (e) {
                      console.error(`Failed to derive AES key for selected private vault ${vaultId}:`, e);
                      showMessageBox('Key Derivation Error', `Failed to setup encryption for private vault "${vault.name}".`);
                      return;
                 }
            }

            // --- Check if key is available (for security) ---
            if (!vault.key) {
                 showMessageBox('Key Unavailable', `Cannot access vault "${vault.name}". The encryption key is missing or could not be derived.`);
                 console.error(`Attempted to select vault ${vaultId} but key is null.`);
                 return;
            }

            activeVaultId = vaultId;
            localStorage.setItem('lastActiveVaultId', vaultId);
            renderVaultList();
            document.getElementById('no-vault-selected').classList.add('hidden');
            document.getElementById('chat-window').classList.remove('hidden');
            document.getElementById('chat-input-area').classList.remove('hidden');
            renderChatMessages(vaultId);
            document.getElementById('message-input').focus();
            console.log(`Selected vault: ${vault.name} (${vaultId})`);
        }

        // --- Event Listeners and Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            userId = localStorage.getItem('thePlatformUserId');
            if (!userId) {
                userId = crypto.randomUUID();
                localStorage.setItem('thePlatformUserId', userId);
                console.log(`Generated new user ID: ${userId}`);
            } else {
                console.log(`Loaded existing user ID: ${userId}`);
            }
            document.getElementById('current-user-id').textContent = userId;
            initWebSocket();

            const createVaultModal = document.getElementById('create-vault-modal');
            const joinVaultModal = document.getElementById('join-vault-modal');
            const createVaultBtn = document.getElementById('create-vault-btn');
            const joinVaultBtn = document.getElementById('join-vault-btn');
            const createVaultClose = document.getElementById('create-vault-close');
            const joinVaultClose = document.getElementById('join-vault-close');

            createVaultBtn.addEventListener('click', () => {
                createVaultModal.classList.add('show');
                document.getElementById('create-vault-hash-display').classList.add('hidden');
                document.getElementById('create-vault-form').reset();
            });
            joinVaultBtn.addEventListener('click', () => {
                joinVaultModal.classList.add('show');
                document.getElementById('join-vault-form').reset();
            });
            createVaultClose.addEventListener('click', () => createVaultModal.classList.remove('show'));
            joinVaultClose.addEventListener('click', () => joinVaultModal.classList.remove('show'));

            // Create Vault Form Submission (Modified for Kyber)
            document.getElementById('create-vault-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const vaultName = document.getElementById('vault-name').value;
                const vaultType = document.getElementById('vault-type').value;
                const expirationTime = document.getElementById('expiration-time').value;

                const vaultAesKey = await generateAesKey();
                const rawVaultAesKey = await exportKey(vaultAesKey);

                if (vaultType === 'public') {
                    // --- Public Vault Creation (Unchanged) ---
                    const salt = crypto.getRandomValues(new Uint8Array(16));
                    sendMessageToServer({
                        type: 'create_vault',
                        userId: userId,
                        vaultName: vaultName,
                        vaultType: vaultType,
                        expiration: expirationTime,
                        rawVaultKeyB64: btoa(String.fromCharCode(...new Uint8Array(rawVaultAesKey))),
                        saltB64: btoa(String.fromCharCode(...salt))
                    });

                } else if (vaultType === 'private') {
                    // --- Private Vault Creation (Kyber PQC) ---
                    // 1. Validate key size (must be 32 bytes for Kyber768 seed)
                    if (rawVaultAesKey.byteLength !== 32) {
                         showMessageBox('Key Error', 'Internal error: Generated key size is incorrect for private vault.');
                         console.error("Generated AES key for private vault is not 32 bytes:", rawVaultAesKey.byteLength);
                         return;
                    }

                    // 2. Generate Kyber768 keypair using the raw AES key as the seed
                    const seed = new Uint8Array(rawVaultAesKey); // 32-byte seed
                    let keypair;
                    try {
                         keypair = noble.postQuantum.kyber.keygen(seed);
                    } catch (err) {
                         console.error("Kyber key generation failed:", err);
                         showMessageBox('Key Generation Error', 'Failed to generate post-quantum keys for the private vault.');
                         return;
                    }
                    const { publicKey: pk_enc, secretKey: sk_enc } = keypair;

                    // 3. Store the secret key temporarily for use in the vault_created handler
                    window.tempSkEnc = sk_enc; // Uint8Array

                    // 4. Send request to server with pk_enc (as raw key placeholder) and other details
                    //    The server will perform encapsulation and store pk_enc/ciphertext.
                    sendMessageToServer({
                        type: 'create_vault',
                        userId: userId,
                        vaultName: vaultName,
                        vaultType: vaultType,
                        expiration: expirationTime,
                        // Send pk_enc to server (server needs it to store)
                        rawVaultKeyB64: btoa(String.fromCharCode(...pk_enc)), // Placeholder, server uses this as pk_enc
                        // No salt needed for private vault creation anymore
                    });
                }
                // The vault_created message from server will handle adding to local vaults and UI update
            });

            document.getElementById('copy-hash-btn').addEventListener('click', () => {
                const hash = document.getElementById('generated-vault-hash').textContent;
                if (hash) {
                    copyToClipboard(hash);
                }
            });

            document.getElementById('join-vault-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const joinVaultHash = document.getElementById('join-vault-hash').value;
                const joinVaultName = document.getElementById('join-vault-name').value;
                sendMessageToServer({
                    type: 'join_vault',
                    userId: userId,
                    vaultHash: joinVaultHash,
                    vaultName: joinVaultName
                });
                joinVaultModal.classList.remove('show');
            });

            document.getElementById('send-message-btn').addEventListener('click', async () => {
                const messageInput = document.getElementById('message-input');
                const fileInput = document.getElementById('file-input');
                const messageText = messageInput.value.trim();
                const file = fileInput.files[0];

                if (!activeVaultId) {
                    showMessageBox('No Vault Selected', 'Please select a vault to send messages.');
                    return;
                }
                if (!messageText && !file) {
                    return;
                }
                const vault = vaults.get(activeVaultId);
                if (!vault) {
                    showMessageBox('Error', 'Active vault not found. Please re-select or refresh.');
                    console.error("Attempted to send message to a non-existent active vault.");
                    return;
                }
                if (!vault.key) { // Extra check for key presence
                     showMessageBox('Error', 'Vault encryption key is not available.');
                     console.error("Attempted to send message to a vault without an available key.");
                     return;
                }

                let encryptedContent;
                let ivB64;
                let isFile = false;
                let fileName = null;
                let fileMimeType = null;

                const localMessageObj = {
                    sender: userId,
                    timestamp: new Date().toISOString(),
                };

                if (file) {
                    try {
                        const base64File = await fileToBase64(file);
                        const { encryptedMessage, iv } = await encryptMessage(base64File, vault.key);
                        encryptedContent = encryptedMessage;
                        ivB64 = iv;
                        isFile = true;
                        fileName = file.name;
                        fileMimeType = file.type;
                        messageInput.value = '';
                        fileInput.value = '';
                        localMessageObj.content = base64File;
                        localMessageObj.isFile = true;
                        localMessageObj.fileName = fileName;
                        localMessageObj.fileMimeType = fileMimeType;
                    } catch (error) {
                        console.error("Error encrypting file:", error);
                        showMessageBox('Encryption Error', 'Failed to encrypt file. Please try again.');
                        return;
                    }
                } else {
                    try {
                        const { encryptedMessage, iv } = await encryptMessage(messageText, vault.key);
                        encryptedContent = encryptedMessage;
                        ivB64 = iv;
                        messageInput.value = '';
                        localMessageObj.content = messageText;
                        localMessageObj.isFile = false;
                    } catch (error) {
                        console.error("Error encrypting message:", error);
                        showMessageBox('Encryption Error', 'Failed to encrypt message. Please try again.');
                        return;
                    }
                }

                vault.messages.push(localMessageObj);
                displayMessage(localMessageObj);
                await saveVaultsToLocalStorage();

                sendMessageToServer({
                    type: 'send_message',
                    vaultId: activeVaultId,
                    senderId: userId,
                    encryptedMessage: encryptedContent,
                    iv: ivB64,
                    timestamp: localMessageObj.timestamp,
                    isFile: isFile,
                    fileName: fileName,
                    fileMimeType: fileMimeType
                });
            });

            document.getElementById('attach-file-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            document.getElementById('nuke-btn').addEventListener('click', nukeAllData);

            document.getElementById('message-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('send-message-btn').click();
                }
            });
        });
    </script>
</body>
</html>
