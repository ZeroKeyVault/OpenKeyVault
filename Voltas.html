<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Platform</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0; /* Light grey background */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }
        .container {
            background-color: #ffffff; /* White background for the main app */
            border-radius: 1rem; /* Rounded corners for the container */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            width: 95%;
            margin: 1.5rem auto;
            overflow: hidden;
        }
        .header {
            background-color: #f9f9f9; /* Slightly off-white for header */
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            text-align: center;
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
        }
        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            background-color: #f5f5f5; /* Light grey for sidebar */
            border-right: 1px solid #e0e0e0;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }
        .vault-list {
            flex-grow: 1;
            overflow-y: auto;
        }
        .vault-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #e0e0e0;
        }
        .vault-item:hover {
            background-color: #f0f0f0;
        }
        .vault-item.active {
            background-color: #e0e0e0;
            font-weight: 600;
        }
        .chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            overflow: hidden; /* Ensure this doesn't create extra scrollbars */
        }
        .messages-display {
            flex-grow: 1;
            background-color: #f9f9f9;
            border-radius: 0.75rem;
            padding: 1rem;
            overflow-y: auto; /* Make messages scrollable */
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
        }
        .message {
            margin-bottom: 0.75rem;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            /* Adjusted max-width for better responsiveness */
            max-width: calc(100% - 4rem); /* Allows some margin/padding */
            word-wrap: break-word; /* Ensures long words break */
        }
        .message.self {
            background-color: #e0e0e0; /* Light grey for self messages */
            margin-left: auto; /* Aligns to the right */
            text-align: right;
        }
        .message.other {
            background-color: #f0f0f0; /* Even lighter grey for other messages */
            margin-right: auto; /* Aligns to the left */
            text-align: left;
        }
        .message-sender {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }
        .message-content {
            font-size: 1rem;
            color: #333;
        }
        .message-timestamp {
            font-size: 0.7rem;
            color: #999;
            margin-top: 0.5rem;
            display: block;
        }
        .input-area {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .input-area input[type="text"] {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
            outline: none;
        }
        .input-area button {
            padding: 0.75rem 1.5rem;
            background-color: #888; /* Grey for buttons */
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .input-area button:hover {
            background-color: #666;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.show {
            visibility: visible;
            opacity: 1;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            position: relative;
        }
        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
            color: #888;
        }
        .modal-content h2 {
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #333;
            text-align: center;
        }
        .modal-content label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #555;
        }
        .modal-content input,
        .modal-content select {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            border-radius: 0.75rem;
            font-size: 1rem;
        }
        .modal-content button {
            width: 100%;
            padding: 0.75rem;
            background-color: #888;
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            font-size: 1.1rem;
            transition: background-color 0.2s ease;
        }
        .modal-content button:hover {
            background-color: #666;
        }
        .footer {
            text-align: center;
            padding: 1rem;
            color: #666;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        .message-file {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #e0e0e0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
        }
        .message-file svg {
            width: 1.25rem;
            height: 1.25rem;
            fill: #555;
        }
        .message-file span {
            color: #333;
            font-weight: 500;
        }
        .nuke-button {
            background-color: #f44336; /* Red for Nuke button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            margin-top: auto; /* Pushes it to the bottom of the sidebar */
        }
        .nuke-button:hover {
            background-color: #d32f2f;
        }
        .info-message {
            background-color: #fff3cd;
            color: #664d03;
            padding: 0.75rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ffecb3;
            text-align: center;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
                padding-bottom: 0;
            }
            .chat-area {
                padding-top: 0;
            }
            .vault-list {
                max-height: 200px; /* Limit height of vault list on small screens */
            }
            .header {
                font-size: 2rem;
                padding: 1rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            /* Adjust message max-width on very small screens if needed */
            .message {
                max-width: calc(100% - 2rem); /* More room for padding/margin on very small screens */
            }
            .message.self, .message.other {
                margin-left: 0; /* Remove auto margins to simplify */
                margin-right: 0;
                width: 100%; /* Take full width */
            }
            .message.self {
                text-align: right; /* Keep text alignment */
                background-color: #e0e0e0;
            }
            .message.other {
                text-align: left; /* Keep text alignment */
                background-color: #f0f0f0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">The Platform</div>
        <div class="main-content">
            <div class="sidebar">
                <div class="info-message" id="user-id-display">
                    Your ID: <span id="current-user-id">Generating...</span>
                </div>
                <button id="create-vault-btn" class="input-area button">Create Vault</button>
                <button id="join-vault-btn" class="input-area button">Join Vault</button>

                <div class="vault-list" id="vault-list">
                    <!-- Vault items will be injected here -->
                </div>

                <button id="nuke-btn" class="nuke-button">Nuke All Data</button>
            </div>

            <div class="chat-area">
                <div id="no-vault-selected" class="info-message text-center p-4 rounded-lg bg-gray-100 text-gray-700">
                    Select a vault to start chatting or create/join a new one.
                </div>
                <div id="chat-window" class="messages-display hidden">
                    <!-- Messages will be injected here -->
                </div>
                <div id="chat-input-area" class="input-area hidden">
                    <input type="text" id="message-input" placeholder="Type your message...">
                    <input type="file" id="file-input" class="hidden" accept="*/*">
                    <button id="attach-file-btn" title="Attach File">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                            <path fill-rule="evenodd" d="M18.97 3.659A2.25 2.25 0 0 0 17.023 2.25h-13.5A2.25 2.25 0 0 0 1.25 4.5v11.25c0 1.036.724 1.897 1.702 2.131a.75.75 0 0 0 .584.076l7.497-1.5a.75.75 0 0 0 .427-.715V6.25a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 .75.75v6.19l1.777.355a.75.75 0 0 0 .584-.076c.978-.234 1.702-1.095 1.702-2.131V4.5A2.25 2.25 0 0 0 18.97 3.659ZM12 15.75h.007v.008H12v-.008ZM10.5 6a.75.75 0 0 0-.75.75v4.5a.75.75 0 0 0 .75.75h.75a.75.75 0 0 0 .75-.75v-4.5a.75.75 0 0 0-.75-.75h-.75Z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button id="send-message-btn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Vault Modal -->
    <div id="create-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="create-vault-close">&times;</span>
            <h2>Create New Vault</h2>
            <form id="create-vault-form">
                <label for="vault-name">Vault Name:</label>
                <input type="text" id="vault-name" placeholder="e.g., Family Chat, Project X" required>

                <label for="vault-type">Vault Type:</label>
                <select id="vault-type" required>
                    <option value="private">Private (Direct Message)</option>
                    <option value="public">Public (Group)</option>
                </select>

                <label for="expiration-time">Expiration Time:</label>
                <select id="expiration-time" required>
                    <option value="1h">1 Hour</option>
                    <option value="5h">5 Hours</option>
                    <option value="24h">24 Hours</option>
                    <option value="1mo">1 Month</option>
                    <option value="3mo">3 Months</option>
                    <option value="6mo">6 Months</option>
                    <option value="1yr">1 Year</option>
                    <option value="never">Never</option>
                </select>

                <button type="submit">Create Vault</button>
                <div id="create-vault-hash-display" class="info-message mt-4 hidden">
                    Vault Hash: <span id="generated-vault-hash" class="font-mono break-all"></span><br>
                    <!-- FIX: Added type="button" to prevent accidental form submission -->
                    <button id="copy-hash-btn" type="button" class="mt-2 w-auto px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm">Copy Hash</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Join Vault Modal -->
    <div id="join-vault-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="join-vault-close">&times;</span>
            <h2>Join Existing Vault</h2>
            <form id="join-vault-form">
                <label for="join-vault-hash">Vault Hash:</label>
                <input type="text" id="join-vault-hash" placeholder="Enter vault hash" required>

                <label for="join-vault-name">Name for this Vault (for your reference):</label>
                <input type="text" id="join-vault-name" placeholder="e.g., John's Chat, Dev Team" required>

                <button type="submit">Join Vault</button>
            </form>
        </div>
    </div>

    <!-- Message Box for alerts -->
    <div id="message-box" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="message-box-close">&times;</span>
            <h2 id="message-box-title"></h2>
            <p id="message-box-content" class="text-center mb-4"></p>
            <button id="message-box-ok">OK</button>
        </div>
    </div>

    <footer class="footer">
        <!-- New Footer Text -->
        <p>Encrypted by The Laughing Buddha Protocol</p>
        <p>a Prakhar Solanki creation</p>
        <p>&copy;2025-The Platform.</p>
    </footer>

    <script>
        // Global variables for WebSocket and user ID
        let ws;
        let userId;
        let activeVaultId = null;
        const vaults = new Map(); // Stores vaultId -> { name, type, key, iv, messages: [], participants: [] }
        // IMPORTANT: Update this to your Render WebSocket URL
        // Example: 'wss://your-app-name.onrender.com'
        const SERVER_URL = 'wss://server-618i.onrender.com'; // **UPDATE THIS LINE WITH YOUR RENDER URL**

        // For large file transfers:
        const CHUNK_SIZE = 64 * 1024; // 64 KB chunks
        // Stores fileId -> { fileName, fileMimeType, totalChunks, iv, senderId, timestamp, receivedChunks: Map<chunkIndex, encryptedChunk>, placeholderMessageElement }
        const incomingFileChunks = new Map(); 

        // For Peer-to-Peer (WebRTC)
        const STUN_SERVERS = [
            'stun:stun.l.google.com:19302',
            'stun:stun1.l.google.com:19302',
            'stun:stun2.l.google.com:19302',
            'stun:stun3.l.google.com:19302',
            'stun:stun4.l.google.com:19302'
        ];
        const peerConnections = new Map(); // userId -> RTCPeerConnection
        const dataChannels = new Map();    // userId -> RTCDataChannel
        const pendingIceCandidates = new Map(); // userId -> [] of candidates
        const pendingOffers = new Map();    // userId -> offer (for when PC not ready)


        // --- Utility Functions ---

        /**
         * Displays a custom message box instead of alert().
         * @param {string} title - The title of the message box.
         * @param {string} message - The content message.
         * @param {function} onOk - Callback function when OK is clicked.
         */
        function showMessageBox(title, message, onOk = () => {}) {
            const msgBox = document.getElementById('message-box');
            document.getElementById('message-box-title').textContent = title;
            document.getElementById('message-box-content').textContent = message;
            msgBox.classList.add('show');

            const okBtn = document.getElementById('message-box-ok');
            const closeBtn = document.getElementById('message-box-close');

            const closeMessageBox = () => {
                msgBox.classList.remove('show');
                okBtn.removeEventListener('click', okHandler);
                closeBtn.removeEventListener('click', closeHandler);
                onOk();
            };

            const okHandler = () => closeMessageBox();
            const closeHandler = () => closeMessageBox();

            okBtn.addEventListener('click', okHandler);
            closeBtn.addEventListener('click', closeHandler);
        }

        /**
         * Copies text to the clipboard.
         * @param {string} text - The text to copy.
         */
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showMessageBox('Copied!', 'Vault hash copied to clipboard.');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessageBox('Error', 'Failed to copy hash. Please copy manually: ' + text);
            }
            document.body.removeChild(textarea);
        }

        /**
         * Converts a File object to a Base64 string (Data URL).
         * @param {File} file - The file to convert.
         * @returns {Promise<string>} A promise that resolves with the Base64 string (Data URL).
         */
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result); // e.g., "data:image/png;base64,iVBORw..."
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        /**
         * Converts a Base64 string back to a Blob.
         * @param {string} base64 - The Base64 string.
         * @param {string} mimeType - The MIME type of the original file.
         * @returns {Blob} The Blob object.
         */
        function base64ToBlob(base64, mimeType) {
            // Ensure base64 string does not contain the data URL prefix
            const cleanBase64 = base64.startsWith('data:') ? base64.split(',')[1] : base64;
            const byteString = atob(cleanBase64);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            return new Blob([ab], { type: mimeType });
        }

        /**
         * Downloads a file from Base64 data.
         * @param {string} base64Data - The Base64 encoded file data (full Data URL).
         * @param {string} filename - The name of the file to download.
         * @param {string} mimeType - The MIME type of the file.
         */
        function downloadFile(base64Data, filename, mimeType) {
            const blob = base64ToBlob(base64Data, mimeType); // base64ToBlob now handles prefix
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- Cryptography (The Laughing Buddha Protocol) ---

        /**
         * Generates a random AES-GCM key.
         * @returns {Promise<CryptoKey>} The generated key.
         */
        async function generateAesKey() {
            return crypto.subtle.generateKey(
                { name: "AES-GCM", length: 256 },
                true, // extractable
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Derives a cryptographic key from a given password (hash) using PBKDF2.
         * This is used to encrypt/decrypt the vault's main AES key.
         * @param {string} password - The vault hash (password).
         * @param {Uint8Array} salt - A unique salt for key derivation.
         * @returns {Promise<CryptoKey>} The derived key.
         */
        async function deriveKeyFromHash(password, salt) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                { name: "PBKDF2" },
                false,
                ["deriveBits", "deriveKey"]
            );
            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000, // High iterations for security
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true, // extractable
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Encrypts data using AES-GCM.
         * @param {ArrayBuffer} data - The data to encrypt.
         * @param {CryptoKey} key - The AES-GCM key.
         * @returns {Promise<{encryptedData: ArrayBuffer, iv: Uint8Array}>} Encrypted data and IV.
         */
        async function encryptData(data, key) {
            const iv = crypto.getRandomValues(new Uint8Array(16)); // 96-bit IV recommended for AES-GCM
            const encryptedData = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                data
            );
            return { encryptedData, iv };
        }

        /**
         * Decrypts data using AES-GCM.
         * @param {ArrayBuffer} encryptedData - The encrypted data.
         * @param {Uint8Array} iv - The IV used for encryption.
         * @param {CryptoKey} key - The AES-GCM key.
         * @returns {Promise<ArrayBuffer>} The decrypted data.
         */
        async function decryptData(encryptedData, iv, key) {
            try {
                return await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encryptedData
                );
            } catch (e) {
                console.error("Decryption failed:", e);
                throw new Error("Decryption failed. Key or data might be corrupted.");
            }
        }

        /**
         * Exports a CryptoKey to a raw ArrayBuffer.
         * @param {CryptoKey} key - The key to export.
         * @returns {Promise<ArrayBuffer>} The raw key data.
         */
        async function exportKey(key) {
            return crypto.subtle.exportKey("raw", key);
        }

        /**
         * Imports a raw ArrayBuffer into a CryptoKey.
         * @param {ArrayBuffer} rawKey - The raw key data.
         * @returns {Promise<CryptoKey>} The imported key.
         */
        async function importKey(rawKey) {
            return crypto.subtle.importKey(
                "raw",
                rawKey,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Encrypts a string message.
         * @param {string} message - The message string (can be raw Base64 for files).
         * @param {CryptoKey} key - The AES-GCM key for the vault.
         * @returns {Promise<{encryptedMessage: string, iv: string}>} Base64 encoded encrypted message and IV.
         */
        async function encryptMessage(message, key) {
            const enc = new TextEncoder();
            const encoded = enc.encode(message);
            const { encryptedData, iv } = await encryptData(encoded, key);
            return {
                encryptedMessage: btoa(String.fromCharCode(...new Uint8Array(encryptedData))),
                iv: btoa(String.fromCharCode(...iv))
            };
        }

        /**
         * Decrypts a string message.
         * @param {string} encryptedMessageB64 - Base64 encoded encrypted message.
         * @param {string} ivB64 - Base64 encoded IV.
         * @param {CryptoKey} key - The AES-GCM key for the vault.
         * @returns {Promise<string>} The decrypted message string (can be raw Base64 for files).
         */
        async function decryptMessage(encryptedMessageB64, ivB64, key) {
            try {
                const encryptedData = Uint8Array.from(atob(encryptedMessageB64), c => c.charCodeAt(0));
                const iv = Uint8Array.from(atob(ivB64), c => c.charCodeAt(0));
                const decryptedData = await decryptData(encryptedData, iv, key);
                const dec = new TextDecoder();
                return dec.decode(decryptedData);
            } catch (e) {
                console.error("Error decrypting message:", e);
                return "[Could not decrypt message]";
            }
        }

        // --- WebRTC (Peer-to-Peer) Functions ---

        /**
         * Sends a WebRTC signaling message via the WebSocket server.
         * @param {string} toUserId - The recipient of the signal.
         * @param {object} signalData - The WebRTC offer, answer, or ICE candidate.
         */
        function sendWebRTCSignal(toUserId, signalData) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'webrtc_signal',
                    fromUserId: userId,
                    toUserId: toUserId,
                    signalData: signalData
                }));
            } else {
                console.warn("WebSocket not open, cannot send WebRTC signal.");
            }
        }

        /**
         * Sets up a new RTCPeerConnection and data channel for a target user.
         * @param {string} targetUserId - The ID of the peer to connect to.
         * @param {string} vaultId - The ID of the vault this P2P connection is for.
         * @param {boolean} isInitiator - True if this client should create the offer.
         */
        async function setupPeerConnection(targetUserId, vaultId, isInitiator) {
            if (peerConnections.has(targetUserId)) {
                console.log(`P2P connection already exists for ${targetUserId}.`);
                return;
            }

            console.log(`Setting up P2P connection for ${targetUserId} in vault ${vaultId}. Initiator: ${isInitiator}`);
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: STUN_SERVERS }]
            });
            peerConnections.set(targetUserId, pc);

            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log(`Sending ICE candidate to ${targetUserId}`);
                    sendWebRTCSignal(targetUserId, { type: 'candidate', candidate: event.candidate });
                }
            };

            // Handle ICE connection state changes (for debugging)
            pc.oniceconnectionstatechange = () => {
                console.log(`ICE connection state for ${targetUserId}: ${pc.iceConnectionState}`);
                if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
                    console.warn(`P2P connection to ${targetUserId} failed or disconnected. Falling back to server relay.`);
                    dataChannels.delete(targetUserId); // Remove data channel if connection fails
                }
            };

            // Handle incoming data channels (for the non-initiator)
            pc.ondatachannel = (event) => {
                const dc = event.channel;
                console.log(`Incoming DataChannel from ${targetUserId}: ${dc.label}`);
                dataChannels.set(targetUserId, dc);
                setupDataChannelListeners(dc, targetUserId, vaultId);
            };

            if (isInitiator) {
                // Create data channel (for the initiator)
                const dataChannelLabel = `chat-${vaultId}`; // Unique label for the data channel
                const dc = pc.createDataChannel(dataChannelLabel);
                dataChannels.set(targetUserId, dc);
                setupDataChannelListeners(dc, targetUserId, vaultId);

                // Create offer
                pc.onnegotiationneeded = async () => {
                    try {
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        console.log(`Sending WebRTC offer to ${targetUserId}`);
                        sendWebRTCSignal(targetUserId, { type: 'offer', sdp: pc.localDescription });
                    } catch (e) {
                        console.error("Error creating or sending offer:", e);
                    }
                };
            }

            // Add any pending ICE candidates if they arrived before PC was ready
            if (pendingIceCandidates.has(targetUserId)) {
                for (const candidate of pendingIceCandidates.get(targetUserId)) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                }
                pendingIceCandidates.delete(targetUserId);
            }
        }

        /**
         * Sets up listeners for an RTCDataChannel.
         * @param {RTCDataChannel} dc - The data channel.
         * @param {string} peerId - The ID of the peer.
         * @param {string} vaultId - The vault ID associated with this channel.
         */
        function setupDataChannelListeners(dc, peerId, vaultId) {
            dc.onopen = () => {
                console.log(`DataChannel to ${peerId} in vault ${vaultId} is OPEN.`);
                showMessageBox('P2P Connected!', `Direct connection established with ${peerId.substring(0,8)}... for vault ${vaults.get(vaultId)?.name}.`);
                // Clear any pending offers for this peer if connection succeeded
                pendingOffers.delete(peerId);
            };

            dc.onmessage = async (event) => {
                let data;
                try {
                    data = JSON.parse(event.data);
                } catch (e) {
                    console.error("Failed to parse incoming P2P message:", e, event.data);
                    return;
                }
                console.log(`Received P2P message from ${peerId}:`, data);

                // Process P2P chat messages (similar to new_message from server)
                if (data.type === 'chat_message' || data.type === 'file_chunk') {
                    const { senderId, encryptedMessage, iv, timestamp, isFile, fileName, fileMimeType, fileId, chunkIndex, totalChunks } = data;
                    const vault = vaults.get(vaultId);

                    if (!vault) {
                        console.warn(`Received P2P message for unknown vault ID: ${vaultId}. Message:`, data);
                        return;
                    }

                    const isIncomingFilePart = (fileId !== undefined && chunkIndex !== undefined && totalChunks !== undefined);

                    if (isIncomingFilePart) {
                        if (!incomingFileChunks.has(fileId)) {
                            incomingFileChunks.set(fileId, {
                                fileName: fileName,
                                fileMimeType: fileMimeType,
                                totalChunks: totalChunks,
                                iv: iv, // IV for the whole file
                                senderId: senderId,
                                timestamp: timestamp,
                                receivedChunks: new Map(),
                                placeholderMessageElement: null
                            });

                            if (activeVaultId === vaultId) {
                                const chatWindow = document.getElementById('chat-window');
                                const placeholderDiv = document.createElement('div');
                                placeholderDiv.className = `message other`;
                                placeholderDiv.innerHTML = `
                                    <div class="message-sender">User: ${senderId.substring(0, 8)}...</div>
                                    <div class="message-content">Receiving file: ${fileName || 'unknown'} (0/${totalChunks} chunks received) via P2P...</div>
                                    <span class="message-timestamp">${new Date(timestamp).toLocaleTimeString()}</span>
                                `;
                                chatWindow.appendChild(placeholderDiv);
                                chatWindow.scrollTop = chatWindow.scrollHeight;
                                incomingFileChunks.get(fileId).placeholderMessageElement = placeholderDiv;
                            }
                        }

                        const fileData = incomingFileChunks.get(fileId);
                        fileData.receivedChunks.set(chunkIndex, encryptedMessage);

                        if (activeVaultId === vaultId && fileData.placeholderMessageElement) {
                            const contentSpan = fileData.placeholderMessageElement.querySelector('.message-content');
                            if (contentSpan) {
                                contentSpan.textContent = `Receiving file: ${fileName || 'unknown'} (${fileData.receivedChunks.size}/${totalChunks} chunks received) via P2P`;
                            }
                            document.getElementById('chat-window').scrollTop = document.getElementById('chat-window').scrollHeight;
                        }

                        if (fileData.receivedChunks.size === totalChunks) {
                            const sortedChunks = Array.from(fileData.receivedChunks.entries())
                                                          .sort(([idxA], [idxB]) => idxA - idxB)
                                                          .map(([, chunk]) => chunk);
                            const combinedEncryptedRawBase64 = sortedChunks.join('');

                            try {
                                // Prepend data URL prefix before decrypting
                                const fullEncryptedDataUrl = `data:${fileData.fileMimeType};base64,${combinedEncryptedRawBase64}`;
                                const decryptedContent = await decryptMessage(fullEncryptedDataUrl, fileData.iv, vault.key);
                                const messageObj = {
                                    sender: fileData.senderId,
                                    content: decryptedContent,
                                    timestamp: fileData.timestamp,
                                    isFile: true,
                                    fileName: fileData.fileName,
                                    fileMimeType: fileData.fileMimeType
                                };
                                vault.messages.push(messageObj);
                                await saveVaultsToLocalStorage();

                                if (activeVaultId === vaultId && fileData.placeholderMessageElement) {
                                    fileData.placeholderMessageElement.remove();
                                    displayMessage(messageObj);
                                }
                            } catch (e) {
                                console.error("Failed to decrypt reassembled P2P file:", e);
                                vault.messages.push({
                                    sender: fileData.senderId,
                                    content: `[Failed to receive/decrypt P2P file: ${fileData.fileName || 'unknown_file'}]`,
                                    timestamp: fileData.timestamp,
                                    isFile: false
                                });
                                await saveVaultsToLocalStorage();
                                if (activeVaultId === vaultId && fileData.placeholderMessageElement) {
                                    fileData.placeholderMessageElement.remove();
                                    displayMessage({
                                        sender: fileData.senderId,
                                        content: `[Failed to receive/decrypt P2P file: ${fileData.fileName || 'unknown_file'}]`,
                                        timestamp: fileData.timestamp,
                                        isFile: false
                                    });
                                }
                            } finally {
                                incomingFileChunks.delete(fileId);
                            }
                        }
                    } else { // Regular P2P text message
                        try {
                            const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                            const messageObj = {
                                sender: senderId,
                                content: decryptedContent,
                                timestamp: timestamp,
                                isFile: false // P2P text message
                            };
                            vault.messages.push(messageObj);
                            await saveVaultsToLocalStorage();
                            if (activeVaultId === vaultId) {
                                displayMessage(messageObj);
                            }
                        } catch (e) {
                            console.error("Failed to decrypt incoming P2P message:", e);
                            vault.messages.push({
                                sender: senderId,
                                content: "[Could not decrypt P2P message]",
                                timestamp: timestamp,
                                isFile: false
                            });
                            await saveVaultsToLocalStorage();
                            if (activeVaultId === vaultId) {
                                displayMessage(messageObj);
                            }
                        }
                    }
                }
            };

            dc.onclose = () => {
                console.log(`DataChannel to ${peerId} in vault ${vaultId} is CLOSED.`);
                dataChannels.delete(peerId);
                showMessageBox('P2P Disconnected', `Direct connection to ${peerId.substring(0,8)}... for vault ${vaults.get(vaultId)?.name} has closed. Messages will now relay via server.`);
            };

            dc.onerror = (error) => {
                console.error(`DataChannel error for ${peerId}:`, error);
                showMessageBox('P2P Error', `Error in direct connection to ${peerId.substring(0,8)}.... Falling back to server.`);
                dataChannels.delete(peerId);
            };
        }

        /**
         * Handles incoming WebRTC signaling messages from the WebSocket server.
         * @param {object} data - The message data containing signalData.
         */
        async function handleWebRTCSignal(data) {
            const { fromUserId, signalData } = data;
            const pc = peerConnections.get(fromUserId);

            if (signalData.type === 'offer') {
                if (!pc) {
                    // If peer connection doesn't exist, create it and set remote description
                    // This client is the answerer
                    await setupPeerConnection(fromUserId, activeVaultId, false); // Assume activeVaultId is the relevant one
                    const newPc = peerConnections.get(fromUserId);
                    await newPc.setRemoteDescription(new RTCSessionDescription(signalData.sdp));
                    const answer = await newPc.createAnswer();
                    await newPc.setLocalDescription(answer);
                    sendWebRTCSignal(fromUserId, { type: 'answer', sdp: newPc.localDescription });

                    // Add any pending candidates that arrived before the offer was processed
                    if (pendingIceCandidates.has(fromUserId)) {
                        for (const candidate of pendingIceCandidates.get(fromUserId)) {
                            await newPc.addIceCandidate(new RTCIceCandidate(candidate));
                        }
                        pendingIceCandidates.delete(fromUserId);
                    }
                } else {
                    // If PC exists, but we haven't processed the offer yet (shouldn't happen often)
                    console.warn(`Received offer for existing PC ${fromUserId}, but PC might not be ready.`);
                    await pc.setRemoteDescription(new RTCSessionDescription(signalData.sdp));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    sendWebRTCSignal(fromUserId, { type: 'answer', sdp: pc.localDescription });
                }
            } else if (signalData.type === 'answer') {
                if (pc && pc.localDescription) { // Ensure local description is set before setting remote answer
                    await pc.setRemoteDescription(new RTCSessionDescription(signalData.sdp));
                } else {
                    console.warn(`Received answer for ${fromUserId} but peer connection not ready or local description not set.`);
                    // Store answer if PC not ready, though offers should typically arrive first
                    pendingOffers.set(fromUserId, signalData.sdp);
                }
            } else if (signalData.type === 'candidate') {
                if (pc && pc.remoteDescription) { // Only add candidate if remote description is set
                    try {
                        await pc.addIceCandidate(new RTCIceCandidate(signalData.candidate));
                    } catch (e) {
                        console.error("Error adding ICE candidate:", e);
                    }
                } else {
                    // Store candidates if peer connection or remote description is not yet set
                    if (!pendingIceCandidates.has(fromUserId)) {
                        pendingIceCandidates.set(fromUserId, []);
                    }
                    pendingIceCandidates.get(fromUserId).push(signalData.candidate);
                }
            }
        }

        /**
         * Initializes the WebSocket connection.
         */
        function initWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            console.warn(`Attempting to connect to WebSocket server at: ${SERVER_URL}`);
            ws = new WebSocket(SERVER_URL);

            ws.onopen = async () => {
                console.log('WebSocket connected.');
                // Send user ID to server upon connection
                ws.send(JSON.stringify({ type: 'register', userId: userId }));
                // Load vaults from local storage AFTER registering with the server
                // This ensures we have our ID before trying to retrieve offline messages
                await loadVaultsFromLocalStorage();
            };

            ws.onmessage = async (event) => {
                let data;
                try {
                    data = JSON.parse(event.data);
                } catch (e) {
                    console.error("Failed to parse incoming WebSocket message:", e, event.data);
                    showMessageBox('Data Error', 'Received malformed data from server.');
                    return;
                }
                console.log('Received:', data);

                switch (data.type) {
                    case 'vault_created':
                        // Server sends back the hash and encrypted key for the creator
                        const { vaultId, vaultHash, vaultName, vaultType, expiration, encryptedKeyB64, ivB64, saltB64, participants: createdParticipants } = data;
                        const salt = Uint8Array.from(atob(saltB64), c => c.charCodeAt(0));
                        const derivedKeyForVaultKey = await deriveKeyFromHash(vaultHash, salt);
                        const decryptedVaultKeyRaw = await decryptData(
                            Uint8Array.from(atob(encryptedKeyB64), c => c.charCodeAt(0)),
                            Uint8Array.from(atob(ivB64), c => c.charCodeAt(0)),
                            derivedKeyForVaultKey
                        );
                        const vaultAesKey = await importKey(decryptedVaultKeyRaw);

                        vaults.set(vaultId, {
                            id: vaultId,
                            name: vaultName,
                            type: vaultType,
                            expiration: expiration,
                            key: vaultAesKey,
                            messages: [],
                            participants: createdParticipants || []
                        });
                        await saveVaultsToLocalStorage(); // Await saving
                        renderVaultList();
                        document.getElementById('generated-vault-hash').textContent = vaultHash;
                        document.getElementById('create-vault-hash-display').classList.remove('hidden');
                        showMessageBox('Vault Created!', `Your vault "${vaultName}" has been created. Share this hash: ${vaultHash}`, () => {
                            // Automatically select the new vault after creation
                            selectVault(vaultId);
                        });
                        break;
                    case 'vault_joined':
                        // Server sends back the encrypted key for the joiner
                        const { joinedVaultId, joinedVaultName, joinedVaultType, joinedExpiration, encryptedKeyB64: joinedEncryptedKeyB64, ivB64: joinedIvB64, saltB64: joinedSaltB64, vaultHash: joinHashUsed, participants: joinedParticipants } = data;
                        const joinSalt = Uint8Array.from(atob(joinedSaltB64), c => c.charCodeAt(0));
                        const derivedKeyForJoinedVaultKey = await deriveKeyFromHash(joinHashUsed, joinSalt);
                        const decryptedJoinedVaultKeyRaw = await decryptData(
                            Uint8Array.from(atob(joinedEncryptedKeyB64), c => c.charCodeAt(0)),
                            Uint8Array.from(atob(joinedIvB64), c => c.charCodeAt(0)),
                            derivedKeyForJoinedVaultKey
                        );
                        const joinedVaultAesKey = await importKey(decryptedJoinedVaultKeyRaw);

                        vaults.set(joinedVaultId, {
                            id: joinedVaultId,
                            name: joinedVaultName,
                            type: joinedVaultType,
                            expiration: joinedExpiration,
                            key: joinedVaultAesKey,
                            messages: [],
                            participants: joinedParticipants || []
                        });
                        await saveVaultsToLocalStorage(); // Await saving
                        renderVaultList();
                        showMessageBox('Vault Joined!', `You have joined "${joinedVaultName}".`, () => {
                            selectVault(joinedVaultId);
                        });
                        break;
                    case 'new_message':
                        const { vaultId: msgVaultId, senderId, encryptedMessage, iv, timestamp, isFile, fileName, fileMimeType, fileId, chunkIndex, totalChunks } = data;
                        const vault = vaults.get(msgVaultId);

                        if (!vault) {
                            console.warn(`Received message for unknown vault ID: ${msgVaultId}. Message:`, data);
                            return;
                        }

                        // Determine if this message is part of a chunked file transfer
                        // This condition will now catch both chunks and single-part files sent with chunk metadata
                        const isIncomingFilePart = (fileId !== undefined && chunkIndex !== undefined && totalChunks !== undefined);

                        if (isIncomingFilePart) {
                            if (!incomingFileChunks.has(fileId)) {
                                // Initialize file data for reassembly
                                incomingFileChunks.set(fileId, {
                                    fileName: fileName,
                                    fileMimeType: fileMimeType,
                                    totalChunks: totalChunks,
                                    iv: iv, // IV for the whole file
                                    senderId: senderId,
                                    timestamp: timestamp,
                                    receivedChunks: new Map(), // Map<chunkIndex, encryptedChunk>
                                    placeholderMessageElement: null // To store reference to the placeholder div
                                });

                                // Display a placeholder message immediately for the receiving user
                                if (activeVaultId === msgVaultId) {
                                    const chatWindow = document.getElementById('chat-window');
                                    const placeholderDiv = document.createElement('div');
                                    placeholderDiv.className = `message other`; // Always 'other' for incoming
                                    placeholderDiv.innerHTML = `
                                        <div class="message-sender">User: ${senderId.substring(0, 8)}...</div>
                                        <div class="message-content">Receiving file: ${fileName || 'unknown'} (0/${totalChunks} chunks received)...</div>
                                        <span class="message-timestamp">${new Date(timestamp).toLocaleTimeString()}</span>
                                    `;
                                    chatWindow.appendChild(placeholderDiv);
                                    chatWindow.scrollTop = chatWindow.scrollHeight;
                                    incomingFileChunks.get(fileId).placeholderMessageElement = placeholderDiv;
                                }
                            }

                            const fileData = incomingFileChunks.get(fileId);
                            fileData.receivedChunks.set(chunkIndex, encryptedMessage); // Store encrypted chunk

                            // Update placeholder message with progress
                            if (activeVaultId === msgVaultId && fileData.placeholderMessageElement) {
                                const contentSpan = fileData.placeholderMessageElement.querySelector('.message-content');
                                if (contentSpan) {
                                    contentSpan.textContent = `Receiving file: ${fileName || 'unknown'} (${fileData.receivedChunks.size}/${totalChunks} chunks received)`;
                                }
                                document.getElementById('chat-window').scrollTop = document.getElementById('chat-window').scrollHeight;
                            }

                            // Check if all chunks are received
                            if (fileData.receivedChunks.size === totalChunks) {
                                // Reassemble the file
                                const sortedChunks = Array.from(fileData.receivedChunks.entries())
                                                              .sort(([idxA], [idxB]) => idxA - idxB)
                                                              .map(([, chunk]) => chunk);
                                const combinedEncryptedRawBase64 = sortedChunks.join(''); // Concatenate Base64 strings of encrypted chunks

                                try {
                                    // Prepend data URL prefix before decrypting
                                    const fullEncryptedDataUrl = `data:${fileData.fileMimeType};base64,${combinedEncryptedRawBase64}`;
                                    const decryptedContent = await decryptMessage(fullEncryptedDataUrl, fileData.iv, vault.key);
                                    const messageObj = {
                                        sender: fileData.senderId,
                                        content: decryptedContent, // This is the full Base64 file
                                        timestamp: fileData.timestamp,
                                        isFile: true,
                                        fileName: fileData.fileName,
                                        fileMimeType: fileData.fileMimeType
                                    };
                                    vault.messages.push(messageObj);
                                    console.log(`Reassembled and processed file for vault ${msgVaultId}:`, messageObj);
                                    await saveVaultsToLocalStorage();

                                    // Remove placeholder and display final message
                                    if (activeVaultId === msgVaultId && fileData.placeholderMessageElement) {
                                        fileData.placeholderMessageElement.remove();
                                        displayMessage(messageObj);
                                    }
                                } catch (e) {
                                    console.error("Failed to decrypt reassembled file:", e);
                                    // Store an error message in vault.messages
                                    vault.messages.push({
                                        sender: fileData.senderId,
                                        content: `[Failed to receive/decrypt file: ${fileData.fileName || 'unknown_file'}]`,
                                        timestamp: fileData.timestamp,
                                        isFile: false // Display as text error
                                    });
                                    await saveVaultsToLocalStorage();
                                    // Remove placeholder and display error message
                                    if (activeVaultId === msgVaultId && fileData.placeholderMessageElement) {
                                        fileData.placeholderMessageElement.remove();
                                        displayMessage({
                                            sender: fileData.senderId,
                                            content: `[Failed to receive/decrypt file: ${fileData.fileName || 'unknown_file'}]`,
                                            timestamp: fileData.timestamp,
                                            isFile: false
                                        });
                                    }
                                } finally {
                                    incomingFileChunks.delete(fileId); // Clean up temporary chunks
                                }
                            }
                            // Do NOT display individual chunks if not all received
                        } else {
                            // This is a regular text message (or a file sent without chunk metadata, though our sender now always adds it)
                            try {
                                const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                                const messageObj = {
                                    sender: senderId,
                                    content: decryptedContent,
                                    timestamp: timestamp,
                                    isFile: isFile,
                                    fileName: fileName,
                                    fileMimeType: fileMimeType
                                };
                                vault.messages.push(messageObj);
                                console.log(`New message for vault ${msgVaultId}:`, messageObj);
                                await saveVaultsToLocalStorage();
                                if (activeVaultId === msgVaultId) {
                                    displayMessage(messageObj);
                                }
                            } catch (e) {
                                console.error("Failed to decrypt incoming message:", e);
                                const messageObj = {
                                    sender: senderId,
                                    content: "[Could not decrypt message]",
                                    timestamp: timestamp,
                                    isFile: false
                                };
                                vault.messages.push(messageObj);
                                await saveVaultsToLocalStorage();
                                if (activeVaultId === msgVaultId) {
                                    displayMessage(messageObj);
                                }
                            }
                        }
                        break;
                    case 'offline_messages':
                        console.log(`Received ${data.messages.length} offline messages.`);
                        for (const msg of data.messages) {
                            const { vaultId: msgVaultId, senderId, encryptedMessage, iv, timestamp, isFile, fileName, fileMimeType, fileId, chunkIndex, totalChunks } = msg; // Include chunking metadata for offline messages
                            const vault = vaults.get(msgVaultId);

                            if (!vault) {
                                console.warn(`Received offline message for unknown vault ID: ${msgVaultId}. Message:`, msg);
                                continue;
                            }

                            // Handle offline file chunks similar to live messages
                            const isOfflineFilePart = (fileId !== undefined && chunkIndex !== undefined && totalChunks !== undefined);

                            if (isOfflineFilePart) {
                                if (!incomingFileChunks.has(fileId)) {
                                    incomingFileChunks.set(fileId, {
                                        fileName: fileName,
                                        fileMimeType: fileMimeType,
                                        totalChunks: totalChunks,
                                        iv: iv,
                                        senderId: senderId,
                                        timestamp: timestamp,
                                        receivedChunks: new Map()
                                    });
                                }
                                const fileData = incomingFileChunks.get(fileId);
                                fileData.receivedChunks.set(chunkIndex, encryptedMessage);

                                if (fileData.receivedChunks.size === totalChunks) {
                                    const sortedChunks = Array.from(fileData.receivedChunks.entries())
                                                                  .sort(([idxA], [idxB]) => idxA - idxB)
                                                                  .map(([, chunk]) => chunk);
                                    const combinedEncryptedRawBase64 = sortedChunks.join('');

                                    try {
                                        const fullEncryptedDataUrl = `data:${fileData.fileMimeType};base64,${combinedEncryptedRawBase64}`;
                                        const decryptedContent = await decryptMessage(fullEncryptedDataUrl, fileData.iv, vault.key);
                                        const messageObj = {
                                            sender: fileData.senderId,
                                            content: decryptedContent,
                                            timestamp: fileData.timestamp,
                                            isFile: true,
                                            fileName: fileData.fileName,
                                            fileMimeType: fileData.fileMimeType
                                        };
                                        vault.messages.push(messageObj);
                                        console.log(`Reassembled and processed offline file for vault ${msgVaultId}:`, messageObj);
                                    } catch (e) {
                                        console.error("Failed to decrypt reassembled offline file:", e);
                                        vault.messages.push({
                                            sender: fileData.senderId,
                                            content: `[Failed to receive/decrypt offline file: ${fileData.fileName || 'unknown_file'}]`,
                                            timestamp: fileData.timestamp,
                                            isFile: false
                                        });
                                    } finally {
                                        incomingFileChunks.delete(fileId);
                                    }
                                }
                            } else {
                                // Handle regular offline messages
                                try {
                                    const decryptedContent = await decryptMessage(encryptedMessage, iv, vault.key);
                                    const messageObj = {
                                        sender: senderId,
                                        content: decryptedContent,
                                        timestamp: timestamp,
                                        isFile: isFile,
                                        fileName: fileName,
                                        fileMimeType: fileMimeType
                                    };
                                    vault.messages.push(messageObj);
                                    console.log(`Processed offline message for vault ${msgVaultId}:`, messageObj);
                                } catch (e) {
                                    console.error("Failed to decrypt offline message:", e);
                                    vault.messages.push({
                                        sender: senderId,
                                        content: "[Could not decrypt message]",
                                        timestamp: timestamp,
                                        isFile: false
                                    });
                                }
                            }
                        }
                        await saveVaultsToLocalStorage(); // Await saving
                        // Re-render chat for the active vault if new offline messages were added to it
                        if (activeVaultId && vaults.has(activeVaultId)) {
                            renderChatMessages(activeVaultId);
                        }
                        break;
                    case 'error':
                        showMessageBox('Error', data.message);
                        break;
                    case 'vault_expired_notification':
                        const { expiredVaultId, expiredVaultName } = data;
                        if (vaults.has(expiredVaultId)) {
                             vaults.delete(expiredVaultId);
                             await saveVaultsToLocalStorage(); // Await saving after deletion
                             renderVaultList();
                             if (activeVaultId === expiredVaultId) {
                                 activeVaultId = null;
                                 document.getElementById('chat-window').classList.add('hidden');
                                 document.getElementById('chat-input-area').classList.add('hidden');
                                 document.getElementById('no-vault-selected').classList.remove('hidden');
                             }
                             showMessageBox('Vault Expired', `The vault "${expiredVaultName}" has expired and all its data has been wiped.`);
                        } else {
                            console.log(`Received expiration for unknown or already removed vault: ${expiredVaultName} (${expiredVaultId})`);
                        }
                        break;
                    case 'webrtc_signal':
                        handleWebRTCSignal(data);
                        break;
                }
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected. Attempting to reconnect in 5 seconds...');
                // Consider adding a visual indicator for disconnection
                setTimeout(initWebSocket, 5000);
            };

            ws.onerror = (event) => {
                console.error('WebSocket error event:', event);
                showMessageBox('Connection Error',
                    `Could not connect to the server at ${SERVER_URL}. ` +
                    `Please ensure:
                    1. The Node.js server is running.
                    2. The SERVER_URL in index.html is correct.
                    3. If deployed (e.g., to Render), use 'wss://' for the SERVER_URL.`);
            };
        }

        /**
         * Sends a message to the WebSocket server.
         * @param {object} message - The message object to send.
         */
        function sendMessageToServer(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                showMessageBox('Connection Error', 'Not connected to server. Please wait or refresh.');
                console.warn("Attempted to send message while WebSocket is not open.", message);
            }
        }

        // --- Local Storage Management ---

        /**
         * Saves all vaults data to localStorage.
         * Note: CryptoKey objects cannot be directly stored. We export them to raw ArrayBuffer (Base64)
         * and re-import them when loading.
         */
        async function saveVaultsToLocalStorage() {
            console.log("Saving vaults to localStorage...");
            const serializableVaults = [];
            for (const [id, vault] of vaults.entries()) {
                try {
                    const exportedKey = await exportKey(vault.key);
                    serializableVaults.push({
                        id: vault.id,
                        name: vault.name,
                        type: vault.type,
                        expiration: vault.expiration,
                        key: btoa(String.fromCharCode(...new Uint8Array(exportedKey))), // Base64 encode key
                        messages: vault.messages, // Messages are already serializable
                        participants: vault.participants || [] // Save participants
                    });
                } catch (e) {
                    console.error(`Failed to export key for vault ${id}:`, e);
                    // Optionally, remove this vault from the list to be saved if its key is corrupted
                }
            }
            try {
                localStorage.setItem('thePlatformVaults', JSON.stringify(serializableVaults));
                console.log("Vaults successfully saved to localStorage.");
            } catch (e) {
                console.error("Error saving vaults to localStorage:", e);
                showMessageBox('Storage Error', 'Could not save data to local storage. Your browser might be full or private browsing is enabled.');
            }
        }

        /**
         * Loads vaults data from localStorage.
         */
        async function loadVaultsFromLocalStorage() {
            console.log("Loading vaults from localStorage...");
            const storedVaults = localStorage.getItem('thePlatformVaults');
            vaults.clear(); // Clear existing vaults before loading
            if (storedVaults) {
                try {
                    const parsedVaults = JSON.parse(storedVaults);
                    for (const serializedVault of parsedVaults) {
                        try {
                            const importedKey = await importKey(Uint8Array.from(atob(serializedVault.key), c => c.charCodeAt(0)));
                            vaults.set(serializedVault.id, {
                                id: serializedVault.id,
                                name: serializedVault.name,
                                type: serializedVault.type,
                                expiration: serializedVault.expiration,
                                key: importedKey,
                                messages: serializedVault.messages || [],
                                participants: serializedVault.participants || [] // Load participants
                            });
                            console.log(`Loaded vault: ${serializedVault.name} (${serializedVault.id})`);
                        } catch (e) {
                            console.error(`Failed to load vault ${serializedVault.id} from localStorage (key import failed):`, e);
                            // This vault might be corrupted or key unimportable, skip it.
                        }
                    }
                    console.log(`Finished loading ${vaults.size} vaults from localStorage.`);
                    renderVaultList();
                    // If there are vaults, select the first one by default or previously active
                    if (vaults.size > 0) {
                        const lastActiveVaultId = localStorage.getItem('lastActiveVaultId');
                        if (lastActiveVaultId && vaults.has(lastActiveVaultId)) {
                            selectVault(lastActiveVaultId);
                        } else {
                            selectVault(vaults.keys().next().value); // Select the first available vault
                        }
                    } else {
                        console.log("No vaults found in localStorage.");
                        document.getElementById('no-vault-selected').classList.remove('hidden');
                        document.getElementById('chat-window').classList.add('hidden');
                        document.getElementById('chat-input-area').classList.add('hidden');
                    }
                } catch (e) {
                    console.error("Error parsing vaults from localStorage:", e);
                    showMessageBox('Data Corruption', 'Local vault data is corrupted. Clearing data and starting fresh.');
                    localStorage.removeItem('thePlatformVaults'); // Clear corrupted data
                    // Reload the page or simply continue with empty vaults
                    renderVaultList();
                }
            } else {
                console.log("No vaults found in localStorage initially.");
            }
        }

        /**
         * Clears all local data (vaults, messages, user ID).
         */
        function nukeAllData() {
            showMessageBox('Confirm Nuke', 'Are you sure you want to wipe ALL your local data and disconnect? This action cannot be undone. This will also attempt to clear your data on the server.', async () => {
                localStorage.removeItem('thePlatformVaults');
                localStorage.removeItem('thePlatformUserId');
                localStorage.removeItem('lastActiveVaultId');
                vaults.clear();
                activeVaultId = null;
                document.getElementById('chat-window').innerHTML = '';
                document.getElementById('vault-list').innerHTML = '';
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('current-user-id').textContent = 'Nuked! Reopen for new ID.';

                // Inform server to remove user's data
                sendMessageToServer({ type: 'nuke', userId: userId });

                // Simulate closing the page by clearing content and displaying a message
                document.body.innerHTML = `
                    <div class="flex flex-col items-center justify-center min-h-screen bg-gray-100 text-gray-700">
                        <h1 class="text-4xl font-bold mb-4">Data Nuked!</h1>
                        <p class="text-lg">All your local data has been wiped.</p>
                        <p class="text-lg">To start fresh, please reopen "The Platform".</p>
                    </div>
                `;
            });
        }


        // --- UI Rendering ---

        /**
         * Renders the list of vaults in the sidebar.
         */
        function renderVaultList() {
            const vaultListDiv = document.getElementById('vault-list');
            vaultListDiv.innerHTML = '';
            if (vaults.size === 0) {
                vaultListDiv.innerHTML = '<p class="text-center text-gray-500 text-sm mt-4">No vaults yet. Create or join one!</p>';
            }
            vaults.forEach(vault => {
                const vaultItem = document.createElement('div');
                vaultItem.className = `vault-item ${activeVaultId === vault.id ? 'active' : ''}`;
                vaultItem.dataset.vaultId = vault.id;
                vaultItem.innerHTML = `
                    <span>${vault.name} (${vault.type === 'private' ? 'DM' : 'Group'})</span>
                    <span class="text-xs text-gray-500">${vault.expiration === 'never' ? 'Never Exp.' : `Exp: ${vault.expiration}`}</span>
                `;
                vaultItem.addEventListener('click', () => selectVault(vault.id));
                vaultListDiv.appendChild(vaultItem);
            });
        }

        /**
         * Displays a single message in the chat window.
         * @param {object} message - The message object.
         */
        function displayMessage(message) {
            const chatWindow = document.getElementById('chat-window');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.sender === userId ? 'self' : 'other'}`;

            const senderSpan = document.createElement('div');
            senderSpan.className = 'message-sender';
            senderSpan.textContent = message.sender === userId ? 'You' : `User: ${message.sender.substring(0, 8)}...`;
            messageDiv.appendChild(senderSpan);

            if (message.isFile) {
                const fileLink = document.createElement('div');
                fileLink.className = 'message-file';
                fileLink.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path d="M19.5 7.5c-1.25 0-2.5.31-3.57.88-.85.45-1.48 1.12-1.87 1.94-.17.36-.31.75-.41 1.15a.75.75 0 0 1-1.09-.72c.16-.49.37-.96.6-1.42.34-.67.79-1.28 1.34-1.83 1.04-1.04 2.39-1.66 3.86-1.8.02-.01.04-.02.06-.02a.75.75 0 0 1 .78 1.25c-.06.05-.12.09-.18.14-.8.6-1.25 1.4-1.25 2.25v.75h.75c.85 0 1.65-.45 2.25-1.25.05-.06.09-.12.14-.18a.75.75 0 0 1 1.25.78c-.01.02-.02.04-.02.06-.14 1.47-.76 2.82-1.8 3.86-1.04 1.04-2.39 1.66-3.86 1.8-.02.01-.04.02-.06.02a.75.75 0 0 1-.78-1.25c.06-.05.12-.09.18-.14.8-.6 1.25-1.4 1.25-2.25V7.5h-.75Zm-10.5 0c-1.25 0-2.5.31-3.57.88-.85.45-1.48 1.12-1.87 1.94-.17.36-.31.75-.41 1.15a.75.75 0 0 1-1.09-.72c.16-.49.37-.96.6-1.42.34-.67.79-1.28 1.34-1.83 1.04-1.04 2.39-1.66 3.86-1.8.02-.01.04-.02.06-.02a.75.75 0 0 1 .78 1.25c-.06.05-.12.09-.18.14-.8.6-1.25 1.4-1.25 2.25v.75h.75c.85 0 1.65-.45 2.25-1.25.05-.06.09-.12.14-.18a.75.75 0 0 1 1.25.78c-.01.02-.02.04-.02.06-.14 1.47-.76 2.82-1.8 3.86-1.04 1.04-2.39 1.66-3.86 1.8-.02.01-.04.02-.06.02a.75.75 0 0 1-.78-1.25c.06-.05.12-.09.18-.14.8-.6 1.25-1.4 1.25-2.25V7.5h-.75Z" />
                    </svg>
                    <span>${message.fileName || 'File'}</span>
                `;
                fileLink.addEventListener('click', () => downloadFile(message.content, message.fileName, message.fileMimeType));
                messageDiv.appendChild(fileLink);
            } else {
                const contentSpan = document.createElement('div');
                contentSpan.className = 'message-content';
                contentSpan.textContent = message.content;
                messageDiv.appendChild(contentSpan);
            }

            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = new Date(message.timestamp).toLocaleTimeString();
            messageDiv.appendChild(timestampSpan);

            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight; // Scroll to bottom
        }

        /**
         * Renders all messages for the currently selected vault.
         * @param {string} vaultId - The ID of the vault whose messages to render.
         */
        function renderChatMessages(vaultId) {
            const chatWindow = document.getElementById('chat-window');
            chatWindow.innerHTML = ''; // Clear previous messages
            const vault = vaults.get(vaultId);
            if (vault && vault.messages) {
                // Sort messages by timestamp to ensure correct order
                vault.messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                vault.messages.forEach(msg => displayMessage(msg));
            }
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /**
         * Selects a vault and displays its chat.
         * @param {string} vaultId - The ID of the vault to select.
         */
        function selectVault(vaultId) {
            if (!vaults.has(vaultId)) {
                console.warn(`Attempted to select non-existent vault: ${vaultId}`);
                showMessageBox('Vault Not Found', 'This vault no longer exists locally. It might have expired or been removed.');
                activeVaultId = null;
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                renderVaultList(); // Re-render to ensure no vault is marked active
                return;
            }

            activeVaultId = vaultId;
            localStorage.setItem('lastActiveVaultId', vaultId); // Using localStorage for persistence
            renderVaultList(); // Update active class
            document.getElementById('no-vault-selected').classList.add('hidden');
            document.getElementById('chat-window').classList.remove('hidden');
            document.getElementById('chat-input-area').classList.remove('hidden');
            renderChatMessages(vaultId);
            document.getElementById('message-input').focus();
            console.log(`Selected vault: ${vaults.get(vaultId).name} (${vaultId})`);

            // P2P: If it's a private vault, try to establish P2P connection with the other participant
            const vault = vaults.get(vaultId);
            if (vault.type === 'private' && vault.participants.length === 2) {
                const otherParticipantId = vault.participants.find(pId => pId !== userId);
                if (otherParticipantId) {
                    // Initiate P2P connection if not already established
                    if (!peerConnections.has(otherParticipantId) || dataChannels.get(otherParticipantId)?.readyState !== 'open') {
                        setupPeerConnection(otherParticipantId, vaultId, true); // This client is the initiator
                    }
                }
            }
        }

        /**
         * Sends a message to the WebSocket server.
         * @param {object} message - The message object to send.
         */
        function sendMessageToServer(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                showMessageBox('Connection Error', 'Not connected to server. Please wait or refresh.');
                console.warn("Attempted to send message while WebSocket is not open.", message);
            }
        }

        // --- Local Storage Management ---

        /**
         * Saves all vaults data to localStorage.
         * Note: CryptoKey objects cannot be directly stored. We export them to raw ArrayBuffer (Base64)
         * and re-import them when loading.
         */
        async function saveVaultsToLocalStorage() {
            console.log("Saving vaults to localStorage...");
            const serializableVaults = [];
            for (const [id, vault] of vaults.entries()) {
                try {
                    const exportedKey = await exportKey(vault.key);
                    serializableVaults.push({
                        id: vault.id,
                        name: vault.name,
                        type: vault.type,
                        expiration: vault.expiration,
                        key: btoa(String.fromCharCode(...new Uint8Array(exportedKey))), // Base64 encode key
                        messages: vault.messages, // Messages are already serializable
                        participants: vault.participants || [] // Save participants
                    });
                } catch (e) {
                    console.error(`Failed to export key for vault ${id}:`, e);
                    // Optionally, remove this vault from the list to be saved if its key is corrupted
                }
            }
            try {
                localStorage.setItem('thePlatformVaults', JSON.stringify(serializableVaults));
                console.log("Vaults successfully saved to localStorage.");
            } catch (e) {
                console.error("Error saving vaults to localStorage:", e);
                showMessageBox('Storage Error', 'Could not save data to local storage. Your browser might be full or private browsing is enabled.');
            }
        }

        /**
         * Loads vaults data from localStorage.
         */
        async function loadVaultsFromLocalStorage() {
            console.log("Loading vaults from localStorage...");
            const storedVaults = localStorage.getItem('thePlatformVaults');
            vaults.clear(); // Clear existing vaults before loading
            if (storedVaults) {
                try {
                    const parsedVaults = JSON.parse(storedVaults);
                    for (const serializedVault of parsedVaults) {
                        try {
                            const importedKey = await importKey(Uint8Array.from(atob(serializedVault.key), c => c.charCodeAt(0)));
                            vaults.set(serializedVault.id, {
                                id: serializedVault.id,
                                name: serializedVault.name,
                                type: serializedVault.type,
                                expiration: serializedVault.expiration,
                                key: importedKey,
                                messages: serializedVault.messages || [],
                                participants: serializedVault.participants || [] // Load participants
                            });
                            console.log(`Loaded vault: ${serializedVault.name} (${serializedVault.id})`);
                        } catch (e) {
                            console.error(`Failed to load vault ${serializedVault.id} from localStorage (key import failed):`, e);
                            // This vault might be corrupted or key unimportable, skip it.
                        }
                    }
                    console.log(`Finished loading ${vaults.size} vaults from localStorage.`);
                    renderVaultList();
                    // If there are vaults, select the first one by default or previously active
                    if (vaults.size > 0) {
                        const lastActiveVaultId = localStorage.getItem('lastActiveVaultId');
                        if (lastActiveVaultId && vaults.has(lastActiveVaultId)) {
                            selectVault(lastActiveVaultId);
                        } else {
                            selectVault(vaults.keys().next().value); // Select the first available vault
                        }
                    } else {
                        console.log("No vaults found in localStorage.");
                        document.getElementById('no-vault-selected').classList.remove('hidden');
                        document.getElementById('chat-window').classList.add('hidden');
                        document.getElementById('chat-input-area').classList.add('hidden');
                    }
                } catch (e) {
                    console.error("Error parsing vaults from localStorage:", e);
                    showMessageBox('Data Corruption', 'Local vault data is corrupted. Clearing data and starting fresh.');
                    localStorage.removeItem('thePlatformVaults'); // Clear corrupted data
                    // Reload the page or simply continue with empty vaults
                    renderVaultList();
                }
            } else {
                console.log("No vaults found in localStorage initially.");
            }
        }

        /**
         * Clears all local data (vaults, messages, user ID).
         */
        function nukeAllData() {
            showMessageBox('Confirm Nuke', 'Are you sure you want to wipe ALL your local data and disconnect? This action cannot be undone. This will also attempt to clear your data on the server.', async () => {
                localStorage.removeItem('thePlatformVaults');
                localStorage.removeItem('thePlatformUserId');
                localStorage.removeItem('lastActiveVaultId');
                vaults.clear();
                activeVaultId = null;
                document.getElementById('chat-window').innerHTML = '';
                document.getElementById('vault-list').innerHTML = '';
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('current-user-id').textContent = 'Nuked! Reopen for new ID.';

                // Inform server to remove user's data
                sendMessageToServer({ type: 'nuke', userId: userId });

                // Simulate closing the page by clearing content and displaying a message
                document.body.innerHTML = `
                    <div class="flex flex-col items-center justify-center min-h-screen bg-gray-100 text-gray-700">
                        <h1 class="text-4xl font-bold mb-4">Data Nuked!</h1>
                        <p class="text-lg">All your local data has been wiped.</p>
                        <p class="text-lg">To start fresh, please reopen "The Platform".</p>
                    </div>
                `;
            });
        }


        // --- UI Rendering ---

        /**
         * Renders the list of vaults in the sidebar.
         */
        function renderVaultList() {
            const vaultListDiv = document.getElementById('vault-list');
            vaultListDiv.innerHTML = '';
            if (vaults.size === 0) {
                vaultListDiv.innerHTML = '<p class="text-center text-gray-500 text-sm mt-4">No vaults yet. Create or join one!</p>';
            }
            vaults.forEach(vault => {
                const vaultItem = document.createElement('div');
                vaultItem.className = `vault-item ${activeVaultId === vault.id ? 'active' : ''}`;
                vaultItem.dataset.vaultId = vault.id;
                vaultItem.innerHTML = `
                    <span>${vault.name} (${vault.type === 'private' ? 'DM' : 'Group'})</span>
                    <span class="text-xs text-gray-500">${vault.expiration === 'never' ? 'Never Exp.' : `Exp: ${vault.expiration}`}</span>
                `;
                vaultItem.addEventListener('click', () => selectVault(vault.id));
                vaultListDiv.appendChild(vaultItem);
            });
        }

        /**
         * Displays a single message in the chat window.
         * @param {object} message - The message object.
         */
        function displayMessage(message) {
            const chatWindow = document.getElementById('chat-window');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.sender === userId ? 'self' : 'other'}`;

            const senderSpan = document.createElement('div');
            senderSpan.className = 'message-sender';
            senderSpan.textContent = message.sender === userId ? 'You' : `User: ${message.sender.substring(0, 8)}...`;
            messageDiv.appendChild(senderSpan);

            if (message.isFile) {
                const fileLink = document.createElement('div');
                fileLink.className = 'message-file';
                fileLink.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path d="M19.5 7.5c-1.25 0-2.5.31-3.57.88-.85.45-1.48 1.12-1.87 1.94-.17.36-.31.75-.41 1.15a.75.75 0 0 1-1.09-.72c.16-.49.37-.96.6-1.42.34-.67.79-1.28 1.34-1.83 1.04-1.04 2.39-1.66 3.86-1.8.02-.01.04-.02.06-.02a.75.75 0 0 1 .78 1.25c-.06.05-.12.09-.18.14-.8.6-1.25 1.4-1.25 2.25v.75h.75c.85 0 1.65-.45 2.25-1.25.05-.06.09-.12.14-.18a.75.75 0 0 1 1.25.78c-.01.02-.02.04-.02.06-.14 1.47-.76 2.82-1.8 3.86-1.04 1.04-2.39 1.66-3.86 1.8-.02.01-.04.02-.06.02a.75.75 0 0 1-.78-1.25c.06-.05.12-.09.18-.14.8-.6 1.25-1.4 1.25-2.25V7.5h-.75Zm-10.5 0c-1.25 0-2.5.31-3.57.88-.85.45-1.48 1.12-1.87 1.94-.17.36-.31.75-.41 1.15a.75.75 0 0 1-1.09-.72c.16-.49.37-.96.6-1.42.34-.67.79-1.28 1.34-1.83 1.04-1.04 2.39-1.66 3.86-1.8.02-.01.04-.02.06-.02a.75.75 0 0 1 .78 1.25c-.06.05-.12.09-.18.14-.8.6-1.25 1.4-1.25 2.25v.75h.75c.85 0 1.65-.45 2.25-1.25.05-.06.09-.12.14-.18a.75.75 0 0 1 1.25.78c-.01.02-.02.04-.02.06-.14 1.47-.76 2.82-1.8 3.86-1.04 1.04-2.39 1.66-3.86 1.8-.02.01-.04.02-.06.02a.75.75 0 0 1-.78-1.25c.06-.05.12-.09.18-.14.8-.6 1.25-1.4 1.25-2.25V7.5h-.75Z" />
                    </svg>
                    <span>${message.fileName || 'File'}</span>
                `;
                fileLink.addEventListener('click', () => downloadFile(message.content, message.fileName, message.fileMimeType));
                messageDiv.appendChild(fileLink);
            } else {
                const contentSpan = document.createElement('div');
                contentSpan.className = 'message-content';
                contentSpan.textContent = message.content;
                messageDiv.appendChild(contentSpan);
            }

            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = new Date(message.timestamp).toLocaleTimeString();
            messageDiv.appendChild(timestampSpan);

            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight; // Scroll to bottom
        }

        /**
         * Renders all messages for the currently selected vault.
         * @param {string} vaultId - The ID of the vault whose messages to render.
         */
        function renderChatMessages(vaultId) {
            const chatWindow = document.getElementById('chat-window');
            chatWindow.innerHTML = ''; // Clear previous messages
            const vault = vaults.get(vaultId);
            if (vault && vault.messages) {
                // Sort messages by timestamp to ensure correct order
                vault.messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                vault.messages.forEach(msg => displayMessage(msg));
            }
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /**
         * Selects a vault and displays its chat.
         * @param {string} vaultId - The ID of the vault to select.
         */
        function selectVault(vaultId) {
            if (!vaults.has(vaultId)) {
                console.warn(`Attempted to select non-existent vault: ${vaultId}`);
                showMessageBox('Vault Not Found', 'This vault no longer exists locally. It might have expired or been removed.');
                activeVaultId = null;
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                renderVaultList(); // Re-render to ensure no vault is marked active
                return;
            }

            activeVaultId = vaultId;
            localStorage.setItem('lastActiveVaultId', vaultId); // Using localStorage for persistence
            renderVaultList(); // Update active class
            document.getElementById('no-vault-selected').classList.add('hidden');
            document.getElementById('chat-window').classList.remove('hidden');
            document.getElementById('chat-input-area').classList.remove('hidden');
            renderChatMessages(vaultId);
            document.getElementById('message-input').focus();
            console.log(`Selected vault: ${vaults.get(vaultId).name} (${vaultId})`);

            // P2P: If it's a private vault, try to establish P2P connection with the other participant
            const vault = vaults.get(vaultId);
            if (vault.type === 'private' && vault.participants.length === 2) {
                const otherParticipantId = vault.participants.find(pId => pId !== userId);
                if (otherParticipantId) {
                    // Initiate P2P connection if not already established
                    if (!peerConnections.has(otherParticipantId) || dataChannels.get(otherParticipantId)?.readyState !== 'open') {
                        setupPeerConnection(otherParticipantId, vaultId, true); // This client is the initiator
                    }
                }
            }
        }

        /**
         * Sends a message to the WebSocket server.
         * @param {object} message - The message object to send.
         */
        function sendMessageToServer(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                showMessageBox('Connection Error', 'Not connected to server. Please wait or refresh.');
                console.warn("Attempted to send message while WebSocket is not open.", message);
            }
        }

        // --- Local Storage Management ---

        /**
         * Saves all vaults data to localStorage.
         * Note: CryptoKey objects cannot be directly stored. We export them to raw ArrayBuffer (Base64)
         * and re-import them when loading.
         */
        async function saveVaultsToLocalStorage() {
            console.log("Saving vaults to localStorage...");
            const serializableVaults = [];
            for (const [id, vault] of vaults.entries()) {
                try {
                    const exportedKey = await exportKey(vault.key);
                    serializableVaults.push({
                        id: vault.id,
                        name: vault.name,
                        type: vault.type,
                        expiration: vault.expiration,
                        key: btoa(String.fromCharCode(...new Uint8Array(exportedKey))), // Base64 encode key
                        messages: vault.messages, // Messages are already serializable
                        participants: vault.participants || [] // Save participants
                    });
                } catch (e) {
                    console.error(`Failed to export key for vault ${id}:`, e);
                    // Optionally, remove this vault from the list to be saved if its key is corrupted
                }
            }
            try {
                localStorage.setItem('thePlatformVaults', JSON.stringify(serializableVaults));
                console.log("Vaults successfully saved to localStorage.");
            } catch (e) {
                console.error("Error saving vaults to localStorage:", e);
                showMessageBox('Storage Error', 'Could not save data to local storage. Your browser might be full or private browsing is enabled.');
            }
        }

        /**
         * Loads vaults data from localStorage.
         */
        async function loadVaultsFromLocalStorage() {
            console.log("Loading vaults from localStorage...");
            const storedVaults = localStorage.getItem('thePlatformVaults');
            vaults.clear(); // Clear existing vaults before loading
            if (storedVaults) {
                try {
                    const parsedVaults = JSON.parse(storedVaults);
                    for (const serializedVault of parsedVaults) {
                        try {
                            const importedKey = await importKey(Uint8Array.from(atob(serializedVault.key), c => c.charCodeAt(0)));
                            vaults.set(serializedVault.id, {
                                id: serializedVault.id,
                                name: serializedVault.name,
                                type: serializedVault.type,
                                expiration: serializedVault.expiration,
                                key: importedKey,
                                messages: serializedVault.messages || [],
                                participants: serializedVault.participants || [] // Load participants
                            });
                            console.log(`Loaded vault: ${serializedVault.name} (${serializedVault.id})`);
                        } catch (e) {
                            console.error(`Failed to load vault ${serializedVault.id} from localStorage (key import failed):`, e);
                            // This vault might be corrupted or key unimportable, skip it.
                        }
                    }
                    console.log(`Finished loading ${vaults.size} vaults from localStorage.`);
                    renderVaultList();
                    // If there are vaults, select the first one by default or previously active
                    if (vaults.size > 0) {
                        const lastActiveVaultId = localStorage.getItem('lastActiveVaultId');
                        if (lastActiveVaultId && vaults.has(lastActiveVaultId)) {
                            selectVault(lastActiveVaultId);
                        } else {
                            selectVault(vaults.keys().next().value); // Select the first available vault
                        }
                    } else {
                        console.log("No vaults found in localStorage.");
                        document.getElementById('no-vault-selected').classList.remove('hidden');
                        document.getElementById('chat-window').classList.add('hidden');
                        document.getElementById('chat-input-area').classList.add('hidden');
                    }
                } catch (e) {
                    console.error("Error parsing vaults from localStorage:", e);
                    showMessageBox('Data Corruption', 'Local vault data is corrupted. Clearing data and starting fresh.');
                    localStorage.removeItem('thePlatformVaults'); // Clear corrupted data
                    // Reload the page or simply continue with empty vaults
                    renderVaultList();
                }
            } else {
                console.log("No vaults found in localStorage initially.");
            }
        }

        /**
         * Clears all local data (vaults, messages, user ID).
         */
        function nukeAllData() {
            showMessageBox('Confirm Nuke', 'Are you sure you want to wipe ALL your local data and disconnect? This action cannot be undone. This will also attempt to clear your data on the server.', async () => {
                localStorage.removeItem('thePlatformVaults');
                localStorage.removeItem('thePlatformUserId');
                localStorage.removeItem('lastActiveVaultId');
                vaults.clear();
                activeVaultId = null;
                document.getElementById('chat-window').innerHTML = '';
                document.getElementById('vault-list').innerHTML = '';
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('current-user-id').textContent = 'Nuked! Reopen for new ID.';

                // Inform server to remove user's data
                sendMessageToServer({ type: 'nuke', userId: userId });

                // Simulate closing the page by clearing content and displaying a message
                document.body.innerHTML = `
                    <div class="flex flex-col items-center justify-center min-h-screen bg-gray-100 text-gray-700">
                        <h1 class="text-4xl font-bold mb-4">Data Nuked!</h1>
                        <p class="text-lg">All your local data has been wiped.</p>
                        <p class="text-lg">To start fresh, please reopen "The Platform".</p>
                    </div>
                `;
            });
        }


        // --- UI Rendering ---

        /**
         * Renders the list of vaults in the sidebar.
         */
        function renderVaultList() {
            const vaultListDiv = document.getElementById('vault-list');
            vaultListDiv.innerHTML = '';
            if (vaults.size === 0) {
                vaultListDiv.innerHTML = '<p class="text-center text-gray-500 text-sm mt-4">No vaults yet. Create or join one!</p>';
            }
            vaults.forEach(vault => {
                const vaultItem = document.createElement('div');
                vaultItem.className = `vault-item ${activeVaultId === vault.id ? 'active' : ''}`;
                vaultItem.dataset.vaultId = vault.id;
                vaultItem.innerHTML = `
                    <span>${vault.name} (${vault.type === 'private' ? 'DM' : 'Group'})</span>
                    <span class="text-xs text-gray-500">${vault.expiration === 'never' ? 'Never Exp.' : `Exp: ${vault.expiration}`}</span>
                `;
                vaultItem.addEventListener('click', () => selectVault(vault.id));
                vaultListDiv.appendChild(vaultItem);
            });
        }

        /**
         * Displays a single message in the chat window.
         * @param {object} message - The message object.
         */
        function displayMessage(message) {
            const chatWindow = document.getElementById('chat-window');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.sender === userId ? 'self' : 'other'}`;

            const senderSpan = document.createElement('div');
            senderSpan.className = 'message-sender';
            senderSpan.textContent = message.sender === userId ? 'You' : `User: ${message.sender.substring(0, 8)}...`;
            messageDiv.appendChild(senderSpan);

            if (message.isFile) {
                const fileLink = document.createElement('div');
                fileLink.className = 'message-file';
                fileLink.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path d="M19.5 7.5c-1.25 0-2.5.31-3.57.88-.85.45-1.48 1.12-1.87 1.94-.17.36-.31.75-.41 1.15a.75.75 0 0 1-1.09-.72c.16-.49.37-.96.6-1.42.34-.67.79-1.28 1.34-1.83 1.04-1.04 2.39-1.66 3.86-1.8.02-.01.04-.02.06-.02a.75.75 0 0 1 .78 1.25c-.06.05-.12.09-.18.14-.8.6-1.25 1.4-1.25 2.25v.75h.75c.85 0 1.65-.45 2.25-1.25.05-.06.09-.12.14-.18a.75.75 0 0 1 1.25.78c-.01.02-.02.04-.02.06-.14 1.47-.76 2.82-1.8 3.86-1.04 1.04-2.39 1.66-3.86 1.8-.02.01-.04.02-.06.02a.75.75 0 0 1-.78-1.25c.06-.05.12-.09.18-.14.8-.6 1.25-1.4 1.25-2.25V7.5h-.75Zm-10.5 0c-1.25 0-2.5.31-3.57.88-.85.45-1.48 1.12-1.87 1.94-.17.36-.31.75-.41 1.15a.75.75 0 0 1-1.09-.72c.16-.49.37-.96.6-1.42.34-.67.79-1.28 1.34-1.83 1.04-1.04 2.39-1.66 3.86-1.8.02-.01.04-.02.06-.02a.75.75 0 0 1 .78 1.25c-.06.05-.12.09-.18.14-.8.6-1.25 1.4-1.25 2.25v.75h.75c.85 0 1.65-.45 2.25-1.25.05-.06.09-.12.14-.18a.75.75 0 0 1 1.25.78c-.01.02-.02.04-.02.06-.14 1.47-.76 2.82-1.8 3.86-1.04 1.04-2.39 1.66-3.86 1.8-.02.01-.04.02-.06.02a.75.75 0 0 1-.78-1.25c.06-.05.12-.09.18-.14.8-.6 1.25-1.4 1.25-2.25V7.5h-.75Z" />
                    </svg>
                    <span>${message.fileName || 'File'}</span>
                `;
                fileLink.addEventListener('click', () => downloadFile(message.content, message.fileName, message.fileMimeType));
                messageDiv.appendChild(fileLink);
            } else {
                const contentSpan = document.createElement('div');
                contentSpan.className = 'message-content';
                contentSpan.textContent = message.content;
                messageDiv.appendChild(contentSpan);
            }

            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = new Date(message.timestamp).toLocaleTimeString();
            messageDiv.appendChild(timestampSpan);

            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight; // Scroll to bottom
        }

        /**
         * Renders all messages for the currently selected vault.
         * @param {string} vaultId - The ID of the vault whose messages to render.
         */
        function renderChatMessages(vaultId) {
            const chatWindow = document.getElementById('chat-window');
            chatWindow.innerHTML = ''; // Clear previous messages
            const vault = vaults.get(vaultId);
            if (vault && vault.messages) {
                // Sort messages by timestamp to ensure correct order
                vault.messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                vault.messages.forEach(msg => displayMessage(msg));
            }
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /**
         * Selects a vault and displays its chat.
         * @param {string} vaultId - The ID of the vault to select.
         */
        function selectVault(vaultId) {
            if (!vaults.has(vaultId)) {
                console.warn(`Attempted to select non-existent vault: ${vaultId}`);
                showMessageBox('Vault Not Found', 'This vault no longer exists locally. It might have expired or been removed.');
                activeVaultId = null;
                document.getElementById('no-vault-selected').classList.remove('hidden');
                document.getElementById('chat-window').classList.add('hidden');
                document.getElementById('chat-input-area').classList.add('hidden');
                renderVaultList(); // Re-render to ensure no vault is marked active
                return;
            }

            activeVaultId = vaultId;
            localStorage.setItem('lastActiveVaultId', vaultId); // Using localStorage for persistence
            renderVaultList(); // Update active class
            document.getElementById('no-vault-selected').classList.add('hidden');
            document.getElementById('chat-window').classList.remove('hidden');
            document.getElementById('chat-input-area').classList.remove('hidden');
            renderChatMessages(vaultId);
            document.getElementById('message-input').focus();
            console.log(`Selected vault: ${vaults.get(vaultId).name} (${vaultId})`);

            // P2P: If it's a private vault, try to establish P2P connection with the other participant
            const vault = vaults.get(vaultId);
            if (vault.type === 'private' && vault.participants.length === 2) {
                const otherParticipantId = vault.participants.find(pId => pId !== userId);
                if (otherParticipantId) {
                    // Initiate P2P connection if not already established
                    if (!peerConnections.has(otherParticipantId) || dataChannels.get(otherParticipantId)?.readyState !== 'open') {
                        setupPeerConnection(otherParticipantId, vaultId, true); // This client is the initiator
                    }
                }
            }
        }

        // --- Event Listeners and Initial Setup ---

        document.addEventListener('DOMContentLoaded', () => {
            // Generate or retrieve unique user ID from localStorage
            userId = localStorage.getItem('thePlatformUserId');
            if (!userId) {
                userId = crypto.randomUUID(); // Generate a new complex random ID
                localStorage.setItem('thePlatformUserId', userId);
                console.log(`Generated new user ID: ${userId}`);
            } else {
                console.log(`Loaded existing user ID: ${userId}`);
            }
            document.getElementById('current-user-id').textContent = userId;

            initWebSocket(); // Initialize WebSocket connection

            // Modals
            const createVaultModal = document.getElementById('create-vault-modal');
            const joinVaultModal = document.getElementById('join-vault-modal');
            const createVaultBtn = document.getElementById('create-vault-btn');
            const joinVaultBtn = document.getElementById('join-vault-btn');
            const createVaultClose = document.getElementById('create-vault-close');
            const joinVaultClose = document.getElementById('join-vault-close');

            createVaultBtn.addEventListener('click', () => {
                createVaultModal.classList.add('show');
                document.getElementById('create-vault-hash-display').classList.add('hidden'); // Hide hash display initially
                document.getElementById('create-vault-form').reset(); // Clear form
            });
            joinVaultBtn.addEventListener('click', () => {
                joinVaultModal.classList.add('show');
                document.getElementById('join-vault-form').reset(); // Clear form
            });
            createVaultClose.addEventListener('click', () => createVaultModal.classList.remove('show'));
            joinVaultClose.addEventListener('click', () => joinVaultModal.classList.remove('show'));

            // Create Vault Form Submission
            document.getElementById('create-vault-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const vaultName = document.getElementById('vault-name').value;
                const vaultType = document.getElementById('vault-type').value;
                const expirationTime = document.getElementById('expiration-time').value;

                // Generate a new AES key for the vault
                const vaultAesKey = await generateAesKey();
                const rawVaultAesKey = await exportKey(vaultAesKey);

                // Generate a random salt for PBKDF2
                const salt = crypto.getRandomValues(new Uint8Array(16));

                // Send request to server to create vault. Server will generate hash and encrypt the vault key.
                // Include current userId in participants for server to store
                sendMessageToServer({
                    type: 'create_vault',
                    userId: userId,
                    vaultName: vaultName,
                    vaultType: vaultType,
                    expiration: expirationTime,
                    rawVaultKeyB64: btoa(String.fromCharCode(...new Uint8Array(rawVaultAesKey))), // Send raw key to server for encryption
                    saltB64: btoa(String.fromCharCode(...salt)), // Send salt to server
                    participants: [userId] // Initial participant list
                });

                // The vault_created message from server will handle adding to local vaults and UI update
            });

            // Copy Hash Button
            // FIX: Added type="button" to prevent accidental form submission
            document.getElementById('copy-hash-btn').addEventListener('click', () => {
                const hash = document.getElementById('generated-vault-hash').textContent;
                if (hash) {
                    copyToClipboard(hash);
                }
            });

            // Join Vault Form Submission
            document.getElementById('join-vault-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const joinVaultHash = document.getElementById('join-vault-hash').value;
                const joinVaultName = document.getElementById('join-vault-name').value;

                sendMessageToServer({
                    type: 'join_vault',
                    userId: userId,
                    vaultHash: joinVaultHash,
                    vaultName: joinVaultName // User-given name for their reference
                });
                joinVaultModal.classList.remove('show');
            });

            // Universal Send Message Function (handles P2P fallback)
            async function sendMessage(messageText, file) {
                if (!activeVaultId) {
                    showMessageBox('No Vault Selected', 'Please select a vault to send messages.');
                    return;
                }

                if (!messageText && !file) {
                    return; // Don't send empty messages
                }

                const vault = vaults.get(activeVaultId);
                if (!vault) {
                    showMessageBox('Error', 'Active vault not found. Please re-select or refresh.');
                    console.error("Attempted to send message to a non-existent active vault.");
                    return;
                }

                const timestamp = new Date().toISOString();
                const fileId = crypto.randomUUID(); // Unique ID for this file transfer

                let sentViaP2P = false;

                // Attempt P2P for private vaults if connection is established
                if (vault.type === 'private' && vault.participants.length === 2) {
                    const otherParticipantId = vault.participants.find(pId => pId !== userId);
                    const dc = dataChannels.get(otherParticipantId);

                    if (dc && dc.readyState === 'open') {
                        try {
                            if (file) {
                                const fileSize = file.size;
                                const totalChunks = Math.ceil(fileSize / CHUNK_SIZE);

                                // Display placeholder for sender
                                const localFileMessageObj = {
                                    sender: userId,
                                    content: `Sending file: ${file.name} (${(fileSize / 1024).toFixed(2)} KB) via P2P...`,
                                    timestamp: timestamp,
                                    isFile: false,
                                    fileName: file.name,
                                    fileMimeType: file.type,
                                    fileId: fileId
                                };
                                vault.messages.push(localFileMessageObj);
                                displayMessage(localFileMessageObj);
                                await saveVaultsToLocalStorage();

                                for (let i = 0; i < totalChunks; i++) {
                                    const start = i * CHUNK_SIZE;
                                    const end = Math.min(start + CHUNK_SIZE, fileSize);
                                    const chunk = file.slice(start, end);

                                    const reader = new FileReader();
                                    reader.onload = async (e) => {
                                        const rawChunkBase64 = e.target.result.split(',')[1]; // Get raw Base64 part
                                        const { encryptedMessage: encryptedChunk, iv: chunkIv } = await encryptMessage(rawChunkBase64, vault.key);

                                        const p2pChunkMessage = {
                                            type: 'file_chunk', // Specific type for P2P file chunks
                                            vaultId: activeVaultId,
                                            senderId: userId,
                                            encryptedMessage: encryptedChunk,
                                            iv: chunkIv,
                                            timestamp: timestamp,
                                            isFile: true,
                                            fileId: fileId,
                                            chunkIndex: i,
                                            totalChunks: totalChunks,
                                            fileName: file.name,
                                            fileMimeType: file.type
                                        };
                                        dc.send(JSON.stringify(p2pChunkMessage));

                                        if (i === totalChunks - 1) {
                                            // Update local message to actual file after all chunks sent
                                            const indexToUpdate = vault.messages.findIndex(msg => msg.fileId === fileId);
                                            if (indexToUpdate !== -1) {
                                                vault.messages[indexToUpdate].content = await fileToBase64(file); // Store full Data URL
                                                vault.messages[indexToUpdate].isFile = true;
                                                delete vault.messages[indexToUpdate].fileId; // Remove temporary fileId
                                            }
                                            renderChatMessages(activeVaultId);
                                            await saveVaultsToLocalStorage();
                                            showMessageBox('File Sent (P2P)', `File "${file.name}" sent successfully via P2P.`);
                                        }
                                    };
                                    reader.onerror = (error) => {
                                        console.error("Error reading file chunk for P2P:", error);
                                        showMessageBox('File Error (P2P)', 'Failed to read file chunk. Falling back to server.');
                                        sentViaP2P = false; // Force fallback
                                    };
                                    reader.readAsDataURL(chunk);
                                }
                                sentViaP2P = true; // Mark as attempted P2P send
                            } else { // Regular text message via P2P
                                const { encryptedMessage, iv } = await encryptMessage(messageText, vault.key);
                                const p2pMessage = {
                                    type: 'chat_message', // New type for P2P messages
                                    vaultId: activeVaultId,
                                    senderId: userId,
                                    encryptedMessage: encryptedMessage,
                                    iv: iv,
                                    timestamp: timestamp,
                                    isFile: false
                                };
                                dc.send(JSON.stringify(p2pMessage));
                                sentViaP2P = true;

                                // Update local UI immediately for P2P
                                const localMessageObj = {
                                    sender: userId,
                                    content: messageText,
                                    timestamp: timestamp,
                                    isFile: false
                                };
                                vault.messages.push(localMessageObj);
                                displayMessage(localMessageObj);
                                await saveVaultsToLocalStorage();
                                showMessageBox('Message Sent (P2P)', `Message sent via P2P.`);
                            }
                        } catch (p2pError) {
                            console.error("P2P send failed, falling back to server:", p2pError);
                            sentViaP2P = false; // Force fallback
                        }
                    }
                }

                // Fallback to server relay if P2P not attempted or failed
                if (!sentViaP2P) {
                    console.log("Sending via server relay.");
                    if (file) {
                        const fileSize = file.size;

                        if (fileSize <= CHUNK_SIZE) { // Send as a single message if small enough
                            const base64File = await fileToBase64(file);
                            const rawBase64Content = base64File.split(',')[1]; // Get raw Base64 part
                            const { encryptedMessage, iv } = await encryptMessage(rawBase64Content, vault.key);

                            const localFileMessageObj = {
                                sender: userId,
                                content: base64File, // Store full Data URL for local display
                                timestamp: timestamp,
                                isFile: true,
                                fileName: file.name,
                                fileMimeType: file.type
                            };
                            vault.messages.push(localFileMessageObj);
                            displayMessage(localFileMessageObj);
                            await saveVaultsToLocalStorage();

                            sendMessageToServer({
                                type: 'send_message',
                                vaultId: activeVaultId,
                                senderId: userId,
                                encryptedMessage: encryptedMessage, // This is raw Base64
                                iv: iv,
                                timestamp: timestamp,
                                isFile: true,
                                fileName: file.name,
                                fileMimeType: file.type,
                                fileId: fileId, // Always include fileId for consistency
                                chunkIndex: 0,
                                totalChunks: 1 // Indicate it's a single chunk
                            });
                            showMessageBox('File Sent (Server)', `File "${file.name}" sent successfully via server.`);
                        } else { // Send in chunks via server
                            const totalChunks = Math.ceil(fileSize / CHUNK_SIZE);

                            // Display a placeholder message immediately for the sender's UI
                            const localFileMessageObj = {
                                sender: userId,
                                content: `Sending file: ${file.name} (${(fileSize / 1024).toFixed(2)} KB) via server...`,
                                timestamp: timestamp,
                                isFile: false, // Temporarily display as text, will update once fully sent
                                fileName: file.name,
                                fileMimeType: file.type,
                                fileId: fileId // Store fileId to find and update this message later
                            };
                            vault.messages.push(localFileMessageObj);
                            displayMessage(localFileMessageObj);
                            await saveVaultsToLocalStorage();

                            for (let i = 0; i < totalChunks; i++) {
                                const start = i * CHUNK_SIZE;
                                const end = Math.min(start + CHUNK_SIZE, fileSize);
                                const chunk = file.slice(start, end);

                                const reader = new FileReader();
                                reader.onload = async (e) => {
                                    const rawChunkBase64 = e.target.result.split(',')[1]; // Get raw Base64 part
                                    const { encryptedMessage, iv } = await encryptMessage(rawChunkBase64, vault.key);

                                    sendMessageToServer({
                                        type: 'send_message', // Server will relay this as 'new_message'
                                        vaultId: activeVaultId,
                                        senderId: userId,
                                        encryptedMessage: encryptedMessage, // This is raw Base64
                                        iv: iv,
                                        timestamp: timestamp,
                                        isFile: true, // It is a file chunk
                                        fileId: fileId, // Unique ID for the whole file
                                        chunkIndex: i,
                                        totalChunks: totalChunks,
                                        fileName: file.name,
                                        fileMimeType: file.type
                                    });

                                    if (i === totalChunks - 1) {
                                        // Last chunk sent, update sender's local message to actual file
                                        const indexToUpdate = vault.messages.findIndex(msg => msg.fileId === fileId);
                                        if (indexToUpdate !== -1) {
                                            vault.messages[indexToUpdate].content = await fileToBase64(file); // Store full Data URL
                                            vault.messages[indexToUpdate].isFile = true;
                                            delete vault.messages[indexToUpdate].fileId; // Remove temporary fileId
                                        }
                                        renderChatMessages(activeVaultId); // Re-render to show the actual file
                                        await saveVaultsToLocalStorage();
                                        showMessageBox('File Sent (Server)', `File "${file.name}" sent successfully via server.`);
                                    }
                                };
                                reader.onerror = (error) => {
                                    console.error("Error reading file chunk for server relay:", error);
                                    showMessageBox('File Error (Server)', 'Failed to read file chunk. Please try again.');
                                };
                                reader.readAsDataURL(chunk); // Read as data URL to include mime type for each chunk (though overall mimeType is sent once)
                            }
                        }
                    } else {
                        // Handle regular text message via server
                        try {
                            const { encryptedMessage, iv } = await encryptMessage(messageText, vault.key);
                            const localMessageObj = {
                                sender: userId,
                                content: messageText,
                                timestamp: timestamp,
                                isFile: false
                            };
                            vault.messages.push(localMessageObj);
                            displayMessage(localMessageObj); // Display immediately
                            await saveVaultsToLocalStorage(); // Ensure local storage is updated

                            // Now send the encrypted message to the server
                            sendMessageToServer({
                                type: 'send_message',
                                vaultId: activeVaultId,
                                senderId: userId,
                                encryptedMessage: encryptedMessage,
                                iv: iv,
                                timestamp: localMessageObj.timestamp,
                                isFile: false
                            });
                            showMessageBox('Message Sent (Server)', `Message sent successfully via server.`);
                        } catch (error) {
                            console.error("Error encrypting message for server relay:", error);
                            showMessageBox('Encryption Error', 'Failed to encrypt message. Please try again.');
                        }
                    }
                }
                messageInput.value = ''; // Clear text input
                fileInput.value = ''; // Clear file input
            }


            document.getElementById('send-message-btn').addEventListener('click', async () => {
                const messageInput = document.getElementById('message-input');
                const fileInput = document.getElementById('file-input');
                const messageText = messageInput.value.trim();
                const file = fileInput.files[0];
                await sendMessage(messageText, file);
            });

            // Attach File Button
            document.getElementById('attach-file-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            // Nuke Button
            document.getElementById('nuke-btn').addEventListener('click', nukeAllData); // Call nukeAllData directly as it has its own confirmation

            // Handle Enter key for sending messages
            document.getElementById('message-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('send-message-btn').click();
                }
            });
        });
    </script>
</body>
</html>
